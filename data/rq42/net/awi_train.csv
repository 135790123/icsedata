,source,target
0,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
1,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
2,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
3,"@Deprecated
public static String PROVIDER;",0
4,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
5,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
6,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
7,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
8,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
9,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
10,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
11,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
12,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
13,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
14,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
15,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
16,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
17,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
18,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
19,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
20,public int size;,0
21,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
22,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
23,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
24,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
25,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
26,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
27,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
28,"public int[] startSubnegotiationRemote() {
return null;
}",0
29,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
30,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
31,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
32,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
33,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
34,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
35,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
36,"public InputStream getInputStream(boolean longOutput, String username, String encoding) throws IOException {
DataOutputStream output;
StringBuilder buffer = new StringBuilder(64);
if (longOutput) {
buffer.append(__LONG_FLAG);
}
buffer.append(username);
buffer.append(SocketClient.NETASCII_EOL);
byte[] encodedQuery = (encoding == null ? buffer.toString().getBytes() : buffer.toString().getBytes(encoding));
output = new DataOutputStream(new BufferedOutputStream(_output_, 1024));
output.write(encodedQuery, 0, encodedQuery.length);
output.flush();
return _input_;
}",0
37,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0
38,"public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, method.getAuthName()))) {
return false;
}
switch(method) {
case PLAIN:
{
int result = sendData(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case CRAM_MD5:
{
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
int result = sendData(new String(Base64.encodeBase64(toEncode)));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case LOGIN:
{
if (sendData(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT) {
return false;
}
int result = sendData(new String(Base64.encodeBase64(password.getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
}
return false;
}",0
39,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
40,"public boolean login(String username, String timestamp, String secret) throws IOException, NoSuchAlgorithmException {
int i;
byte[] digest;
StringBuilder buffer, digestBuffer;
MessageDigest md5;
if (getState() != AUTHORIZATION_STATE) {
return false;
}
md5 = MessageDigest.getInstance(""MD5"");
timestamp += secret;
digest = md5.digest(timestamp.getBytes());
digestBuffer = new StringBuilder(128);
for (i = 0; i < digest.length; i++) {
int digit = digest[i] & 0xff;
if (digit <= 15) {
digestBuffer.append(""0"");
}
digestBuffer.append(Integer.toHexString(digit));
}
buffer = new StringBuilder(256);
buffer.append(username);
buffer.append(' ');
buffer.append(digestBuffer.toString());
if (sendCommand(POP3Command.APOP, buffer.toString()) != POP3Reply.OK) {
return false;
}
setState(TRANSACTION_STATE);
return true;
}",0
41,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
42,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
43,"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
44,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
45,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
46,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
47,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
48,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
49,private final CopyOnWriteArrayList<EventListener> __listeners;,0
50,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
51,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
52,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
53,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
54,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
55,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
56,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
57,"@Deprecated
public static String KEYSTORE_ALGORITHM;",0
58,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
59,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
60,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
61,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
62,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
63,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
64,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
65,"public IOException getIOException() {
return (IOException) getCause();
}",0
66,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
67,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
68,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
69,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
70,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
71,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
72,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
73,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
74,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
75,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
76,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
77,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
78,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
79,public String identifier;,0
80,public int size;,0
81,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
82,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
83,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
84,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
85,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
86,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
87,"public int[] startSubnegotiationRemote() {
return null;
}",0
88,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
89,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
90,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
91,private final CopyOnWriteArrayList<EventListener> __listeners;,0
92,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
93,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
94,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
95,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
96,"@Deprecated
public static String PROVIDER;",0
97,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
98,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
99,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
100,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
101,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
102,"public IOException getIOException() {
return (IOException) getCause();
}",0
103,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
104,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
105,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
106,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
107,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
108,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
109,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
110,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
111,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0
112,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
113,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
114,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
115,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
116,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
117,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
118,"public int[] startSubnegotiationRemote() {
return null;
}",0
119,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
120,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
121,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
122,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
123,"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
124,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
125,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
126,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
127,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
128,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
129,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
130,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
131,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
132,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
133,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
134,"public IOException getIOException() {
return (IOException) getCause();
}",0
135,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
136,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
137,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
138,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
139,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
bogusIdCount++;
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
140,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
141,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
142,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
143,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
144,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
145,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
146,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
147,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
148,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
149,"public int[] startSubnegotiationRemote() {
return null;
}",0
150,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
151,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
152,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
153,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
154,"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
155,private final CopyOnWriteArrayList<EventListener> __listeners;,0
156,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
157,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
158,"InputStream _createErrorStream() throws IOException {
ServerSocket server;
Socket socket;
server = _serverSocketFactory_.createServerSocket(0, 1, getLocalAddress());
_output_.write(Integer.toString(server.getLocalPort()).getBytes());
_output_.write('\0');
_output_.flush();
socket = server.accept();
server.close();
if (__remoteVerificationEnabled && !verifyRemote(socket)) {
socket.close();
throw new IOException(""Security violation: unexpected connection attempt by "" + socket.getInetAddress().getHostAddress());
}
return (new SocketInputStream(socket, socket.getInputStream()));
}",0
159,"public String getTime() throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader reader;
reader = new BufferedReader(new InputStreamReader(_input_));
while (true) {
read = reader.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
return result.toString();
}",0
160,"public String getTime(InetAddress host, int port) throws IOException {
DatagramPacket sendPacket, receivePacket;
sendPacket = new DatagramPacket(__dummyData, __dummyData.length, host, port);
receivePacket = new DatagramPacket(__timeData, __timeData.length);
_socket_.send(sendPacket);
_socket_.receive(receivePacket);
return new String(receivePacket.getData(), 0, receivePacket.getLength());
}",0
161,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
162,"private void readStream(InputStream stream, String encoding) throws IOException {
BufferedReader reader;
if (encoding == null) {
reader = new BufferedReader(new InputStreamReader(stream));
} else {
reader = new BufferedReader(new InputStreamReader(stream, encoding));
}
String line = this.parser.readNextEntry(reader);
while (line != null) {
this.entries.add(line);
line = this.parser.readNextEntry(reader);
}
reader.close();
}",0
163,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
164,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
165,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
166,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
167,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
168,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t);
}
}
root = findRootSet();
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects();
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
root = null;
return result;
}",0
169,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
170,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
171,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
172,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
173,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
174,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
}",0
175,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
176,"public boolean auth(AuthenticatingSMTPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!SMTPReply.isPositiveIntermediate(sendCommand(SMTPCommand.AUTH, AUTH_METHOD.getAuthName(method)))) {
return false;
}
if (method.equals(AUTH_METHOD.PLAIN)) {
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))));
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(4).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(toEncode))));
} else if (method.equals(AUTH_METHOD.LOGIN)) {
if (!SMTPReply.isPositiveIntermediate(sendCommand(new String(Base64.encodeBase64(username.getBytes()))))) {
return false;
}
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(password.getBytes()))));
} else {
return false;
}
}",0
177,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
}",0
178,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
179,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
180,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
181,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
182,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
183,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
184,"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
185,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
186,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
187,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
188,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
189,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
190,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
191,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
192,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
193,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
194,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
195,"@Deprecated
public static String STORE_TYPE;",0
196,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
197,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
198,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
199,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
200,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
201,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
202,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
203,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
204,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
205,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
206,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
207,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0
208,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
209,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
210,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
211,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
212,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
213,"public int[] startSubnegotiationLocal() {
return null;
}",0
214,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
215,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _fileName.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_fileName.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
216,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _fileName.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_fileName.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
217,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
218,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
219,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
220,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
221,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
222,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
223,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
224,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
225,"@Deprecated
public static String STORE_TYPE;",0
226,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
227,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
228,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
229,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
230,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
231,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
232,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
233,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
234,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
235,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
236,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
237,public String identifier;,0
238,public int size;,0
239,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
240,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
241,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
242,"public int[] startSubnegotiationLocal() {
return null;
}",0
243,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
244,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
245,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
246,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
247,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
248,private final CopyOnWriteArrayList<EventListener> __listeners;,0
249,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
250,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
251,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
252,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
253,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
254,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
255,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
256,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
257,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
258,"public IOException getIOException() {
return (IOException) getCause();
}",0
259,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
260,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
261,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
262,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
263,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
bogusIdCount++;
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
264,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
265,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
266,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
267,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
268,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
269,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
270,"public int[] startSubnegotiationRemote() {
return null;
}",0
271,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
272,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
273,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
274,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
275,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
276,"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
277,private final CopyOnWriteArrayList<EventListener> __listeners;,0
278,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
279,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
280,"@Override
InputStream _createErrorStream() throws IOException {
int localPort;
ServerSocket server;
Socket socket;
localPort = MAX_CLIENT_PORT;
server = null;
for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort) {
try {
server = _serverSocketFactory_.createServerSocket(localPort, 1, getLocalAddress());
break;
} catch (SocketException e) {
continue;
}
}
if (server == null) {
throw new BindException(""All ports in use."");
}
_output_.write(Integer.toString(server.getLocalPort()).getBytes());
_output_.write('\0');
_output_.flush();
socket = server.accept();
server.close();
if (isRemoteVerificationEnabled() && !verifyRemote(socket)) {
socket.close();
throw new IOException(""Security violation: unexpected connection attempt by "" + socket.getInetAddress().getHostAddress());
}
return (new SocketInputStream(socket, socket.getInputStream()));
}",0
281,"public void rexec(String username, String password, String command, boolean separateErrorStream) throws IOException {
int ch;
if (separateErrorStream) {
_errorStream_ = _createErrorStream();
} else {
_output_.write('\0');
}
_output_.write(username.getBytes());
_output_.write('\0');
_output_.write(password.getBytes());
_output_.write('\0');
_output_.write(command.getBytes());
_output_.write('\0');
_output_.flush();
ch = _input_.read();
if (ch > 0) {
StringBuilder buffer = new StringBuilder();
while ((ch = _input_.read()) != -1 && ch != '\n') {
buffer.append((char) ch);
}
throw new IOException(buffer.toString());
} else if (ch < 0) {
throw new IOException(""Server closed connection."");
}
}",0
282,"InputStream _createErrorStream() throws IOException {
ServerSocket server;
Socket socket;
server = _serverSocketFactory_.createServerSocket(0, 1, getLocalAddress());
_output_.write(Integer.toString(server.getLocalPort()).getBytes());
_output_.write('\0');
_output_.flush();
socket = server.accept();
server.close();
if (__remoteVerificationEnabled && !verifyRemote(socket)) {
socket.close();
throw new IOException(""Security violation: unexpected connection attempt by "" + socket.getInetAddress().getHostAddress());
}
return (new SocketInputStream(socket, socket.getInputStream()));
}",0
283,"public String getTime() throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader reader;
reader = new BufferedReader(new InputStreamReader(_input_));
while (true) {
read = reader.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
return result.toString();
}",0
284,"public String getTime(InetAddress host, int port) throws IOException {
DatagramPacket sendPacket, receivePacket;
sendPacket = new DatagramPacket(__dummyData, __dummyData.length, host, port);
receivePacket = new DatagramPacket(__timeData, __timeData.length);
_socket_.send(sendPacket);
_socket_.receive(receivePacket);
return new String(receivePacket.getData(), 0, receivePacket.getLength());
}",0
285,"public InputStream getInputStream(boolean longOutput, String username, String encoding) throws IOException {
DataOutputStream output;
StringBuilder buffer = new StringBuilder(64);
if (longOutput) {
buffer.append(__LONG_FLAG);
}
buffer.append(username);
buffer.append(SocketClient.NETASCII_EOL);
byte[] encodedQuery = (encoding == null ? buffer.toString().getBytes() : buffer.toString().getBytes(encoding));
output = new DataOutputStream(new BufferedOutputStream(_output_, 1024));
output.write(encodedQuery, 0, encodedQuery.length);
output.flush();
return _input_;
}",0
286,"public String query(boolean longOutput, String username) throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader input;
input = new BufferedReader(new InputStreamReader(getInputStream(longOutput, username)));
try {
while (true) {
read = input.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
} finally {
input.close();
}
return result.toString();
}",0
287,"public String[] listNames(String pathname) throws IOException {
Socket socket;
if ((socket = _openDataConnection_(FTPCommand.NLST, getListArguments(pathname))) == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
288,"public int execADAT(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ADAT, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ADAT);
}
}",0
289,"@Deprecated
public static String KEYSTORE_ALGORITHM;",0
290,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = _socket_.getInetAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (!isClientMode) {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
}",0
291,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0
292,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0
293,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
294,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
295,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
296,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
297,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t);
}
}
root = findRootSet();
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects();
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
root = null;
return result;
}",0
298,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
299,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
300,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
301,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
302,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
303,"public boolean auth(AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (sendCommand(POP3Command.AUTH, method.getAuthName()) != POP3Reply.OK_INT) {
return false;
}
switch(method) {
case PLAIN:
return sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))) == POP3Reply.OK;
case CRAM_MD5:
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return sendCommand(new String(Base64.encodeBase64(toEncode))) == POP3Reply.OK;
default:
return false;
}
}",0
304,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
305,"public boolean login(String username, String timestamp, String secret) throws IOException, NoSuchAlgorithmException {
int i;
byte[] digest;
StringBuilder buffer, digestBuffer;
MessageDigest md5;
if (getState() != AUTHORIZATION_STATE) {
return false;
}
md5 = MessageDigest.getInstance(""MD5"");
timestamp += secret;
digest = md5.digest(timestamp.getBytes());
digestBuffer = new StringBuilder(128);
for (i = 0; i < digest.length; i++) {
int digit = digest[i] & 0xff;
if (digit <= 15) {
digestBuffer.append(""0"");
}
digestBuffer.append(Integer.toHexString(digit));
}
buffer = new StringBuilder(256);
buffer.append(username);
buffer.append(' ');
buffer.append(digestBuffer.toString());
if (sendCommand(POP3Command.APOP, buffer.toString()) != POP3Reply.OK) {
return false;
}
setState(TRANSACTION_STATE);
return true;
}",0
306,public String identifier;,0
307,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
308,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
309,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
}",0
310,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
311,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
312,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
313,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
314,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
315,"final synchronized void _sendTerminalType() throws IOException {
if (debug) {
System.err.println(""SEND TERMINAL-TYPE: "" + terminalType);
}
if (terminalType != null) {
_output_.write(_COMMAND_SB);
_output_.write(_COMMAND_IS);
_output_.write(terminalType.getBytes());
_output_.write(_COMMAND_SE);
_output_.flush();
}
}",0
316,"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
317,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
318,"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
319,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
320,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
321,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
322,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
323,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
324,"public Object encode(Object pObject) {
if (!(pObject instanceof byte[])) {
throw new RuntimeException(""Parameter supplied to Base64 encode is not a byte[]"");
}
return encode((byte[]) pObject);
}",0
325,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
326,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
327,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
328,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
329,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",1
330,"// Call sequence: 2
public X509Certificate[] getCertificateChain(String alias) {
try {
return new X509Certificate[] { (X509Certificate) keyStore.getCertificate(alias) };
} catch (GeneralSecurityException e) {
return null;
}
}",1
331,"public Throwable getRootCause() {
return this.rootCause;
}",1
332,"@Override
public FTPFile parseFTPEntry(String entry) {
boolean isParsed = false;
FTPFile f = new FTPFile();
if (isType == FILE_LIST_TYPE) {
isParsed = parseFileList(f, entry);
} else if (isType == MEMBER_LIST_TYPE) {
isParsed = parseMemberList(f, entry);
if (!isParsed) {
isParsed = parseSimpleEntry(f, entry);
}
} else if (isType == UNIX_LIST_TYPE) {
return unixFTPEntryParser.parseFTPEntry(entry);
} else if (isType == JES_LEVEL_1_LIST_TYPE) {
isParsed = parseJeslevel1List(f, entry);
} else if (isType == JES_LEVEL_2_LIST_TYPE) {
isParsed = parseJeslevel2List(f, entry);
}
if (!isParsed) {
f = null;
}
return f;
}",0
333,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",1
334,public String identifier;,0
335,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
}",0
336,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",1
337,"private void gatherSubjects() {
int count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) count++;
HashMap<String, ThreadContainer> subjectTable = new HashMap<String, ThreadContainer>((int) (count * 1.2), (float) 0.9);
count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) {
Threadable threadable = c.threadable;
if (threadable == null)
threadable = c.child.threadable;
String subj = threadable.simplifiedSubject();
if (subj == null || subj == """")
continue;
ThreadContainer old = subjectTable.get(subj);
// Add this container to the table iff:
// - The container in the table has a ""Re:"" version of this subject, and
// this container has a non-""Re:"" version of this subject. The non-""Re:"" version
if (old == null || (c.threadable == null && old.threadable != null) || (old.threadable != null && old.threadable.subjectIsReply() && c.threadable != null && !c.threadable.subjectIsReply())) {
subjectTable.put(subj, c);
count++;
}
}
if (count == 0)
return;
ThreadContainer prev, c, rest;
for (prev = null, c = root.child, rest = c.next; c != null; prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
Threadable threadable = c.threadable;
if (threadable == null)
threadable = c.child.threadable;
String subj = threadable.simplifiedSubject();
if (subj == null || subj == """")
continue;
ThreadContainer old = subjectTable.get(subj);
if (old == c)
continue;
if (prev == null)
root.child = c.next;
else
prev.next = c.next;
c.next = null;
if (old.threadable == null && c.threadable == null) {
ThreadContainer tail;
for (tail = old.child; tail != null && tail.next != null; tail = tail.next) {
}
if (tail != null) {
tail.next = c.child;
}
for (tail = c.child; tail != null; tail = tail.next) tail.parent = old;
c.child = null;
} else if (old.threadable == null || (c.threadable != null && c.threadable.subjectIsReply() && !old.threadable.subjectIsReply())) {
// Else if old is empty, or c has ""Re:"" and old does not  ==> make this message a child of old
c.parent = old;
c.next = old.child;
old.child = c;
} else {
ThreadContainer newc = new ThreadContainer();
newc.threadable = old.threadable;
newc.child = old.child;
for (ThreadContainer tail = newc.child; tail != null; tail = tail.next) tail.parent = newc;
old.threadable = null;
old.child = null;
c.parent = old;
newc.parent = old;
old.child = c;
c.next = newc;
}
c = prev;
}
subjectTable.clear();
subjectTable = null;
}",1
338,"private void tunnelHandshake(String host, int port, InputStream input, OutputStream output) throws IOException, UnsupportedEncodingException {
final String connectString = ""CONNECT "" + host + "":"" + port + "" HTTP/1.1"";
_output_.write(connectString.getBytes(getControlEncoding()));
_output_.write(CRLF);
if (proxyUsername != null && proxyPassword != null) {
final String header = ""Proxy-Authorization: Basic "" + base64.encode(proxyUsername + "":"" + proxyPassword) + ""\r\n"";
_output_.write(header.getBytes(""UTF-8""));
_output_.write(CRLF);
List<String> response = new ArrayList<String>();
BufferedReader reader = new BufferedReader(new InputStreamReader(_input_));
for (String line = reader.readLine(); line != null && line.length() > 0; line = reader.readLine()) {
response.add(line);
}
int size = response.size();
if (size == 0) {
throw new IOException(""No response from proxy"");
}
String code = null;
String resp = response.get(0);
if (resp.startsWith(""HTTP/"") && resp.length() >= 12) {
code = resp.substring(9, 12);
} else {
throw new IOException(""Invalid response from proxy: "" + resp);
}
if (!""200"".equals(code)) {
StringBuilder msg = new StringBuilder();
msg.append(""HTTPTunnelConnector: connection failed\r\n"");
msg.append(""Response received from the proxy:\r\n"");
for (String line : response) {
msg.append(line);
msg.append(""\r\n"");
}
throw new IOException(msg.toString());
}
}
}",0
339,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
try {
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
} catch (IllegalMonitorStateException e) {
System.err.println(""Exception processing AYT:"" + e.getMessage());
}
}
return (retValue);
}",0
340,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
try {
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
} catch (IllegalMonitorStateException e) {
System.err.println(""Exception processing AYT:"" + e.getMessage());
}
}
return (retValue);
}",1
341,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = _socket_.getInetAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (!isClientMode) {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
}",0
342,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",1
343,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
344,public int size;,0
345,"private void gatherSubjects() {
int count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) count++;
HashMap<String, ThreadContainer> subjectTable = new HashMap<String, ThreadContainer>((int) (count * 1.2), (float) 0.9);
count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) {
Threadable threadable = c.threadable;
if (threadable == null)
threadable = c.child.threadable;
String subj = threadable.simplifiedSubject();
if (subj == null || subj == """")
continue;
ThreadContainer old = subjectTable.get(subj);
// Add this container to the table iff:
// - The container in the table has a ""Re:"" version of this subject, and
// this container has a non-""Re:"" version of this subject. The non-""Re:"" version
if (old == null || (c.threadable == null && old.threadable != null) || (old.threadable != null && old.threadable.subjectIsReply() && c.threadable != null && !c.threadable.subjectIsReply())) {
subjectTable.put(subj, c);
count++;
}
}
if (count == 0)
return;
ThreadContainer prev, c, rest;
for (prev = null, c = root.child, rest = c.next; c != null; prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
Threadable threadable = c.threadable;
if (threadable == null)
threadable = c.child.threadable;
String subj = threadable.simplifiedSubject();
if (subj == null || subj == """")
continue;
ThreadContainer old = subjectTable.get(subj);
if (old == c)
continue;
if (prev == null)
root.child = c.next;
else
prev.next = c.next;
c.next = null;
if (old.threadable == null && c.threadable == null) {
ThreadContainer tail;
for (tail = old.child; tail != null && tail.next != null; tail = tail.next) {
}
if (tail != null) {
tail.next = c.child;
}
for (tail = c.child; tail != null; tail = tail.next) tail.parent = old;
c.child = null;
} else if (old.threadable == null || (c.threadable != null && c.threadable.subjectIsReply() && !old.threadable.subjectIsReply())) {
// Else if old is empty, or c has ""Re:"" and old does not  ==> make this message a child of old
c.parent = old;
c.next = old.child;
old.child = c;
} else {
ThreadContainer newc = new ThreadContainer();
newc.threadable = old.threadable;
newc.child = old.child;
for (ThreadContainer tail = newc.child; tail != null; tail = tail.next) tail.parent = newc;
old.threadable = null;
old.child = null;
c.parent = old;
newc.parent = old;
old.child = c;
c.next = newc;
}
c = prev;
}
subjectTable.clear();
subjectTable = null;
}",0
346,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",1
347,"private void gatherSubjects() {
int count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) {
count++;
}
HashMap<String, ThreadContainer> subjectTable = new HashMap<String, ThreadContainer>((int) (count * 1.2), (float) 0.9);
count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) {
Threadable threadable = c.threadable;
if (threadable == null) {
threadable = c.child.threadable;
}
String subj = threadable.simplifiedSubject();
if (subj == null || subj.length() == 0) {
continue;
}
ThreadContainer old = subjectTable.get(subj);
// Add this container to the table iff:
// - The container in the table has a ""Re:"" version of this subject, and
// this container has a non-""Re:"" version of this subject. The non-""Re:"" version
if (old == null || (c.threadable == null && old.threadable != null) || (old.threadable != null && old.threadable.subjectIsReply() && c.threadable != null && !c.threadable.subjectIsReply())) {
subjectTable.put(subj, c);
count++;
}
}
if (count == 0) {
return;
}
ThreadContainer prev, c, rest;
for (prev = null, c = root.child, rest = c.next; c != null; prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
Threadable threadable = c.threadable;
if (threadable == null) {
threadable = c.child.threadable;
}
String subj = threadable.simplifiedSubject();
if (subj == null || subj.length() == 0) {
continue;
}
ThreadContainer old = subjectTable.get(subj);
if (old == c) {
continue;
}
if (prev == null) {
root.child = c.next;
} else {
prev.next = c.next;
}
c.next = null;
if (old.threadable == null && c.threadable == null) {
ThreadContainer tail;
for (tail = old.child; tail != null && tail.next != null; tail = tail.next) {
}
if (tail != null) {
tail.next = c.child;
}
for (tail = c.child; tail != null; tail = tail.next) {
tail.parent = old;
}
c.child = null;
} else if (old.threadable == null || (c.threadable != null && c.threadable.subjectIsReply() && !old.threadable.subjectIsReply())) {
// Else if old is empty, or c has ""Re:"" and old does not  ==> make this message a child of old
c.parent = old;
c.next = old.child;
old.child = c;
} else {
ThreadContainer newc = new ThreadContainer();
newc.threadable = old.threadable;
newc.child = old.child;
for (ThreadContainer tail = newc.child; tail != null; tail = tail.next) {
tail.parent = newc;
}
old.threadable = null;
old.child = null;
c.parent = old;
newc.parent = old;
old.child = c;
c.next = newc;
}
c = prev;
}
subjectTable.clear();
subjectTable = null;
}",1
348,"public ParserInitializationException(String message, Throwable rootCause) {
super(message);
this.rootCause = rootCause;
}",1
349,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",1
350,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
__cslDebug = csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
351,"public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, AUTH_METHOD.getAuthName(method)))) {
return false;
}
if (method.equals(AUTH_METHOD.PLAIN)) {
int result = sendUntaggedCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
int result = sendUntaggedCommand(new String(Base64.encodeBase64(toEncode)));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
} else if (method.equals(AUTH_METHOD.LOGIN)) {
if (sendUntaggedCommand(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT) {
return false;
}
int result = sendUntaggedCommand(new String(Base64.encodeBase64(password.getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
} else
return false;
}",0
352,"public FTPFile parseFTPEntry(String entry) {
String[] parts = entry.split("" "", 2);
if (parts.length != 2) {
return null;
}
FTPFile file = new FTPFile();
file.setRawListing(entry);
file.setName(parts[1]);
String[] facts = parts[0].split("";"");
boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
for (String fact : facts) {
String[] factparts = fact.split(""="");
if (factparts.length != 2) {
continue;
}
String factname = factparts[0].toLowerCase(Locale.ENGLISH);
String factvalue = factparts[1];
String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
if (""size"".equals(factname)) {
file.setSize(Long.parseLong(factvalue));
} else if (""sizd"".equals(factname)) {
file.setSize(Long.parseLong(factvalue));
} else if (""modify"".equals(factname)) {
SimpleDateFormat sdf;
if (factvalue.contains(""."")) {
sdf = new SimpleDateFormat(""yyyyMMddHHmmss.SSS"");
} else {
sdf = new SimpleDateFormat(""yyyyMMddHHmmss"");
}
GregorianCalendar gc = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
try {
gc.setTime(sdf.parse(factvalue));
} catch (ParseException e) {
}
file.setTimestamp(gc);
} else if (""type"".equals(factname)) {
Integer intType = TYPE_TO_INT.get(valueLowerCase);
if (intType == null) {
} else {
file.setType(intType.intValue());
}
} else if (factname.startsWith(""unix."")) {
String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
if (""group"".equals(unixfact)) {
file.setGroup(factvalue);
} else if (""owner"".equals(unixfact)) {
file.setUser(factvalue);
} else if (""mode"".equals(unixfact)) {
int off = factvalue.length() - 4;
for (int i = 1; i <= 3; i++) {
int ch = factvalue.charAt(off + i) - '0';
for (int p : UNIX_PERMS[ch]) {
file.setPermission(UNIX_GROUPS[i - 1], p, true);
}
}
file.setUser(factvalue);
}
} else if (!hasUnixMode && ""perm"".equals(factname)) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
return null;
}
}
}
}
return file;
}",0
353,"public byte[] parseADATReply(String reply) {
if (reply == null)
return null;
else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
354,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1
355,"public boolean status(String mailboxName, String[] itemNames) throws IOException {
String statusNames = """";
if (itemNames != null) {
statusNames += "" ("";
for (int i = 0; i < itemNames.length; i++) {
statusNames += itemNames[i];
if (i < itemNames.length - 1)
statusNames += "" "";
}
statusNames += "")"";
}
return doCommand(IMAPCommand.STATUS, statusNames);
}",1
356,ThreadContainer prev;,1
357,"public FTPFile[] listFiles(String pathname) throws IOException {
String key = null;
FTPListParseEngine engine = initiateListParsing(key, pathname);
return engine.getFiles();
}",1
358,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1
