,source,target
0,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
1,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
2,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
3,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,0
4,"@Override
public void addObject(final K key) throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.addObject(key);
} finally {
writeLock.unlock();
}
}",0
5,"@Override
public void invalidateObject(final K key, final V obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
6,"@Override
public void clear(final K key) throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.clear(key);
} finally {
writeLock.unlock();
}
}",0
7,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
8,"void cancel() {
scheduledFuture.cancel(false);
}",0
9,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
if (_factory.validateObject(key, obj)) {
_factory.passivateObject(key, obj);
} else {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
10,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
11,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
12,"public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
long idleSoftEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
if (getSoftMinEvictableIdleTimeMillis() > 0) {
idleSoftEvictTime = getSoftMinEvictableIdleTimeMillis();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis() || (idleSoftEvictTime < underTest.getIdleTimeMillis() && getMinIdle() < idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
return;
}",0
13,"@Override
public void addObject() throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.addObject();
} finally {
writeLock.unlock();
}
}",0
14,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
ObjectTimestampPair pair = null;
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
if (newlyCreated) {
pool.incrementActiveCount();
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
pool.incrementActiveCount();
return pair.value;
}
}
}
}",0
15,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
16,"public synchronized void evict() throws Exception {
Object key = null;
if (_recentlyEvictedKeys == null) {
_recentlyEvictedKeys = new HashSet(_poolMap.size());
}
Set remainingKeys = new HashSet(_poolMap.keySet());
remainingKeys.removeAll(_recentlyEvictedKeys);
Iterator keyIter = remainingKeys.iterator();
ListIterator objIter = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap.size() > 0) {
if (key == null) {
if (!keyIter.hasNext()) {
_recentlyEvictedKeys.clear();
remainingKeys = new HashSet(_poolMap.keySet());
keyIter = remainingKeys.iterator();
}
if (!keyIter.hasNext()) {
return;
}
key = keyIter.next();
}
if (objIter == null) {
final LinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
if (_evictLastIndex < 0 || _evictLastIndex > list.size()) {
_evictLastIndex = list.size();
}
objIter = list.listIterator(_evictLastIndex);
}
if (objIter.hasPrevious()) {
ObjectTimestampPair pair = (ObjectTimestampPair) (objIter.previous());
boolean removeObject = false;
if (_minEvictableIdleTimeMillis > 0 && System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
objIter.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if ((_minIdle == 0) && (((ObjectQueue) (_poolMap.get(key))).queue.isEmpty())) {
_poolMap.remove(key);
}
} catch (Exception e) {
;
}
}
} else {
_recentlyEvictedKeys.add(key);
_evictLastIndex = -1;
objIter = null;
}
}
}
}",0
17,"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0
18,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
19,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
20,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
21,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
22,private int initIdleCapacity;,0
23,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
24,"void cancel() {
scheduledFuture.cancel(false);
}",0
25,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
26,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final LinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final LinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
27,"public synchronized void evict() throws Exception {
Object key = null;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
boolean removeObject = false;
if ((_minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if (_minIdle == 0) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
if (objectQueue != null && objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
} catch (Exception e) {
}
}
}
}",0
28,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}",0
29,private long _maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;,0
30,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
31,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
32,"@Override
public void clear(K key) {
ObjectDeque<T> objectDeque = poolMap.get(key);
if (objectDeque == null) {
return;
}
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",0
33,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}",0
34,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
35,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(final Object other) {
return ((IdentityWrapper) other).instance == instance;
}",0
36,"public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
PooledObject<T> underTest = null;
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
keyCopy.addAll(poolKeyList);
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis()) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest.getObject());
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest.getObject())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest.getObject());
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}",0
37,"@Override
@Deprecated
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
}
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}",0
38,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
39,private int initIdleCapacity;,0
40,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
41,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
42,private GenericKeyedObjectPoolConfig config;,0
43,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
44,private int maxSleeping;,0
45,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
46,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}",0
47,"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0
48,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
49,"@Override
public void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
if (this._factory == null) {
synchronized (factoryLock) {
if (this._factory == null) {
this._factory = factory;
} else {
throw new IllegalStateException(""Factory already set"");
}
}
} else {
throw new IllegalStateException(""Factory already set"");
}
}",0
50,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
51,"public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
boolean testWhileIdle = _testWhileIdle;
long idleEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
PooledObject<T> underTest = null;
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
keyCopy.addAll(poolKeyList);
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis()) {
destroy(evictionKey, underTest);
} else {
if (testWhileIdle) {
boolean active = false;
try {
_factory.activateObject(evictionKey, underTest.getObject());
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest);
}
if (active) {
if (!_factory.validateObject(evictionKey, underTest.getObject())) {
destroy(evictionKey, underTest);
} else {
try {
_factory.passivateObject(evictionKey, underTest.getObject());
} catch (Exception e) {
destroy(evictionKey, underTest);
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}",0
52,private int maxSleeping;,0
53,"@Override
public T borrowObject() throws Exception, NoSuchElementException, IllegalStateException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
return pool.borrowObject();
} finally {
writeLock.unlock();
}
}",0
54,"public synchronized void clear() {
for (Iterator entries = _poolMap.entrySet().iterator(); entries.hasNext(); ) {
final Map.Entry entry = (Map.Entry) entries.next();
final Object key = entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (entry.getValue())).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
}
_poolMap.clear();
_poolList.clear();
_totalIdle = 0;
notifyAll();
}",0
55,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
ObjectTimestampPair pair = null;
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
if (newlyCreated) {
pool.incrementActiveCount();
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
pool.incrementActiveCount();
return pair.value;
}
}
}
}",0
56,"public void evict() throws Exception {
assertOpen();
if (_idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_evictionIterator == null || !_evictionIterator.hasNext()) {
if (getLifo()) {
_evictionIterator = _idleObjects.descendingIterator();
} else {
_evictionIterator = _idleObjects.iterator();
}
}
if (!_evictionIterator.hasNext()) {
return;
} else {
try {
underTest = _evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
_evictionIterator = null;
continue;
}
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (getMinEvictableIdleTimeMillis() > 0 && getMinEvictableIdleTimeMillis() < underTest.getIdleTimeMillis() || (getSoftMinEvictableIdleTimeMillis() > 0 && getSoftMinEvictableIdleTimeMillis() < underTest.getIdleTimeMillis() && getMinIdle() < _idleObjects.size())) {
destroy(underTest);
} else {
if (getTestWhileIdle()) {
boolean active = false;
try {
_factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
}
if (active) {
if (!_factory.validateObject(underTest.getObject())) {
destroy(underTest);
} else {
try {
_factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
}
}
}
}
if (!underTest.endEvictionTest()) {
}
}
}
return;
}",0
57,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
58,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActiveOld--;
}
allocate();
}
}
}",0
59,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
60,"void cancel() {
scheduledFuture.cancel(false);
}",0
61,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
62,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
63,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
64,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTime(), getSoftMinEvictableIdleTime(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
65,private int initIdleCapacity;,0
66,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
67,private int _maxSleeping = StackObjectPool.DEFAULT_MAX_SLEEPING;,0
68,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
69,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
70,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
71,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
72,"@Override
public void addObject(final K key) throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.addObject(key);
} finally {
writeLock.unlock();
}
}",0
73,"@Override
public void invalidateObject(final K key, final V obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
74,"@Override
public void clear(final K key) throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.clear(key);
} finally {
writeLock.unlock();
}
}",0
75,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
76,"@Override
public boolean validateObject(final K key, final V obj) {
writeLock.tryLock();
try {
return keyedFactory.validateObject(key, obj);
} finally {
writeLock.unlock();
}
}",0
77,"void cancel() {
scheduledFuture.cancel(false);
}",0
78,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
79,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p.getObject());
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
80,private int _minIdle = DEFAULT_MIN_IDLE;,0
81,private GenericObjectPoolConfig config;,0
82,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
83,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
84,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
85,"public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
long idleSoftEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
if (getSoftMinEvictableIdleTimeMillis() > 0) {
idleSoftEvictTime = getSoftMinEvictableIdleTimeMillis();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis() || (idleSoftEvictTime < underTest.getIdleTimeMillis() && getMinIdle() < idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
return;
}",0
86,"public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
87,"@Override
public void addObject() throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.addObject();
} finally {
writeLock.unlock();
}
}",0
88,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
ObjectTimestampPair pair = null;
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
if (newlyCreated) {
pool.incrementActiveCount();
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
pool.incrementActiveCount();
return pair.value;
}
}
}
}",0
89,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
90,"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0
91,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
92,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
93,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
94,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
95,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
96,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
97,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
98,"public synchronized void evict() throws Exception {
Object key = null;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
boolean removeObject = false;
if ((_minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if (_minIdle == 0) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
if (objectQueue != null && objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
} catch (Exception e) {
}
}
}
}",0
99,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}",0
100,"@Override
public void returnObject(final T obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.returnObject(obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
101,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
102,"@Override
public int getNumIdle(final K key) {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle(key);
} finally {
readLock.unlock();
}
}",0
103,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
104,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
105,"@Override
public void destroyObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.destroyObject(key, obj);
} finally {
writeLock.unlock();
}
}",0
106,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
107,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0
108,"@Override
public void clear(K key) {
ObjectDeque<T> objectDeque = poolMap.get(key);
if (objectDeque == null) {
return;
}
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",0
109,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
110,"public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
PooledObject<T> underTest = null;
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
keyCopy.addAll(poolKeyList);
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis()) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest.getObject());
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest.getObject())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest.getObject());
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}",0
111,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
112,"@Override
public void close() {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.close();
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
113,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",0
114,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
115,"@Override
@Deprecated
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
}
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}",0
116,private int initIdleCapacity;,0
117,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
118,private GenericKeyedObjectPoolConfig config;,0
119,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
120,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}",0
121,"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0
122,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
123,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
124,"@Override
public void close() {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.close();
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
125,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
126,"@Override
public void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
if (this._factory == null) {
synchronized (factoryLock) {
if (this._factory == null) {
this._factory = factory;
} else {
throw new IllegalStateException(""Factory already set"");
}
}
} else {
throw new IllegalStateException(""Factory already set"");
}
}",0
127,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
128,"@Override
public void activateObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.activateObject(key, obj);
} finally {
writeLock.unlock();
}
}",0
129,"@Override
public int getNumActive() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return pool.getNumActive();
} finally {
readLock.unlock();
}
}",0
130,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
131,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActiveOld--;
}
allocate();
}
}
}",0
132,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
133,"void cancel() {
scheduledFuture.cancel(false);
}",0
134,"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0
135,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
136,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
137,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTime(), getSoftMinEvictableIdleTime(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
138,private int initIdleCapacity;,0
139,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
140,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
141,protected int _totIdle = 0;,1
142,"public PoolableObjectFactory getFactory() {
return _factory;
}",1
143,"private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if (null == old) {
_activeCount.put(key, new Integer(1));
} else {
_activeCount.put(key, new Integer(old.intValue() + 1));
}
}",1
144,private int initIdleCapacity;,1
145,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
final PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (final Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",1
146,"@Override
public int getNumIdle() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle();
} finally {
readLock.unlock();
}
}",1
147,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
148,private int _totalIdle = 0;,1
149,"@Override
public boolean validateObject(final K key, final V obj) {
writeLock.tryLock();
try {
return keyedFactory.validateObject(key, obj);
} finally {
writeLock.unlock();
}
}",1
150,"private long getMeanFromStatsCache(LinkedList<Long> cache) {
List<Long> times = new ArrayList<Long>(AVERAGE_TIMING_STATS_CACHE_SIZE);
synchronized (cache) {
times.addAll(cache);
}
double result = 0;
int counter = 0;
Iterator<Long> iter = times.iterator();
while (iter.hasNext()) {
Long time = iter.next();
if (time != null) {
counter++;
result = result * ((counter - 1) / counter) + time.longValue() / counter;
}
}
return (long) result;
}",1
151,private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;,1
152,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",1
153,"@Override
public int getNumActive() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumActive();
} finally {
readLock.unlock();
}
}",1
154,"@Override
public void returnObject(T obj) {
PooledObject<T> p = allObjects.get(obj);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(obj)) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(obj);
} catch (Exception e1) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdle();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(p);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
updateStatsReturn(activeTime);
}",1
155,"@Override
public T makeObject() throws Exception {
writeLock.tryLock();
try {
return factory.makeObject();
} finally {
writeLock.unlock();
}
}",1
156,"@Override
public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (getTestOnReturn()) {
if (!_factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
return;
}
}
try {
_factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
return;
}
if (!p.deallocate()) {
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
}",1
157,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
158,"@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll();
}",1
159,"@Override
public void clear() throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.clear();
} finally {
writeLock.unlock();
}
}",1
160,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(final Object other) {
return ((IdentityWrapper) other).instance == instance;
}",1
161,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",1
162,"@Override
public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
if (hasBorrowWaiters()) {
reuseCapacity();
}
updateStatsReturn(activeTime);
}",1
163,"private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if (null == active) {
} else if (active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}",1
164,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",1
165,"@Override
public int getNumIdle(final K key) {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle(key);
} finally {
readLock.unlock();
}
}",1
166,protected PoolableObjectFactory _factory = null;,1
167,"@Override
public void close() {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.close();
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",1
168,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",1
169,"public JdkProxySource(ClassLoader classLoader, Class<?>[] interfaces) {
this.classLoader = classLoader;
this.interfaces = interfaces;
}",1
170,private int initIdleCapacity;,1
171,private int maxSleeping;,1
172,"@Override
public V borrowObject(final K key) throws Exception, NoSuchElementException, IllegalStateException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
return keyedPool.borrowObject(key);
} finally {
writeLock.unlock();
}
}",1
173,"@Override
public void activateObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.activateObject(key, obj);
} finally {
writeLock.unlock();
}
}",1
174,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",1
175,"@Override
public void invalidateObject(final T obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.invalidateObject(obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",1
176,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",1
177,"private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext(); ) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext(); ) {
try {
factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
} finally {
synchronized (this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}",1
178,"private void removeAbandoned() {
final long now = System.currentTimeMillis();
final long timeout = now - (abandonedConfig.getRemoveAbandonedTimeout() * 1000);
ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>();
Iterator<PooledObject<T>> it = allObjects.values().iterator();
while (it.hasNext()) {
PooledObject<T> pooledObject = it.next();
synchronized (pooledObject) {
if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsed() <= timeout) {
pooledObject.markAbandoned();
remove.add(pooledObject);
}
}
}
Iterator<PooledObject<T>> itr = remove.iterator();
while (itr.hasNext()) {
PooledObject<T> pooledObject = itr.next();
if (abandonedConfig.getLogAbandoned()) {
pooledObject.printStackTrace();
}
try {
invalidateObject(pooledObject.getObject());
} catch (Exception e) {
e.printStackTrace();
}
}
}",1
179,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
180,"public PoolableObjectFactory getFactory() {
return _factory;
}",1
181,"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",1
182,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",1
183,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
184,"@Override
public void passivateObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.passivateObject(key, obj);
} finally {
writeLock.unlock();
}
}",1
185,private Exception borrowedBy = null;,1
186,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
187,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
188,private int initIdleCapacity;,1
189,protected int _totIdle = 0;,1
190,"private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if (null == old) {
_activeCount.put(key, new Integer(1));
} else {
_activeCount.put(key, new Integer(old.intValue() + 1));
}
}",1
191,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
final PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (final Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",1
192,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
193,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
194,private int _totalIdle = 0;,1
195,"@Override
public int getNumActive() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumActive();
} finally {
readLock.unlock();
}
}",1
196,protected int _totIdle = 0;,1
197,"@Override
public int getNumIdle() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return pool.getNumIdle();
} finally {
readLock.unlock();
}
}",1
198,"@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + t.getMessage());
}
}
}
}
_numActive++;
return obj;
}",1
199,"private void destroy(PooledObject<T> toDestory) {
_idleObjects.remove(toDestory);
try {
_factory.destroyObject(toDestory.getObject());
} catch (Exception e) {
}
}",1
200,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
201,protected int _totActive = 0;,1
202,"@Override
public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (getTestOnReturn()) {
if (!_factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
return;
}
}
try {
_factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
return;
}
if (!p.deallocate()) {
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
}",1
203,"@Override
public void clear() throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.clear();
} finally {
writeLock.unlock();
}
}",1
204,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(final Object other) {
return ((IdentityWrapper) other).instance == instance;
}",1
205,"@Override
public Map<String, Integer> getNumWaitersByKey() {
final Map<String, Integer> result = new HashMap<String, Integer>();
for (final K key : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",1
206,"@Override
public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
if (hasBorrowWaiters()) {
reuseCapacity();
}
updateStatsReturn(activeTime);
}",1
207,"private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if (null == active) {
} else if (active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}",1
208,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",1
209,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
210,"@SuppressWarnings(""null"")
public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",1
211,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (final PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
final Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
final Map.Entry<PooledObject<T>, K> entry = iter.next();
final K key = entry.getValue();
final PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (final Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",1
212,private int maxSleeping;,1
213,"private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext(); ) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext(); ) {
try {
factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
} finally {
synchronized (this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}",1
214,private int initIdleCapacity;,1
215,"private void removeAbandoned() {
final long now = System.currentTimeMillis();
final long timeout = now - (abandonedConfig.getRemoveAbandonedTimeout() * 1000);
ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>();
Iterator<PooledObject<T>> it = allObjects.values().iterator();
while (it.hasNext()) {
PooledObject<T> pooledObject = it.next();
synchronized (pooledObject) {
if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsed() <= timeout) {
pooledObject.markAbandoned();
remove.add(pooledObject);
}
}
}
Iterator<PooledObject<T>> itr = remove.iterator();
while (itr.hasNext()) {
PooledObject<T> pooledObject = itr.next();
if (abandonedConfig.getLogAbandoned()) {
pooledObject.printStackTrace();
}
try {
invalidateObject(pooledObject.getObject());
} catch (Exception e) {
e.printStackTrace();
}
}
}",1
216,protected int _totIdle = 0;,1
217,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",1
218,"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",1
219,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
220,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",1
221,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",1
222,private Exception borrowedBy = null;,1
223,private SoftReference<T> reference;,1
224,private int initIdleCapacity;,1
225,"@Override
public void clear() {
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",1
226,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
227,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
228,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
229,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
230,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
231,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
232,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
233,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
234,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
235,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
236,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
237,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
238,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
239,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
240,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
241,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
242,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
243,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
244,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
245,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
246,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
247,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
248,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
249,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
250,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
251,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
252,"// --- protected methods ------------------------------------------
@Override
protected Listable<E> insertListable(Listable<E> before, Listable<E> after, E value) {
_modCount++;
_size++;
Listable<E> elt = _list.insertListable((null == before ? _pre : before), (null == after ? _post : after), value);
if (null == _head.next()) {
_head.setNext(elt);
_head.setPrev(elt);
}
if (before == _head.prev()) {
_head.setPrev(elt);
}
if (after == _head.next()) {
_head.setNext(elt);
}
broadcastListableInserted(elt);
return elt;
}",0
253,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
254,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
255,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
256,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
257,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
258,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
259,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
260,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
261,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
262,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
263,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
264,"@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
265,"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
266,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
267,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
268,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
269,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
270,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
271,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
272,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
273,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
274,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
275,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
276,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
277,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
278,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
279,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
280,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
281,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
282,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}",0
283,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
284,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
285,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}",0
286,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
287,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
288,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
289,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
290,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
291,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
292,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
293,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
294,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
295,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
296,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
297,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
298,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
299,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
300,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
301,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
302,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
303,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
304,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
305,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
306,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
307,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
308,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
309,"protected void listableChanged(Listable elt) {
if (_lastReturned == elt) {
_lastReturned = null;
}
}",0
310,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
311,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
312,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
313,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
314,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
315,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
316,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
317,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
318,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
319,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
320,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
321,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
322,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
323,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
324,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
325,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
326,protected int _totActive = 0;,0
327,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
328,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
329,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
330,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
331,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
332,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
333,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
334,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
335,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
336,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
337,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
338,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
339,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
340,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
341,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
342,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
343,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
344,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
345,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
346,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
347,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
348,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
349,protected int _totIdle = 0;,0
350,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
351,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
352,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
353,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
354,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
355,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
356,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
357,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
358,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
359,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
360,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
361,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
362,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
363,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
364,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
365,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
366,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
367,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
368,"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
369,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
370,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
371,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
372,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
373,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
374,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
375,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
376,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
377,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
378,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
379,"@Deprecated
protected int _totIdle = 0;",0
380,"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0
381,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
382,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
383,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
384,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
385,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
386,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
387,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
388,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
389,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
390,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
391,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
392,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
393,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
394,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
395,"protected void broadcastListableInserted(Listable elt) {
Iterator it = _cursors.iterator();
while (it.hasNext()) {
WeakReference ref = (WeakReference) it.next();
Cursor cursor = (Cursor) ref.get();
if (cursor == null) {
it.remove();
} else {
cursor.listableInserted(elt);
}
}
}",0
396,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
397,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
398,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
399,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
400,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
401,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
402,"public synchronized void clear() {
if (null != _factory) {
Iterator iter = _pool.iterator();
while (iter.hasNext()) {
try {
Object obj = ((SoftReference) iter.next()).get();
if (null != obj) {
_factory.destroyObject(obj);
}
} catch (Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}",0
403,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
404,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
405,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
406,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
407,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
408,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
409,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
410,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
411,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
412,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
413,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
414,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
415,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
416,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
417,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
418,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
419,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
420,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
421,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
422,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
423,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
424,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
425,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
426,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
427,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
428,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
429,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
430,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
431,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
432,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
433,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
434,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
435,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}

ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
436,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
437,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
438,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
439,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
440,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
441,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
442,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
443,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
444,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
445,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
446,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
447,protected int _totIdle = 0;,0
448,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
449,"public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
450,"public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
451,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
452,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
453,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
454,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
455,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
456,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
457,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
458,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
459,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
460,"public void returnObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
461,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
462,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
463,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
464,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
465,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
466,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
467,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
468,"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0
469,"@Deprecated
@Override
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
}
}
destroy(toDestroy, oldFactory);
}",0
470,"@Override
public void clear() {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
471,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) {
return;
}
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
472,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
473,private ClassLoader _factoryClassLoader = null;,0
474,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
475,"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
476,private ClassLoader _factoryClassLoader = null;,0
477,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
478,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
479,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.getTstamp();
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.getValue());
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.getValue())) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.getValue());
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.getValue());
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
480,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
481,"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
482,"@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
483,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
484,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
485,"@Deprecated
protected int _totActive = 0;",0
486,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
487,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
488,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
489,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
490,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
491,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
492,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
493,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
494,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
495,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
496,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
497,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
498,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
499,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
500,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
501,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
_size = 0;
_modCount = 0;
_cursors = new ArrayList();
_head = new Listable(null, null, null);
int size = in.readInt();
for (int i = 0; i < size; i++) {
this.add(in.readObject());
}
}",0
502,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
503,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
504,"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
505,"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
506,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
507,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
508,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
509,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
510,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
511,"public synchronized void clear() {
if (null != _factory) {
Iterator iter = _pool.iterator();
while (iter.hasNext()) {
try {
Object obj = ((SoftReference) iter.next()).get();
if (null != obj) {
_factory.destroyObject(obj);
}
} catch (Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}",0
512,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
513,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
514,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
515,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
516,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
517,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
518,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
519,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
520,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
521,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
522,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
523,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
524,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
525,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
526,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
527,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
528,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
529,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
530,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
531,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
532,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
533,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
534,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
535,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
536,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
537,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
538,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
539,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
540,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
541,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
542,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
543,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
544,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
545,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
546,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
547,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
548,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
549,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
550,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
551,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
552,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
553,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
554,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
555,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
556,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
557,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
558,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
559,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
560,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
561,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
562,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
563,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
564,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
565,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
566,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
567,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
568,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
569,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
570,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
571,"protected void broadcastListableRemoved(Listable elt) {
Iterator it = _cursors.iterator();
while (it.hasNext()) {
WeakReference ref = (WeakReference) it.next();
Cursor cursor = (Cursor) ref.get();
if (cursor == null) {
it.remove();
} else {
cursor.listableRemoved(elt);
}
}
}",0
572,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
573,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
574,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
575,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}",0
576,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
577,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
578,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
579,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
580,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
581,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
582,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
583,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
584,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
585,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
586,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
587,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
588,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
589,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
590,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
591,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
592,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
593,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
594,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
595,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
596,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
597,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
598,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
599,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
600,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
601,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
602,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
603,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
604,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
605,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
606,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
607,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
608,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
609,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
610,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
611,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
612,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
613,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
614,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
615,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
616,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
617,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
618,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
619,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
620,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
621,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
622,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
623,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
624,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
625,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
626,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
627,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
628,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
629,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
630,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
631,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
632,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
633,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
634,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
635,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
636,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
637,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
638,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
639,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
640,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
641,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
642,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
643,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
644,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
645,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
646,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
647,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
648,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
649,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
650,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
651,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
652,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
653,"private void writeObject(ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeInt(_size);
Listable cur = _head.next();
while (cur != null) {
out.writeObject(cur.value());
cur = cur.next();
}
}",0
654,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
655,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
656,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
657,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
658,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
659,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
660,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
661,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
662,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
663,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
664,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
665,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
666,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
667,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
668,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
669,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
670,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
671,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
672,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
673,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
674,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
675,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
676,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
677,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
678,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
679,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
680,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
681,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
682,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
683,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
684,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
685,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
686,"// --- public methods ------------------------------------------
@Override
public void clear() {
checkForComod();
Iterator<E> it = iterator();
while (it.hasNext()) {
it.next();
it.remove();
}
}",0
687,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
688,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
689,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
690,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
691,"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
692,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final K key = keyiter.next();
final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set<Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final List<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
693,"@Deprecated
@Override
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
694,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
695,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
696,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
697,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
698,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
699,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
700,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
701,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
702,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
703,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
704,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
705,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
706,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
707,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
708,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
709,"@Deprecated
protected int _totIdle = 0;",0
710,"private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if (null == active) {
} else if (active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}",0
711,"@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
712,"@Deprecated
protected int _totActive = 0;",0
713,"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0
714,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
715,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
716,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
717,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
718,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
719,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
720,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
721,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
722,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
723,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
724,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
725,"public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
// set the classloader for the factory
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
// Evict from the pool
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
// Re-create idle instances.
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
// restore the previous CCL
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0
726,private ClassLoader _factoryClassLoader = null;,0
727,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
728,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
729,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
730,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
731,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
732,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
733,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
734,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
735,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
736,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
737,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
738,private ClassLoader _factoryClassLoader = null;,0
739,"public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0
740,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
741,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
742,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
743,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
744,protected int _totActive = 0;,0
745,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
746,protected int _totIdle = 0;,0
747,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
748,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
749,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
750,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
751,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
752,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
753,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
754,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
755,"@Override
public void clear() {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
756,private int minIdlePerKey;,0
757,private boolean testOnReturn;,0
758,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (this.testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (this.maxIdlePerKey >= 0 && (pool.queue.size() >= this.maxIdlePerKey)) {
shouldDestroy = true;
} else if (success) {
if (this.lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
759,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
760,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
761,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
for (K key : _poolMap.keySet()) {
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
762,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
763,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (K key : _poolMap.keySet()) {
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (ObjectTimestampPair<V> pair : list) {
map.put(pair, key);
}
}
Set<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final CursorableLinkedList<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
764,"@Override
public void addObject(K key) throws Exception {
assertOpen();
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
765,"public int compareTo(ObjectTimestampPair<V> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
766,private long maxWait;,0
767,private boolean lifo;,0
768,private int maxTotalPerKey;,0
769,private int maxIdlePerKey;,0
770,private long minEvictableIdleTimeMillis;,0
771,private long timeBetweenEvictionRunsMillis;,0
772,private int numTestsPerEvictionRun;,0
773,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(this.lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((this.lifo && !_evictionCursor.hasPrevious()) || !this.lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(this.lifo ? _pool.size() : 0);
}
pair = this.lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.getTstamp();
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.getValue());
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.getValue())) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.getValue());
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.getValue());
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (this.lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
774,"@Override
public void addObject() throws Exception {
assertOpen();
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
775,private int maxIdle;,0
776,private long maxWait;,0
777,private WhenExhaustedAction whenExhaustedAction;,0
778,private int minIdle;,0
779,private long softMinEvictableIdleTimeMillis;,0
780,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(this.createReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
781,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(this.createReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
782,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
783,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
784,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
785,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
786,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
787,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
788,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
789,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
790,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
791,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
792,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
793,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
794,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
795,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
796,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
797,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
798,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
799,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
800,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
801,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
802,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
803,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
804,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
805,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
806,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
807,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
808,"public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
if (hasBorrowWaiters()) {
reuseCapacity();
}
updateStatsReturn(activeTime);
}",0
809,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
810,"private boolean reuseCapacity() {
final int maxTotalPerKey = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKey && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
boolean success = false;
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
success = true;
}
} catch (Exception ex) {
} finally {
deregister(loadedKey);
}
}
return success;
}",0
811,"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0
812,"public T borrowObject(long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWait < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p.getObject());
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0
813,"public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
long idleSoftEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
if (getSoftMinEvictableIdleTimeMillis() > 0) {
idleSoftEvictTime = getSoftMinEvictableIdleTimeMillis();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis() || (idleSoftEvictTime < underTest.getIdleTimeMillis() && getMinIdle() < idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
return;
}",0
814,"@Override
public void clear() {
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",0
815,"@Override
public void returnObject(T obj) {
PooledObject<T> p = allObjects.get(obj);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(obj)) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(obj);
} catch (Exception e1) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdle();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(p);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
updateStatsReturn(activeTime);
}",0
816,"public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
817,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
818,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
819,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
820,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
821,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
822,"E setValue(E val) {
E temp = _val;
_val = val;
return temp;
}",0
823,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
824,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
825,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (K key : _poolMap.keySet()) {
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (ObjectTimestampPair<V> pair : list) {
map.put(pair, key);
}
}
Set<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
826,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
827,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
828,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
829,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
830,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(this.lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((this.lifo && !_evictionCursor.hasPrevious()) || !this.lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(this.lifo ? _pool.size() : 0);
}
pair = this.lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.getTstamp();
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.getValue());
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.getValue())) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.getValue());
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.getValue());
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (this.lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
831,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (this.maxTotal < 0 || (_numActive + _numInternalProcessing) < this.maxTotal)) {
Latch latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
832,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
833,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
834,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
835,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
836,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
837,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
838,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
839,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
840,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
841,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
842,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
843,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
844,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
845,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
846,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
847,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
848,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
849,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
850,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
851,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
852,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
853,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
854,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
855,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
856,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
857,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
858,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
859,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
860,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
861,"public void run() {
try {
objectPool.getFactory().destroyObject(obj);
} catch (Exception e) {
}
}",0
862,"private void close(final Object key) {
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
pool.close();
synchronized (objectPools) {
if (pool.getNumActive() == 0) {
objectPools.remove(key);
pool.close();
}
}
} catch (Exception e) {
// XXX: In pool 3 this catch block will not be necessary and shouled be removed
} finally {
if (keys != null) {
keys.set(null);
}
}
}",0
863,"// XXX: Add better handling of when this instance is not Serializable
private final ObjectPoolFactory poolFactory;",0
864,"public String toString() {
final StringBuffer sb = new StringBuffer(128);
sb.append(""CompositeKeyedObjectPool{"");
sb.append(""poolFactory="").append(poolFactory);
sb.append("", open="").append(open);
try {
final int numActive = getNumActive();
sb.append("", activeObjects="").append(numActive);
} catch (Exception e) {
}
try {
final int numIdle = getNumIdle();
sb.append("", idleObjects="").append(numIdle);
} catch (Exception e) {
}
sb.append('}');
return sb.toString();
}",0
865,"public String toString() {
final StringBuffer sb = new StringBuffer(128);
sb.append(""CompositeObjectPool{"");
if (factoryConfig != null) {
sb.append(factoryConfig);
} else {
sb.append(""factory="").append(factory);
sb.append("", lender="").append(lender);
sb.append("", manager="").append(manager);
sb.append("", tracker="").append(tracker);
sb.append("", validateOnReturn="").append(validateOnReturn);
}
sb.append("", open="").append(open);
try {
final int numActive = getNumActive();
sb.append("", activeObjects="").append(numActive);
} catch (Exception e) {
}
try {
final int numIdle = getNumIdle();
sb.append("", idleObjects="").append(numIdle);
} catch (Exception e) {
}
sb.append('}');
return sb.toString();
}",0
866,private final transient Object lock = new Object();,0
867,private final transient ThreadLocal cause = new ThreadLocal();,0
868,"public void run() {
if (referant == null) {
cancel();
return;
}
final PoolableObjectFactory factory = getObjectPool().getFactory();
synchronized (InvalidEvictorReference.this) {
Object r = referant;
while (r instanceof LenderReference) {
r = ((LenderReference) r).get();
}
if (r == null) {
clear();
return;
}
try {
factory.activateObject(r);
if (factory.validateObject(r)) {
factory.passivateObject(r);
} else {
factory.destroyObject(r);
clear();
}
} catch (Exception e) {
clear();
}
}
}",0
869,"public void run() {
if (referant == null) {
cancel();
return;
}
final PoolableObjectFactory factory = getObjectPool().getFactory();
synchronized (InvalidEvictorReference.this) {
Object r = referant;
while (r instanceof LenderReference) {
r = ((LenderReference) r).get();
}
if (r == null) {
clear();
return;
}
try {
factory.activateObject(r);
if (factory.validateObject(r)) {
factory.passivateObject(r);
} else {
factory.destroyObject(r);
clear();
}
} catch (Exception e) {
clear();
}
}
}",0
870,protected final transient ReferenceQueue rq = new ReferenceQueue();,0
871,private transient volatile int active = 0;,0
872,"public boolean addAll(Collection c) {
checkForComod();
return super.addAll(c);
}",0
873,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
874,"public synchronized void evict() throws Exception {
Object key = null;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
boolean removeObject = false;
if ((_minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if (_minIdle == 0) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
if (objectQueue != null && objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
} catch (Exception e) {
;
}
}
}
}",0
875,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
synchronized (this) {
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
876,"public synchronized void clear() {
for (Iterator entries = _poolMap.entrySet().iterator(); entries.hasNext(); ) {
final Map.Entry entry = (Map.Entry) entries.next();
final Object key = entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (entry.getValue())).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
}
_poolMap.clear();
_poolList.clear();
_totalIdle = 0;
notifyAll();
}",0
877,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
878,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
}
}
}",0
879,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
}
}
}",0
880,"public void run() {
try {
evict();
} catch (Exception e) {
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
881,"public synchronized void evict() throws Exception {
assertOpen();
if (!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0) && (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0) && (idleTimeMilis > _softMinEvictableIdleTimeMillis) && (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if (_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
}
}
}",0
882,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
883,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
884,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
885,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
886,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
887,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
888,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
889,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
890,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
_factory.passivateObject(obj);
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
891,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
892,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
893,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
894,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
895,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
896,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
897,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
898,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
899,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
900,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
901,"@Override
public E removeLast() {
checkForComod();
return super.removeLast();
}",0
902,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
903,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
904,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
905,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
906,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
907,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
908,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
909,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
910,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
911,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
912,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
913,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
914,"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0
915,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
916,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
917,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
918,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
919,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
920,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
921,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
922,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
923,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
924,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
925,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
926,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
927,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
928,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
929,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
930,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
931,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
932,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
933,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
934,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
935,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
936,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
937,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
938,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll();
}",0
939,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
940,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
941,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
942,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
943,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
944,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
945,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
946,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy.fillInStackTrace();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
947,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
948,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
949,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
950,private long createCount = 0;,0
951,"@Override
public synchronized void returnObject(final T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
952,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
953,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
954,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
955,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
956,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
957,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
958,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
959,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
960,"protected void listableInserted(Listable elt) {
if (null == _cur.next() && null == _cur.prev()) {
_cur.setNext(elt);
} else if (_cur.prev() == elt.prev()) {
_cur.setNext(elt);
}
if (_cur.next() == elt.next()) {
_cur.setPrev(elt);
}
if (_lastReturned == elt) {
_lastReturned = null;
}
}",0
961,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
962,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
963,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
964,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
965,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
966,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
967,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
968,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
969,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
970,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
971,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
972,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
973,protected int _totIdle = 0;,0
974,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
975,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
976,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
977,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
978,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
979,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
980,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
981,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
982,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
983,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
984,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
985,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
986,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
987,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
988,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
989,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
990,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
991,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0
992,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
993,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
994,"@Override
public int compareTo(final PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
995,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy.fillInStackTrace();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
996,"@Override
public synchronized void returnObject(final T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
997,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception ignored) {
}
}",0
998,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
999,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception ignored) {
}
}",0
1000,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception ignored) {
}
}",0
1001,PooledObjectState getState();,0
1002,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowInstant = now();
lastUseInstant = lastBorrowInstant;
borrowedCount++;
if (logAbandoned) {
borrowedBy.fillInStackTrace();
}
return true;
}
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
}
return false;
}",0
1003,"@Override
public int compareTo(final PooledObject<T> other) {
final int compareTo = getLastReturnInstant().compareTo(other.getLastReturnInstant());
if (compareTo == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return compareTo;
}",0
1004,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && getNumIdle() < 2 && getNumActive() > getMaxTotal() - 3) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitMillis < 0 ? objectDeque.getIdleObjects().takeFirst() : objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
} catch (InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitMillis="" + borrowMaxWaitMillis));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
1005,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
underTest.endEvictionTest(idleObjects);
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
1006,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
underTest.endEvictionTest(idleObjects);
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
1007,"@Override
public synchronized void addObject() throws E {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception ignored) {
}
}
}",0
1008,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception e) {
}
}",0
1009,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
1010,"void cancel() {
scheduledFuture.cancel(false);
}",0
1011,"@Override
public int compareTo(final PooledObject<T> other) {
final int compareTo = getLastReturnInstant().compareTo(other.getLastReturnInstant());
if (compareTo == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return compareTo;
}",0
1012,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitMillis < 0 ? objectDeque.getIdleObjects().takeFirst() : objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
} catch (InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitMillis="" + borrowMaxWaitMillis));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
1013,"public T borrowObject(final Duration borrowMaxWaitDuration) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitDuration.isNegative() ? idleObjects.takeFirst() : idleObjects.pollFirst(borrowMaxWaitDuration);
} catch (final InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitDuration="" + borrowMaxWaitDuration));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p, DestroyMode.NORMAL);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
1014,"@Override
public synchronized void returnObject(final T obj) throws E {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
1015,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
1016,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
1017,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
1018,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
1019,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
1020,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
1021,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
1022,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
1023,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
1024,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
1025,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
1026,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
1027,"private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext(); ) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
} finally {
synchronized (this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}",0
1028,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
1029,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}",0
1030,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
1031,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
1032,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
1033,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}",0
1034,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
1035,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
1036,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
1037,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
1038,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
1039,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
1040,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
1041,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
1042,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
1043,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
1044,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
1045,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
1046,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
1047,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
1048,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
1049,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
1050,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
1051,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
1052,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
1053,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
1054,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
1055,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
1056,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
1057,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
1058,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
1059,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
1060,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
1061,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
1062,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
1063,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
1064,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
1065,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
1066,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
1067,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
1068,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
1069,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
1070,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
1071,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
1072,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
1073,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
1074,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
1075,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
1076,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
1077,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
1078,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
1079,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
1080,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
1081,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
1082,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
1083,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
1084,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
1085,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
1086,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
1087,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
1088,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
1089,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
1090,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
1091,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
1092,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
1093,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
1094,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
1095,PooledObjectState getState();,0
1096,"@Override
public int compareTo(final PooledObject<T> other) {
final int compareTo = getLastReturnInstant().compareTo(other.getLastReturnInstant());
if (compareTo == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return compareTo;
}",0
1097,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
}
if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
1098,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
1099,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitMillis < 0 ? objectDeque.getIdleObjects().takeFirst() : objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
} catch (InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitMillis="" + borrowMaxWaitMillis));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
1100,private long createCount;,0
1101,"@Override
public synchronized void addObject() throws E {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
1102,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
1103,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
1104,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
1105,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
1106,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
1107,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
1108,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
1109,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
1110,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
1111,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
1112,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
1113,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
synchronized (this) {
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
1114,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
notifyAll();
}
}
}",0
1115,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
1116,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e2) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",0
1117,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
1118,"public void run() {
try {
evict();
} catch (Exception e) {
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
1119,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
notifyAll();
}
}
}
}",0
1120,"public synchronized void clear() {
for (Iterator it = _pool.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
_pool.clear();
notifyAll();
}",0
1121,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
1122,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
1123,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
1124,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
1125,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
1126,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
1127,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
1128,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
1129,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
1130,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
1131,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(Object other) {
return ((IdentityWrapper) other).instance == instance;
}",0
1132,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
1133,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
1134,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
1135,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
1136,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
1137,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
1138,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
1139,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
