,source,target
0,protected List reactorProjects;,0
1,protected boolean outputAbsoluteArtifactFilename;,0
2,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3,public boolean silent;,0
4,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
5,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0
6,private Renderer siteRenderer;,0
7,private File outputDirectory;,0
8,private ProjectDependencyAnalyzer analyzer;,0
9,"protected String getOutputDirectory() {
getLog().info(outputDirectory.toString());
return outputDirectory.toString();
}",0
10,"public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}",0
11,private MavenProject project;,0
12,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
13,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(outputFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0
14,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
if (StringUtils.isEmpty(fileSeparator)) {
isFileSepSet = false;
} else {
isFileSepSet = true;
}
if (StringUtils.isEmpty(pathSeparator)) {
isPathSepSet = false;
} else {
isPathSepSet = true;
}
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
String separator = File.separator;
if (File.separator.equals(""\\"")) {
separator = ""\\\\"";
}
cpString = cpString.replaceAll(separator, fileSeparator);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
15,private File cpFile;,0
16,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
17,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
18,protected ArtifactRepositoryFactory repositoryFactory;,0
19,protected ArtifactInstaller installer;,0
20,"private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}",0
21,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
22,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
23,"private String serialiseDependencyTree(DependencyNode rootNode) {
StringWriter writer = new StringWriter();
TreeTokens treeTokens = toTreeTokens(tokens);
DependencyNodeVisitor visitor = getSerializingDependencyNodeVisitor(writer);
// TODO: remove the need for this when the serializer can calculate last nodes from visitor calls only
visitor = new BuildingDependencyNodeVisitor(visitor);
DependencyNodeFilter filter = createDependencyNodeFilter();
if (filter != null) {
CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();
DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor(collectingVisitor, filter);
rootNode.accept(firstPassVisitor);
DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());
visitor = new FilteringDependencyNodeVisitor(visitor, secondPassFilter);
}
rootNode.accept(visitor);
return writer.toString();
}",0
24,private boolean excludeTransitive;,0
25,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Iterator i = plugins.iterator(); i.hasNext(); ) {
Artifact plugin = (Artifact) i.next();
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
Set transitiveDependencies = this.resolveArtifactDependencies(plugin);
for (Iterator transIter = transitiveDependencies.iterator(); transIter.hasNext(); ) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName((Artifact) transIter.next(), false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
26,"public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}",0
27,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
28,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
29,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
30,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
31,"protected DependencyStatusSets getDependencySets(boolean stopOnFailure) throws MojoExecutionException {
FilterArtifacts filter = new FilterArtifacts();
filter.addFilter(new ProjectTransitivityFilter(project.getDependencyArtifacts(), this.excludeTransitive));
filter.addFilter(new ScopeFilter(DependencyUtil.cleanToBeTokenizedString(this.includeScope), DependencyUtil.cleanToBeTokenizedString(this.excludeScope)));
filter.addFilter(new TypeFilter(DependencyUtil.cleanToBeTokenizedString(this.includeTypes), DependencyUtil.cleanToBeTokenizedString(this.excludeTypes)));
filter.addFilter(new ClassifierFilter(DependencyUtil.cleanToBeTokenizedString(this.includeClassifiers), DependencyUtil.cleanToBeTokenizedString(this.excludeClassifiers)));
filter.addFilter(new GroupIdFilter(DependencyUtil.cleanToBeTokenizedString(this.includeGroupIds), DependencyUtil.cleanToBeTokenizedString(this.excludeGroupIds)));
filter.addFilter(new ArtifactIdFilter(DependencyUtil.cleanToBeTokenizedString(this.includeArtifactIds), DependencyUtil.cleanToBeTokenizedString(this.excludeArtifactIds)));
Set<Artifact> artifacts = project.getArtifacts();
try {
artifacts = filter.filter(artifacts);
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
DependencyStatusSets status = null;
if (StringUtils.isNotEmpty(classifier)) {
status = getClassifierTranslatedDependencies(artifacts, stopOnFailure);
} else {
status = filterMarkedDependencies(artifacts);
}
return status;
}",0
32,protected boolean outputAbsoluteArtifactFilename;,0
33,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
34,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
35,protected File outputFile;,0
36,protected MavenProjectBuilder mavenProjectBuilder;,0
37,private File cpFile;,0
38,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
39,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
40,boolean attach;,0
41,"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0
42,"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0
43,"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0
44,protected ArtifactRepositoryFactory repositoryFactory;,0
45,"private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}",0
46,protected MavenProject project;,0
47,"public void execute() throws MojoExecutionException {
Set<Artifact> artifacts = getProject().getArtifacts();
for (Artifact artifact : artifacts) {
project.getProperties().setProperty(artifact.getDependencyConflictId(), artifact.getFile().getAbsolutePath());
}
}",0
48,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
49,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
50,"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
51,private List remotePluginRepositories;,0
52,private boolean excludeTransitive;,0
53,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
54,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
55,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
56,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
57,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
58,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
59,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
60,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
61,protected MavenProject project;,0
62,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
63,protected boolean outputAbsoluteArtifactFilename;,0
64,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0
65,protected MavenProjectBuilder mavenProjectBuilder;,0
66,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
67,private String groupId;,0
68,private boolean excludeTransitive;,0
69,private List remotePluginRepositories;,0
70,"public boolean include(Artifact artifact) {
if (artifactsGAMatch(artifact, projectArtifact)) {
return true;
}
for (Artifact depArtifact : directDependencyArtifacts) {
if (this.artifactsGAMatch(artifact, depArtifact)) {
return true;
}
}
return false;
}",0
71,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
72,"@Parameter
protected boolean ignorePermissions;",0
73,"@Parameter
protected boolean useJvmChmod = true;",0
74,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
75,"@Parameter
protected boolean ignorePermissions;",0
76,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0
77,"@Parameter
protected boolean useJvmChmod = true;",0
78,"@Parameter
protected boolean useJvmChmod = true;",0
79,"protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
80,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
81,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
82,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
83,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
84,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
85,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
86,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
87,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
88,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
89,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
90,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
91,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
92,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
93,"@Parameter
protected boolean useJvmChmod = true;",0
94,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
95,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
96,"@Parameter
protected boolean useJvmChmod = true;",0
97,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
98,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
99,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
100,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
101,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
102,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
103,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
104,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
105,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
106,"@Parameter
protected boolean useJvmChmod = true;",0
107,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
108,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
109,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
110,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
111,"@Parameter
protected boolean useJvmChmod = true;",0
112,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
113,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
114,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
115,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
116,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
117,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
118,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
119,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
120,"@Parameter
protected boolean useJvmChmod = true;",0
121,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
122,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
123,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
124,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
125,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
126,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
127,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
128,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
129,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
130,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
131,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
132,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
133,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
134,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
135,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
136,"@Parameter
protected boolean useJvmChmod = true;",0
137,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
138,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
139,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
140,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
141,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
142,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
143,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
144,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
145,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
146,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
147,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
148,public boolean silent;,0
149,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
150,protected boolean outputAbsoluteArtifactFilename;,0
151,protected MavenProject project;,0
152,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
153,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
154,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
155,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0
156,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
157,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
158,"public Map getMismatch(Map depMgtMap, Set allDependencyArtifacts) {
Map mismatchMap = new HashMap();
Iterator iter = allDependencyArtifacts.iterator();
while (iter.hasNext()) {
Artifact dependencyArtifact = (Artifact) iter.next();
Dependency depFromDepMgt = (Dependency) depMgtMap.get(getArtifactManagementKey(dependencyArtifact));
if (depFromDepMgt != null) {
ArtifactVersion artifactVersion = new DefaultArtifactVersion(dependencyArtifact.getVersion());
dependencyArtifact.isSnapshot();
if (!depFromDepMgt.getVersion().equals(dependencyArtifact.getBaseVersion())) {
mismatchMap.put(dependencyArtifact, depFromDepMgt);
}
}
}
return mismatchMap;
}",0
159,"private boolean checkDependencies() throws MojoExecutionException {
boolean result = false;
try {
ProjectDependencyAnalysis analysis = analyzer.analyze(project);
if (this.displayUsed) {
getLog().info(""Used declared dependencies:"");
logArtifacts(analysis.getUsedDeclaredArtifacts(), false);
}
getLog().info(""Used undeclared dependencies:"");
Set usedUndeclared = analysis.getUsedUndeclaredArtifacts();
logArtifacts(usedUndeclared, true);
getLog().info(""Unused declared dependencies:"");
Set unusedDeclared = analysis.getUnusedDeclaredArtifacts();
if (ignoreNonCompile) {
Iterator iter = unusedDeclared.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
if (!artifact.getScope().equals(Artifact.SCOPE_COMPILE)) {
iter.remove();
}
}
}
logArtifacts(unusedDeclared, false);
if (outputXML) {
writeDependencyXML(usedUndeclared);
}
if (scriptableOutput) {
writeScriptableOutput(usedUndeclared);
}
if ((usedUndeclared != null && !usedUndeclared.isEmpty()) || unusedDeclared != null && !unusedDeclared.isEmpty()) {
getLog().warn(""Potential problems discovered."");
result = true;
}
} catch (ProjectDependencyAnalyzerException exception) {
throw new MojoExecutionException(""Cannot analyze dependencies"", exception);
}
return result;
}",0
160,"private boolean checkDependencies() throws MojoExecutionException {
boolean result = false;
try {
ProjectDependencyAnalysis analysis = analyzer.analyze(project);
if (this.displayUsed) {
getLog().info(""Used declared dependencies:"");
logArtifacts(analysis.getUsedDeclaredArtifacts(), false);
}
getLog().info(""Used undeclared dependencies:"");
Set usedUndeclared = analysis.getUsedUndeclaredArtifacts();
logArtifacts(usedUndeclared, true);
getLog().info(""Unused declared dependencies:"");
Set unusedDeclared = analysis.getUnusedDeclaredArtifacts();
if (ignoreNonCompile) {
Iterator iter = unusedDeclared.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
if (!artifact.getScope().equals(Artifact.SCOPE_COMPILE)) {
iter.remove();
}
}
}
logArtifacts(unusedDeclared, false);
if (outputXML) {
writeDependencyXML(usedUndeclared);
}
if (scriptableOutput) {
writeScriptableOutput(usedUndeclared);
}
if ((usedUndeclared != null && !usedUndeclared.isEmpty()) || unusedDeclared != null && !unusedDeclared.isEmpty()) {
getLog().warn(""Potential problems discovered."");
result = true;
}
} catch (ProjectDependencyAnalyzerException exception) {
throw new MojoExecutionException(""Cannot analyze dependencies"", exception);
}
return result;
}",0
161,private MavenProject project;,0
162,"private String readClasspathFile() throws IOException {
if (!cpFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(cpFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0
163,private String prefix;,0
164,private File cpFile;,0
165,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + cpFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
166,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
167,private boolean regenerateFile;,0
168,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
169,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
170,"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}",0
171,protected boolean outputScope;,0
172,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
173,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
174,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
175,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
176,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
177,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
178,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
179,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
180,"@Parameter
protected boolean useJvmChmod = true;",0
181,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
182,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
183,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}",0
184,"@Parameter
protected boolean useJvmChmod = true;",0
185,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
186,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
187,"@Parameter
protected boolean useJvmChmod = true;",0
188,"@Override
protected void doExecute() throws MojoExecutionException {
results = this.getDependencySets(false, includeParents);
String output = getOutput(outputAbsoluteArtifactFilename, outputScope, sort);
try {
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
} catch (IOException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
189,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
190,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
191,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
192,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
193,public boolean silent;,0
194,protected List reactorProjects;,0
195,protected MavenProject project;,0
196,protected boolean outputAbsoluteArtifactFilename;,0
197,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
198,private boolean excludeTransitive;,0
199,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
200,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
201,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
202,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
203,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
204,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
205,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
206,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
207,"@Parameter
protected boolean useJvmChmod = true;",0
208,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
209,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
210,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
211,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
212,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
213,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
214,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
215,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
216,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
217,protected MavenProject project;,0
218,protected boolean outputAbsoluteArtifactFilename;,0
219,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
220,"public void setUseSubDirectoryPerScope(boolean theUseSubDirectoryPerScope) {
this.useSubDirectoryPerScope = theUseSubDirectoryPerScope;
}",0
221,"protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.getLocal());
return resolveDependencyArtifacts(pomProject);
}",0
222,protected MavenProjectBuilder mavenProjectBuilder;,0
223,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
224,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
225,private MavenProjectHelper projectHelper;,0
226,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
227,private File cpFile;,0
228,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
229,boolean outputFilterFile;,0
230,boolean outputFilterFile;,0
231,"private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}",0
232,"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0
233,protected ArtifactInstaller installer;,0
234,protected ArtifactRepositoryFactory repositoryFactory;,0
235,"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0
236,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
237,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
238,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
239,protected List<MavenProject> reactorProjects;,0
240,"protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
ArtifactRepository local = super.getLocal();
if (this.localRepositoryDirectory != null) {
String url = ""file://"" + this.localRepositoryDirectory.getAbsolutePath();
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(local.getId(), url, local.getLayout(), local.getSnapshots(), local.getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
} else {
this.overrideLocalRepository = local;
}
return this.overrideLocalRepository;
}",0
241,"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
242,private ArtifactRepositoryFactory artifactRepositoryManager;,0
243,private boolean excludeTransitive;,0
244,private List<ArtifactRepository> remotePluginRepositories;,0
245,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
246,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
247,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
248,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
249,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
250,"public AbstractDependencyMojo() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
}",0
251,protected boolean useSubDirectoryPerArtifact;,0
252,protected boolean overWriteSnapshots;,0
253,"protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}",0
254,"protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}",0
255,private ArrayList artifactItems;,0
256,private File markersDirectory;,0
257,private File markersDirectory;,0
258,private String groupId;,0
259,private List remotePluginRepositories;,0
260,private boolean excludeTransitive;,0
261,"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0
262,"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0
263,"private void log(Set artifacts, Log log) {
log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
log.debug("""" + artifact);
}
}",0
264,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
265,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
266,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}",0
267,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
268,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
269,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
270,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
271,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
272,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
273,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
274,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
275,"@Parameter
protected boolean useJvmChmod = true;",0
276,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
277,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
278,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
279,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
280,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
281,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
282,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
283,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
284,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
285,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
286,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
287,"@Parameter
protected boolean useJvmChmod = true;",0
288,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
289,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
290,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
291,"@Parameter
protected boolean useJvmChmod = true;",0
292,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
293,"@Parameter
protected boolean useJvmChmod = true;",0
294,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
295,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
296,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
297,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
298,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
299,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
300,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
getLog().info(""Unpacking "" + file.getPath() + ""to\n "" + location.getPath() + ""\nwith Includes "" + includes + "" and excludes:"" + excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
301,protected boolean outputAbsoluteArtifactFilename;,0
302,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
303,private Renderer siteRenderer;,0
304,"public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}",0
305,private File outputDirectory;,0
306,private MavenProject project;,0
307,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
if (StringUtils.isEmpty(fileSeparator)) {
isFileSepSet = false;
} else {
isFileSepSet = true;
}
if (StringUtils.isEmpty(pathSeparator)) {
isPathSepSet = false;
} else {
isPathSepSet = true;
}
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
String separator = File.separator;
if (File.separator.equals(""\\"")) {
separator = ""\\\\"";
}
cpString = cpString.replaceAll(separator, fileSeparator);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
308,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
309,private MavenProjectHelper projectHelper;,0
310,boolean attach;,0
311,boolean outputFilterFile;,0
312,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
313,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(outputFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0
314,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
315,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
316,private List remotePluginRepositories;,0
317,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
318,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
319,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
320,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
321,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
322,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
323,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
324,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
325,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
326,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
327,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
328,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}",0
329,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
330,"@Parameter
protected boolean useJvmChmod = true;",0
331,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
332,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
333,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
334,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
335,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
336,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
337,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
338,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
339,"private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
340,"private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
341,"private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
342,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
343,"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
344,"@Parameter(defaultValue = ""${reactorProjects}"", readonly = true, required = true)
protected List<MavenProject> reactorProjects;",0
345,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
346,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
347,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
348,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
349,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
350,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
351,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
352,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
353,"@Parameter
protected boolean useJvmChmod = true;",0
354,"@Parameter
protected boolean useJvmChmod = true;",0
355,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
356,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
357,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
358,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
359,protected boolean outputAbsoluteArtifactFilename;,0
360,protected MavenProject project;,0
361,protected MavenProject project;,0
362,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
363,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0
364,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
365,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
366,"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}",0
367,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
368,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
369,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
370,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
371,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
372,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
373,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
374,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
375,"@Parameter
protected boolean useJvmChmod = true;",0
376,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
377,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
378,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
379,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter "" + ""cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
try (BufferedReader r = new BufferedReader(new FileReader(outputFile))) {
for (String line = r.readLine(); line != null; line = r.readLine()) {
sb.append(line);
}
return sb.toString();
}
}",0
380,"@Parameter
protected boolean useJvmChmod = true;",0
381,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
382,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
383,"private StringBuilder buildArtifactListOutput(Set<Artifact> artifacts, boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
List<String> artifactStringList = new ArrayList<>();
for (Artifact artifact : artifacts) {
MessageBuilder messageBuilder = MessageUtils.buffer();
messageBuilder.a(""   "");
if (theOutputScope) {
messageBuilder.a(artifact.toString());
} else {
messageBuilder.a(artifact.getId());
}
if (outputAbsoluteArtifactFilename) {
try {
String artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
messageBuilder.a(':').a(artifactFilename);
} catch (NullPointerException e) {
}
}
if (theOutputScope && artifact.isOptional()) {
messageBuilder.a("" (optional)"");
}
if (artifact.getFile() != null) {
ModuleDescriptor moduleDescriptor = getModuleDescriptor(artifact.getFile());
if (moduleDescriptor != null) {
messageBuilder.project("" -- module "" + moduleDescriptor.name);
if (moduleDescriptor.automatic) {
if (""MANIFEST"".equals(moduleDescriptor.moduleNameSource)) {
messageBuilder.strong("" [auto]"");
} else {
messageBuilder.warning("" (auto)"");
}
}
}
}
artifactStringList.add(messageBuilder.toString() + System.lineSeparator());
}
if (theSort) {
Collections.sort(artifactStringList);
}
for (String artifactString : artifactStringList) {
sb.append(artifactString);
}
return sb;
}",0
384,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
385,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
DependencyUtil.write(output, outputFile, appendOutput, getLog());
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
386,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
try (FileWriter writer = new FileWriter(file, append)) {
writer.write(string);
}
}",0
387,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
388,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
389,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
390,"private void reResolveArtifacts(MavenProject project, Set<Artifact> artifacts, ArtifactFilter filter) throws ArtifactResolutionException, ArtifactNotFoundException {
for (Artifact artifact : artifacts) {
try {
Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), null, ""pom"");
resolver.resolveAlways(pomArtifact, remoteRepositories, localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
}
}
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Artifact artifact : artifacts) {
verbose(""Resolving artifact: "" + artifact.getId());
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
391,"private void reResolveArtifacts(MavenProject project, Set<Artifact> artifacts, ArtifactFilter filter) throws ArtifactResolutionException, ArtifactNotFoundException {
for (Artifact artifact : artifacts) {
try {
Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), null, ""pom"");
resolver.resolveAlways(pomArtifact, remoteRepositories, localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
}
}
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Artifact artifact : artifacts) {
verbose(""Resolving artifact: "" + artifact.getId());
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
392,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
393,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
394,"@Parameter
protected boolean useJvmChmod = true;",0
395,"@Parameter
protected boolean ignorePermissions;",0
396,"@Parameter
protected boolean useJvmChmod = true;",0
397,"@Parameter
protected boolean useJvmChmod = true;",0
398,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0
399,"@Parameter
protected boolean useJvmChmod = true;",0
400,"protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
401,"protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
402,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
403,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
404,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
405,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
406,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
407,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
408,"public AbstractDependencyMojo() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
}",0
409,protected MavenProjectBuilder mavenProjectBuilder;,0
410,protected File outputDirectory;,0
411,"protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}",0
412,private File markersDirectory;,0
413,private boolean excludeTransitive;,0
414,private List remotePluginRepositories;,0
415,"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0
416,"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0
417,"private void log(Set artifacts, Log log) {
log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
log.debug("""" + artifact);
}
}",0
418,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
419,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
420,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers, boolean overwrite) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.setOverwrite(overwrite);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
421,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
422,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
423,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
424,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
425,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
426,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
427,"@Parameter
protected boolean useJvmChmod = true;",0
428,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
429,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
430,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
431,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
432,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
433,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
434,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
435,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
436,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
try (FileWriter writer = new FileWriter(file, append)) {
writer.write(string);
}
}",1
437,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
438,"public void execute() throws MojoExecutionException, MojoFailureException {
if (artifactId == null && artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifactId == null) {
String[] tokens = StringUtils.split(artifact, "":"");
if (tokens.length < 3 && tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify groupId:artifactId:version[:packaging][:classifier] "" + artifact);
}
groupId = tokens[0];
artifactId = tokens[1];
version = tokens[2];
if (tokens.length >= 4) {
packaging = tokens[3];
}
if (tokens.length == 5) {
classifier = tokens[4];
} else {
classifier = null;
}
}
Artifact toDownload = classifier == null ? artifactFactory.createBuildArtifact(groupId, artifactId, version, packaging) : artifactFactory.createArtifactWithClassifier(groupId, artifactId, version, packaging, classifier);
Artifact dummyOriginatingArtifact = artifactFactory.createBuildArtifact(""org.apache.maven.plugins"", ""maven-downloader-plugin"", ""1.0"", ""jar"");
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
ArtifactRepository remoteRepo = artifactRepositoryFactory.createArtifactRepository(repositoryId, repositoryUrl, repositoryLayout, always, always);
if (pomRemoteRepositories == null) {
pomRemoteRepositories = new ArrayList();
}
List repoList = new ArrayList(pomRemoteRepositories);
if (remoteRepositories != null) {
// TODO: remote repositories as Strings?
repoList.addAll(Arrays.asList(StringUtils.split(remoteRepositories, "","")));
}
repoList.add(remoteRepo);
try {
if (transitive) {
artifactResolver.resolveTransitively(Collections.singleton(toDownload), dummyOriginatingArtifact, repoList, localRepository, source);
} else {
artifactResolver.resolve(toDownload, repoList, localRepository);
}
} catch (AbstractArtifactResolutionException e) {
throw new MojoExecutionException(""Couldn't download artifact: "" + e.getMessage(), e);
}
}",1
439,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",1
440,"public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}",0
441,"public Set<Artifact> translate(Set<Artifact> artifacts, Log log) {
Set<Artifact> results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet<Artifact>();
for (Artifact artifact : artifacts) {
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",1
442,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
443,protected boolean appendOutput;,0
444,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
445,"protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
if (this.localRepositoryDirectory != null) {
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(super.getLocal().getId(), ""file://"" + this.localRepositoryDirectory.getAbsolutePath(), super.getLocal().getLayout(), super.getLocal().getSnapshots(), super.getLocal().getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
return this.overrideLocalRepository;
}
this.overrideLocalRepository = super.getLocal();
return this.overrideLocalRepository;
}",0
446,private List remotePluginRepositories;,1
447,private MavenProject project;,0
448,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",1
449,private File markersDirectory;,0
450,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
451,"public void execute() throws MojoExecutionException {
try {
ArtifactResolutionResult result = this.artifactCollector.collect(project.getArtifacts(), project.getArtifact(), this.getLocal(), this.remoteRepos, this.artifactMetadataSource, new ScopeArtifactFilter(Artifact.SCOPE_TEST), new ArrayList());
HashSet repos = new HashSet();
for (Iterator<ResolutionNode> i = result.getArtifactResolutionNodes().iterator(); i.hasNext(); ) {
ResolutionNode node = i.next();
repos.addAll(node.getRemoteRepositories());
}
this.getLog().info(""Repositories Used by this build:"");
for (Iterator i = repos.iterator(); i.hasNext(); ) {
this.getLog().info(i.next().toString());
}
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Unable to resolve artifacts"", e);
}
}",0
452,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
writer.close();
writer = null;
} finally {
IOUtil.close(writer);
}
}",0
453,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
writer.close();
writer = null;
} finally {
IOUtil.close(writer);
}
}",0
454,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try (Writer w = new BufferedWriter(new FileWriter(out))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",1
455,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
456,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
457,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
w.close();
w = null;
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
458,protected boolean useSubDirectoryPerType;,0
