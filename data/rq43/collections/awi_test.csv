,source,target
0,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",1
1,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
2,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
3,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
4,"private final Transformer<C, K> keyTransformer;",0
5,private final Predicate<? super E> predicate;,0
6,"private final Transformer<? super I, ? extends O> transformer;",0
7,private final Closure<? super E>[] iClosures;,0
8,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
9,private final Closure<? super T> iClosure;,0
10,private final Factory<? extends O> iFactory;,0
11,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
12,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
13,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
14,private final Predicate<? super T> iPredicate;,0
15,private final Predicate<? super T> iPredicate;,0
16,private final Predicate<? super T> iPredicate;,0
17,private final Predicate<? super T> iPredicate2;,0
18,private final Predicate<? super T> iPredicate;,0
19,private final Closure<? super E> iDefault;,0
20,"private final Transformer<? super T, ? extends T> iTransformer;",0
21,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
22,private final Factory<? extends E> factory;,0
23,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
24,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
25,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
26,"@Override
public int hashCode() {
return hash;
}",0
27,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
28,"protected Node<K, V> next;",0
29,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
30,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
return SetUtils.isEqualSet(set, otherSet);
}",0
31,"public void trimToSize() {
for (Collection<V> coll : getMap().values()) {
final ArrayList<V> list = (ArrayList<V>) coll;
list.trimToSize();
}
}",0
32,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
33,protected final AbstractMapMultiSet<E> parent;,0
34,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
35,"@Override
public void clear() {
Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();
Set<K> currentKeys = keySet();
while (it.hasNext()) {
if (currentKeys.contains(it.next().getKey())) {
it.remove();
}
}
}",0
36,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
37,"@Override
public void remove() {
if (!canRemove) {
throw new IllegalStateException(""Iterator remove() can only be called once after next()"");
}
final Object value = last.getValue();
super.remove();
parent.reverseMap.remove(value);
last = null;
canRemove = false;
}",0
38,"@Override
public void remove() {
if (!canRemove) {
throw new IllegalStateException(""Iterator remove() can only be called once after next()"");
}
final V value = last.getValue();
iterator.remove();
parent.reverseMap.remove(value);
last = null;
canRemove = false;
}",0
39,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
40,"boolean add(long bits) {
if (size == data.length) {
data = Arrays.copyOf(data, size * 2);
}
data[size++] = bits;
return true;
}",0
41,"private final Transformer<C, K> keyTransformer;",0
42,private final Predicate<? super E> predicate;,0
43,"protected final Transformer<? super E, ? extends E> transformer;",0
44,private final Comparator<? super E> comparator;,0
45,private final Predicate<? super T> iPredicate2;,0
46,private final Closure<? super E>[] iClosures;,0
47,private final Closure<? super T> iClosure;,0
48,private final Factory<? extends O> iFactory;,0
49,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
50,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
51,private final Predicate<? super T> iPredicate;,0
52,private final Predicate<? super T> iPredicate;,0
53,private final Predicate<? super E>[] iPredicates;,0
54,private final Predicate<? super I>[] iPredicates;,0
55,"private final Transformer<? super T, Boolean> iTransformer;",0
56,"public E[] getArray() {
return this.array;
}",0
57,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
58,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
59,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
60,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
final ReferenceEntry<K, V> refEntry = (ReferenceEntry<K, V>) entry;
if (refEntry.purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
refEntry.onPurge();
return;
}
previous = entry;
entry = entry.next;
}
}",0
61,"@Override
public int hashCode() {
return hash;
}",0
62,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
current = next;
next = next.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return current;
}",0
63,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
64,"protected Node<K, V> next;",0
65,"@Override
public boolean equals(final Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (!(other instanceof Set)) {
return false;
}
final Set<?> otherSet = (Set<?>) other;
return SetUtils.isEqualSet(set, otherSet);
}",0
66,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<>(map);
}",0
67,"@Override
public String getProperty(final String key, final String defaultValue) {
return defaultValue;
}",0
68,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
69,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
70,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
71,"private final Transformer<C, K> keyTransformer;",0
72,private final Comparator<? super E> nonNullComparator;,0
73,private final Comparator<E> comparator;,0
74,private final Comparator<O> decorated;,0
75,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
76,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
77,"private final Transformer<? super I, ? extends O> iDefault;",0
78,"private final Transformer<? super E, ?> iTransformer;",0
79,"public E[] getArray() {
return this.array;
}",0
80,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
81,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
82,"protected List<E> getList() {
return (List<E>) decorated();
}",0
83,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
84,"V currentValue, nextValue;",0
85,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
86,"@Override
public int hashCode() {
return hash;
}",0
87,"protected Node<K, V> next;",0
88,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
89,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
90,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
91,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
92,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
93,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
94,"private UnmodifiableBidiMap<V, K> inverse;",0
95,private final Predicate<? super E> predicate;,0
96,"protected final Transformer<? super E, ? extends E> transformer;",0
97,"private final Transformer<? super I, ? extends O> transformer;",0
98,private final Closure<? super E>[] iClosures;,0
99,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
100,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
101,private final Predicate<? super I> iPredicate;,0
102,private final Predicate<? super T> iPredicate;,0
103,private final Predicate<? super T> iPredicate;,0
104,private final Predicate<? super I>[] iPredicates;,0
105,"private final Transformer<? super E, ?> iTransformer;",0
106,"private final Transformer<? super T, Boolean> iTransformer;",0
107,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
108,"public E[] getArray() {
return this.array;
}",0
109,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
110,private final Factory<? extends E> factory;,0
111,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
112,"protected List<E> getList() {
return (List<E>) decorated();
}",0
113,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
114,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
115,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
116,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
117,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
118,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
119,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
120,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
121,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
122,"private UnmodifiableBidiMap<V, K> inverse;",0
123,"private final Transformer<C, K> keyTransformer;",0
124,"protected final Transformer<? super E, ? extends E> transformer;",0
125,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
126,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
127,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
128,private transient Method iCloneMethod;,0
129,"private final Transformer<? super I, ? extends O> iDefault;",0
130,"private final Transformer<? super E, ?> iTransformer;",0
131,"public E[] getArray() {
return this.array;
}",0
132,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
133,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
134,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
135,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
136,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
137,"public int indexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
138,"@Override
public boolean equals(Object other) {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof List)) {
return false;
}
List<?> otherList = (List<?>) other;
if (ListUtils.isEqualList(list, otherList) == false) {
return false;
}
return true;
}",0
139,"public List<V> subList(int fromIndex, int toIndex) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.subList(fromIndex, toIndex);
}",0
140,"public int lastIndexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
141,"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0
142,private transient Collection<V> valuesView;,0
143,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
if (SetUtils.isEqualSet(set, otherSet) == false) {
return false;
}
return true;
}",0
144,"private final Transformer<? super K, ? extends K> keyTransformer;",0
145,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
146,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
147,"private void writeObject(final ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeObject(comparator());
super.doWriteObject(out);
}",0
148,"private final Transformer<C, K> keyTransformer;",0
149,private final List<Comparator<E>> comparatorChain;,0
150,private final Comparator<O> decorated;,0
151,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
152,private final Equator<T> equator;,0
153,private final Factory<? extends O> iFactory;,0
154,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
155,private final Predicate<? super I> iPredicate;,0
156,private final Predicate<? super T> iPredicate;,0
157,private final Predicate<? super T> iPredicate;,0
158,"private final Transformer<? super I, ? extends O>[] iTransformers;",0
159,"public E[] getArray() {
return this.array;
}",0
160,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
161,"private final Transformer<Integer, ? extends E> transformer;",0
162,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
163,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
164,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
165,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
166,"@Override
public int hashCode() {
return hash;
}",0
167,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
168,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
169,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
170,"@Override
public String getProperty(final String key, final String defaultValue) {
return defaultValue;
}",0
171,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
172,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
173,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
174,"private void writeObject(final ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeObject(comparator());
super.doWriteObject(out);
}",0
175,"@Override
public void remove() {
if (canRemove == false) {
throw new IllegalStateException(""Iterator remove() can only be called once after next()"");
}
final Object value = last.getValue();
super.remove();
parent.reverseMap.remove(value);
last = null;
canRemove = false;
}",0
176,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
177,"private UnmodifiableBidiMap<V, K> inverse;",0
178,"private final Transformer<C, K> keyTransformer;",0
179,private final Predicate<? super E> predicate;,0
180,"protected final Transformer<? super E, ? extends E> transformer;",0
181,private final List<Comparator<E>> comparatorChain;,0
182,private final Comparator<? super E> nonNullComparator;,0
183,private final Comparator<? super E> comparator;,0
184,"private final Transformer<? super I, ? extends O> transformer;",0
185,private final Closure<? super E>[] iClosures;,0
186,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
187,private final Closure<? super T> iClosure;,0
188,private final Comparator<T> comparator;,0
189,private final Factory<? extends O> iFactory;,0
190,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
191,private final Predicate<? super E> iPredicate;,0
192,private final Predicate<? super T> iPredicate;,0
193,private final Predicate<? super T> iPredicate;,0
194,private final Closure<? super E>[] iClosures;,0
195,private final Predicate<? super I>[] iPredicates;,0
196,"private final Transformer<? super E, ?> iTransformer;",0
197,"private final Transformer<? super T, Boolean> iTransformer;",0
198,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
199,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
200,"protected List<E> getList() {
return (List<E>) decorated();
}",0
201,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
202,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
203,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
204,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
205,"@Override
public int hashCode() {
return hash;
}",0
206,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
final ReferenceEntry<K, V> refEntry = (ReferenceEntry<K, V>) entry;
if (refEntry.purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
refEntry.onPurge();
return;
}
previous = entry;
entry = entry.next;
}
}",0
207,"@Override
public int hashCode() {
return hash;
}",0
208,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(CollectionUtils.COMMA);
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(CollectionUtils.COMMA);
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
209,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
210,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
211,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
212,"private final Transformer<? super K, ? extends K> keyTransformer;",0
213,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
214,"@Override
public void clear() {
final Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();
final Set<K> currentKeys = keySet();
while (it.hasNext()) {
if (currentKeys.contains(it.next().getKey())) {
it.remove();
}
}
}",0
215,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
216,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
217,"private final Transformer<C, K> keyTransformer;",0
218,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
219,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
220,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
221,"private final Transformer<? super T, ? extends T> iTransformer;",0
222,"private final Transformer<? super T, Boolean> iTransformer;",0
223,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
224,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
225,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
226,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
227,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
228,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
229,"@Override
public int hashCode() {
return hash;
}",0
230,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
231,"public int indexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
232,"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0
233,"@SuppressWarnings(""unchecked"")
public void add(int index, V value) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) AbstractListValuedMap.this.createCollection();
list.add(index, value);
getMap().put((K) key, list);
}
list.add(index, value);
}",0
234,"@Override
public boolean equals(Object other) {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof List)) {
return false;
}
List<?> otherList = (List<?>) other;
if (ListUtils.isEqualList(list, otherList) == false) {
return false;
}
return true;
}",0
235,"public V get(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.get(index);
}",0
236,private transient KeysBag keysBagView;,0
237,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().hashCode();
}
return SetUtils.hashCodeForSet(set);
}",0
238,"private final Transformer<? super K, ? extends K> keyTransformer;",0
239,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
240,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
241,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
242,"private final Transformer<? super I, ? extends O> transformer;",0
243,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
244,"private final Transformer<? super I, ? extends O> iDefault;",0
245,"private final Transformer<? super E, ?> iTransformer;",0
246,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
247,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
248,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
249,"protected List<E> getList() {
return (List<E>) decorated();
}",0
250,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
251,"@Override
public int hashCode() {
return hash;
}",0
252,"V currentValue, nextValue;",0
253,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
254,"@Override
public int hashCode() {
return hash;
}",0
255,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
256,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
257,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
258,"public List<V> subList(int fromIndex, int toIndex) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.subList(fromIndex, toIndex);
}",0
259,"public int indexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
260,"@SuppressWarnings(""unchecked"")
public boolean addAll(int index, Collection<? extends V> c) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) createCollection();
boolean result = list.addAll(index, c);
if (result) {
getMap().put((K) key, list);
}
return result;
}
return list.addAll(index, c);
}",0
261,"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0
262,"@SuppressWarnings(""unchecked"")
public void add(V value) {
if (getMap().get(key) == null) {
List<V> list = (List<V>) createCollection();
getMap().put((K) key, list);
this.values = list;
this.iterator = list.listIterator();
}
this.iterator.add(value);
}",0
263,"public V remove(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
V value = list.remove(index);
if (list.isEmpty()) {
AbstractListValuedMap.this.remove(key);
}
return value;
}",0
264,"@Override
public int hashCode() {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().hashCode();
}
return ListUtils.hashCodeForList(list);
}",0
265,"public V get(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.get(index);
}",0
266,private transient KeysBag keysBagView;,0
267,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
if (SetUtils.isEqualSet(set, otherSet) == false) {
return false;
}
return true;
}",0
268,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
Set<V> valueSet = (Set<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ SetUtils.hashCodeForSet(valueSet);
}
return h;
}",0
269,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
270,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
271,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
272,"@Override
public boolean equals(final Object object) {
if (object == this) {
return true;
}
synchronized (lock) {
return getBag().equals(object);
}
}",0
273,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
274,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
275,"private UnmodifiableBidiMap<V, K> inverse;",0
276,"private final Transformer<C, K> keyTransformer;",0
277,"protected final Transformer<? super E, ? extends E> transformer;",0
278,"private final Transformer<? super I, ? extends O> transformer;",0
279,"private final Transformer<? super I, ? extends O> iDefault;",0
280,"private final Transformer<? super T, Boolean> iTransformer;",0
281,"public E[] getArray() {
return this.array;
}",0
282,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
283,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
284,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
285,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
286,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
287,"V currentValue, nextValue;",0
288,"@Override
public int hashCode() {
return hash;
}",0
289,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
290,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
291,"protected Node<K, V> next;",0
292,"public int indexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
293,"@SuppressWarnings(""unchecked"")
public void add(int index, V value) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) AbstractListValuedMap.this.createCollection();
list.add(index, value);
getMap().put((K) key, list);
}
list.add(index, value);
}",0
294,"public int lastIndexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
295,"public V remove(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
V value = list.remove(index);
if (list.isEmpty()) {
AbstractListValuedMap.this.remove(key);
}
return value;
}",0
296,"@Override
public int hashCode() {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().hashCode();
}
return ListUtils.hashCodeForList(list);
}",0
297,"public V get(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.get(index);
}",0
298,private transient KeysBag keysBagView;,0
299,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().hashCode();
}
return SetUtils.hashCodeForSet(set);
}",0
300,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
Set<V> valueSet = (Set<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ SetUtils.hashCodeForSet(valueSet);
}
return h;
}",0
301,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
302,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
303,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
304,"private UnmodifiableBidiMap<V, K> inverse;",0
305,"protected final Transformer<? super E, ? extends E> transformer;",0
306,private final Comparator<E> comparator;,0
307,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
308,private final Comparator<T> comparator;,0
309,private transient Method iCloneMethod;,0
310,"private final Transformer<? super I, ? extends O> iDefault;",0
311,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
312,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
313,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
314,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
315,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
316,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
317,"V currentValue, nextValue;",0
318,"@Override
public int hashCode() {
return hash;
}",0
319,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
320,protected V value;,0
321,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
322,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
