,source,target
0,"@Deprecated
public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",1
1,"public ModuleExports[] getExportsTable() {
return exports_table;
}",0
2,"@Deprecated
public static final String[] METHODHANDLE_NAMES = { """", ""getField"", ""getStatic"", ""putField"", ""putStatic"", ""invokeVirtual"", ""invokeStatic"", ""invokeSpecial"", ""newInvokeSpecial"", ""invokeInterface"" };",0
3,"@Deprecated
public static final short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",0
4,"@Override
public boolean equals(final Instruction i1, final Instruction i2) {
if (i1.getOpcode() == i2.getOpcode()) {
if (i1 instanceof BranchInstruction) {
return false;
} else if (i1 instanceof ConstantPushInstruction) {
return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());
} else if (i1 instanceof IndexedInstruction) {
return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();
} else if (i1 instanceof NEWARRAY) {
return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
} else {
return true;
}
}
return false;
}",0
5,"public ModuleProvides[] getProvidesTable() {
return provides_table;
}",0
6,"@Deprecated
public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0
7,"@Deprecated
public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",0
8,"public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",1
9,"public ModuleOpens[] getOpensTable() {
return opens_table;
}",0
10,"@Deprecated
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"", ""LocalVariableTypeTable"", ""EnclosingMethod"", ""StackMapTable"", ""BootstrapMethods"", ""MethodParameters"" };",0
11,"@Deprecated
public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",0
12,"@Override
public boolean equals(final Instruction i1, final Instruction i2) {
if (i1.getOpcode() == i2.getOpcode()) {
if (i1 instanceof BranchInstruction) {
return false;
} else if (i1 instanceof ConstantPushInstruction) {
return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());
} else if (i1 instanceof IndexedInstruction) {
return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();
} else if (i1 instanceof NEWARRAY) {
return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
} else {
return true;
}
}
return false;
}",0
13,"public StackMapType[] getTypesOfLocals() {
return types_of_locals;
}",0
14,"@Override
public Object clone() {
OperandStack newstack = new OperandStack(this.maxStack);
@SuppressWarnings(""unchecked"")
final ArrayList<Type> clone = (ArrayList<Type>) this.stack.clone();
newstack.stack = clone;
return newstack;
}",1
15,"// TODO: mutable public array!!
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"", ""LocalVariableTypeTable"", ""EnclosingMethod"", ""StackMapTable"", ""BootstrapMethods"", ""MethodParameters"" };",1
16,"public BootstrapMethod(int bootstrap_method_ref, int num_bootstrap_arguments, int[] bootstrap_arguments) {
this.bootstrap_method_ref = bootstrap_method_ref;
this.bootstrap_arguments = new int[num_bootstrap_arguments];
this.bootstrap_arguments = bootstrap_arguments;
}",1
17,"@Deprecated
public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"", """", """", ""CONSTANT_MethodHandle"", ""CONSTANT_MethodType"", """", ""CONSTANT_InvokeDynamic"" };",1
18,"public Constant[] getConstantPool() {
return constant_pool;
}",0
19,"@Deprecated
public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1
20,"@Deprecated
public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0
21,"public void setConstantPool(final Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0
22,"@Deprecated
public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",1
23,"public final void setBootstrapMethods(final BootstrapMethod[] bootstrap_methods) {
this.bootstrap_methods = bootstrap_methods;
}",0
24,"@Deprecated
public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",1
25,"public final void setAnnotationTable(final AnnotationEntry[] annotation_table) {
this.annotation_table = annotation_table;
}",0
26,"@Deprecated
public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0
27,"@Deprecated
public static final String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",1
28,"public int[] getExceptionIndexTable() {
return exception_index_table;
}",0
29,"public JavaClass parse() throws IOException, ClassFormatException {
ZipFile zip = null;
try {
if (fileOwned) {
if (is_zip) {
zip = new ZipFile(zip_file);
ZipEntry entry = zip.getEntry(file_name);
if (entry == null) {
throw new IOException(""File "" + file_name + "" not found"");
}
dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry), BUFSIZE));
} else {
dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(file_name), BUFSIZE));
}
}
readID();
readVersion();
readConstantPool();
readClassInfo();
readInterfaces();
readFields();
readMethods();
readAttributes();
// System.err.println(""WARNING: "" + u[i]);
// System.err.println(""WARNING: Trailing garbage at end of "" + file_name);
// System.err.println(bytes + "" extra bytes: "" + Utility.toHexString(buf));
} finally {
if (fileOwned) {
try {
if (dataInputStream != null) {
dataInputStream.close();
}
if (zip != null) {
zip.close();
}
} catch (IOException ioe) {
}
}
}
return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor, access_flags, constant_pool, interfaces, fields, methods, attributes, is_zip ? JavaClass.ZIP : JavaClass.FILE);
}",0
30,"public CodeException[] getExceptionTable() {
return exception_table;
}",0
31,"public final LocalVariable[] getLocalVariableTable() {
return local_variable_table;
}",0
32,"public void setInterfaceNames(final String[] interface_names) {
this.interface_names = interface_names;
}",0
33,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0
34,"public void setArgumentTypes(final Type[] arg_types) {
this.arg_types = arg_types;
}",0
35,"public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1
36,"@Deprecated
public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",1
37,"@Override
public VerificationResult do_verify() {
if (!myOwner.doPass3a(method_no).equals(VerificationResult.VR_OK)) {
return VerificationResult.VR_NOTYET;
}
JavaClass jc;
try {
jc = Repository.lookupClass(myOwner.getClassName());
} catch (ClassNotFoundException e) {
// FIXME: maybe not the best way to handle this
throw new AssertionViolatedException(""Missing class: "" + e, e);
}
ConstantPoolGen constantPoolGen = new ConstantPoolGen(jc.getConstantPool());
InstConstraintVisitor icv = new InstConstraintVisitor();
icv.setConstantPoolGen(constantPoolGen);
ExecutionVisitor ev = new ExecutionVisitor();
ev.setConstantPoolGen(constantPoolGen);
Method[] methods = jc.getMethods();
try {
MethodGen mg = new MethodGen(methods[method_no], myOwner.getClassName(), constantPoolGen);
icv.setMethodGen(mg);
if (!(mg.isAbstract() || mg.isNative())) {
ControlFlowGraph cfg = new ControlFlowGraph(mg);
Frame f = new Frame(mg.getMaxLocals(), mg.getMaxStack());
if (!mg.isStatic()) {
if (mg.getName().equals(Constants.CONSTRUCTOR_NAME)) {
Frame.setThis(new UninitializedObjectType(ObjectType.getInstance(jc.getClassName())));
f.getLocals().set(0, Frame._this);
} else {
Frame._this = null;
f.getLocals().set(0, ObjectType.getInstance(jc.getClassName()));
}
}
Type[] argtypes = mg.getArgumentTypes();
int twoslotoffset = 0;
for (int j = 0; j < argtypes.length; j++) {
if (argtypes[j] == Type.SHORT || argtypes[j] == Type.BYTE || argtypes[j] == Type.CHAR || argtypes[j] == Type.BOOLEAN) {
argtypes[j] = Type.INT;
}
f.getLocals().set(twoslotoffset + j + (mg.isStatic() ? 0 : 1), argtypes[j]);
if (argtypes[j].getSize() == 2) {
twoslotoffset++;
f.getLocals().set(twoslotoffset + j + (mg.isStatic() ? 0 : 1), Type.UNKNOWN);
}
}
circulationPump(mg, cfg, cfg.contextOf(mg.getInstructionList().getStart()), f, icv, ev);
}
} catch (VerifierConstraintViolatedException ce) {
ce.extendMessage(""Constraint violated in method '"" + methods[method_no] + ""':\n"", """");
return new VerificationResult(VerificationResult.VERIFIED_REJECTED, ce.getMessage());
} catch (RuntimeException re) {
StringWriter sw = new StringWriter();
PrintWriter pw = new PrintWriter(sw);
re.printStackTrace(pw);
throw new AssertionViolatedException(""Some RuntimeException occured while verify()ing class '"" + jc.getClassName() + ""', method '"" + methods[method_no] + ""'. Original RuntimeException's stack trace:\n---\n"" + sw + ""---\n"", re);
}
return VerificationResult.VR_OK;
}",0
38,"public StackMapType[] getTypesOfStackItems() {
return types_of_stack_items;
}",0
39,"public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {
super(type, cpool);
if (type != ARRAY) {
throw new IllegalArgumentException(""Only element values of type array can be built with this ctor - type specified: "" + type);
}
this.evalues = datums;
}",0
40,"public ParameterAnnotations(final byte parameter_annotation_type, final int name_index, final int length, final ParameterAnnotationEntry[] parameter_annotation_table, final ConstantPool constant_pool) {
super(parameter_annotation_type, name_index, length, constant_pool);
this.parameter_annotation_table = parameter_annotation_table;
}",0
41,"@Deprecated
public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",1
42,"public LocalVariableTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TABLE, name_index, length, constant_pool);
this.local_variable_table = local_variable_table;
}",0
43,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
44,"public LineNumber[] getLineNumberTable() {
return line_number_table;
}",0
45,"@Deprecated
public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0
46,"public BootstrapMethod(final int bootstrap_method_ref, final int[] bootstrap_arguments) {
this.bootstrap_method_ref = bootstrap_method_ref;
this.bootstrap_arguments = bootstrap_arguments;
}",0
47,"public final BootstrapMethod[] getBootstrapMethods() {
return bootstrap_methods;
}",0
48,"public ConstantPool(final Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0
49,"public void setLineNumberTable(final LineNumber[] line_number_table) {
this.line_number_table = line_number_table;
}",0
50,"@Deprecated
public static final String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
51,"synchronized void classNamesJList_valueChanged(ListSelectionEvent e) {
if (e.getValueIsAdjusting()) {
return;
}
current_class = classNamesJList.getSelectedValue().toString();
try {
verify();
} catch (ClassNotFoundException ex) {
// FIXME: report the error using the GUI
ex.printStackTrace();
}
classNamesJList.setSelectedValue(current_class, true);
}",1
52,"public Annotations(final byte annotation_type, final int name_index, final int length, final AnnotationEntry[] annotation_table, final ConstantPool constant_pool, final boolean isRuntimeVisible) {
super(annotation_type, name_index, length, constant_pool);
this.annotation_table = annotation_table;
this.isRuntimeVisible = isRuntimeVisible;
}",0
53,"@Deprecated
public static final int[] CONSUME_STACK = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 3, 4, 3, 4, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 3, 4, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 2, 1, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 4, 2, 4, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 4, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 1, 2, 1, 0, 0, UNPREDICTABLE, 1, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, UNPREDICTABLE, 1, 1, 0, 0, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1
54,"public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",1
55,"public ElementValue[] getElementValuesArray() {
return evalues;
}",0
56,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.local_variable_table = local_variable_table;
}",0
57,"@Deprecated
public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",0
58,"public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",1
59,"@Deprecated
public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",1
60,"public static final String[] METHODHANDLE_NAMES = { """", ""getField"", ""getStatic"", ""putField"", ""putStatic"", ""invokeVirtual"", ""invokeStatic"", ""invokeSpecial"", ""newInvokeSpecial"", ""invokeInterface"" };",1
61,"public final LocalVariable[] getLocalVariableTypeTable() {
return local_variable_type_table;
}",0
62,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.local_variable_type_table = local_variable_table;
}",0
63,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Constants.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Constants.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Constants.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Constants.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Constants.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Constants.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Constants.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Constants.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Constants.CONSTANT_InterfaceMethodref:
case Constants.CONSTANT_Methodref:
case Constants.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Constants.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Constants.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Constants.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
64,"public String[] getInterfaceNames() {
return interface_names;
}",0
65,"public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameter_annotation_table) {
this.parameter_annotation_table = parameter_annotation_table;
}",0
66,"public LocalVariableTypeTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);
this.local_variable_type_table = local_variable_table;
}",0
67,"public int[] getInstructionPositions() {
return byte_positions;
}",0
68,"@Override
public void visitINVOKESPECIAL(INVOKESPECIAL o) {
if (o.getMethodName(cpg).equals(Constants.CONSTRUCTOR_NAME)) {
UninitializedObjectType t = (UninitializedObjectType) stack().peek(o.getArgumentTypes(cpg).length);
if (t == Frame.getThis()) {
Frame._this = null;
}
stack().initializeObject(t);
locals().initializeObject(t);
}
stack().pop();
for (int i = 0; i < o.getArgumentTypes(cpg).length; i++) {
stack().pop();
}
if (o.getReturnType(cpg) != Type.VOID) {
Type t = o.getReturnType(cpg);
if (t.equals(Type.BOOLEAN) || t.equals(Type.CHAR) || t.equals(Type.BYTE) || t.equals(Type.SHORT)) {
t = Type.INT;
}
stack().push(t);
}
}",0
69,"public static final short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",1
70,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0
71,"@Deprecated
public static final String[] METHODHANDLE_NAMES = { """", ""getField"", ""getStatic"", ""putField"", ""putStatic"", ""invokeVirtual"", ""invokeStatic"", ""invokeSpecial"", ""newInvokeSpecial"", ""invokeInterface"" };",1
72,"public InnerClass[] getInnerClasses() {
return inner_classes;
}",0
73,"public void setArgumentNames(final String[] arg_names) {
this.arg_names = arg_names;
}",0
74,"public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
return parameter_annotation_table;
}",0
75,"public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",1
76,"public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool, final boolean verbose) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
System.err.println(""Unreachable default case reached!"");
System.exit(-1);
}
}
}
}
return buf.toString();
}",1
77,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
return parameter_annotation_table;
}",0
78,"@Deprecated
public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0
79,"@Deprecated
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"", ""LocalVariableTypeTable"", ""EnclosingMethod"", ""StackMapTable"", ""BootstrapMethods"", ""MethodParameters"" };",1
80,"public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",1
81,"public void setBootstrapArguments(final int[] bootstrap_arguments) {
this.bootstrap_arguments = bootstrap_arguments;
}",0
82,"@Deprecated
public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"", """", """", ""CONSTANT_MethodHandle"", ""CONSTANT_MethodType"", """", ""CONSTANT_InvokeDynamic"" };",0
83,"public ModuleRequires[] getRequiresTable() {
return requires_table;
}",0
84,"@Deprecated
public static final int[] CONSUME_STACK = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 3, 4, 3, 4, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 3, 4, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 2, 1, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 4, 2, 4, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 4, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 1, 2, 1, 0, 0, UNPREDICTABLE, 1, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, UNPREDICTABLE, 1, 1, 0, 0, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0
85,"@Deprecated
public static final short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",1
86,"public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrap_methods, final ConstantPool constant_pool) {
super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);
this.bootstrap_methods = bootstrap_methods;
}",0
87,"public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table, final ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.line_number_table = line_number_table;
}",0
88,"public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",1
89,"public static final int[] CONSUME_STACK = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 3, 4, 3, 4, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 3, 4, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 2, 1, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 4, 2, 4, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 4, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 1, 2, 1, 0, 0, UNPREDICTABLE, 1, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, UNPREDICTABLE, 1, 1, 0, 0, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1
90,"@Deprecated
public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
91,"@Deprecated
public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",1
92,"public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"", """", """", ""CONSTANT_MethodHandle"", ""CONSTANT_MethodType"", """", ""CONSTANT_InvokeDynamic"" };",1
93,"protected FieldOrMethod(DataInput file, ConstantPool constant_pool) throws IOException, ClassFormatException {
this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null, constant_pool);
int attributes_count = file.readUnsignedShort();
attributes = new Attribute[attributes_count];
for (int i = 0; i < attributes_count; i++) {
attributes[i] = Attribute.readAttribute(file, constant_pool);
}
this.attributes_count = attributes_count;
}",0
94,"public int[] getPackageIndexTable() {
return package_index_table;
}",0
95,"public int[] getBootstrapArguments() {
return bootstrap_arguments;
}",0
96,"public final void setAnnotationTable(AnnotationEntry[] annotation_table) {
this.annotation_table = annotation_table;
}",0
97,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0
98,"public Annotations(byte annotation_type, int name_index, int length, AnnotationEntry[] annotation_table, ConstantPool constant_pool, boolean isRuntimeVisible) {
super(annotation_type, name_index, length, constant_pool);
this.annotation_table = annotation_table;
this.isRuntimeVisible = isRuntimeVisible;
}",0
99,"public ArrayElementValue(int type, ElementValue[] datums, ConstantPool cpool) {
super(type, cpool);
if (type != ARRAY) {
throw new RuntimeException(""Only element values of type array can be built with this ctor - type specified: "" + type);
}
this.evalues = datums;
}",0
100,"public ElementValue[] getElementValuesArray() {
return evalues;
}",0
101,"public static Attribute readAttribute(DataInput file, ConstantPool constant_pool) throws IOException, ClassFormatException {
byte tag = Const.ATTR_UNKNOWN;
int name_index = file.readUnsignedShort();
ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);
String name = c.getBytes();
int length = file.readInt();
for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++) {
if (name.equals(Const.getAttributeName(i))) {
tag = i;
break;
}
}
switch(tag) {
case Const.ATTR_UNKNOWN:
Object r = readers.get(name);
if (r instanceof UnknownAttributeReader) {
return ((UnknownAttributeReader) r).createAttribute(name_index, length, file, constant_pool);
}
return new Unknown(name_index, length, file, constant_pool);
case Const.ATTR_CONSTANT_VALUE:
return new ConstantValue(name_index, length, file, constant_pool);
case Const.ATTR_SOURCE_FILE:
return new SourceFile(name_index, length, file, constant_pool);
case Const.ATTR_CODE:
return new Code(name_index, length, file, constant_pool);
case Const.ATTR_EXCEPTIONS:
return new ExceptionTable(name_index, length, file, constant_pool);
case Const.ATTR_LINE_NUMBER_TABLE:
return new LineNumberTable(name_index, length, file, constant_pool);
case Const.ATTR_LOCAL_VARIABLE_TABLE:
return new LocalVariableTable(name_index, length, file, constant_pool);
case Const.ATTR_INNER_CLASSES:
return new InnerClasses(name_index, length, file, constant_pool);
case Const.ATTR_SYNTHETIC:
return new Synthetic(name_index, length, file, constant_pool);
case Const.ATTR_DEPRECATED:
return new Deprecated(name_index, length, file, constant_pool);
case Const.ATTR_PMG:
return new PMGClass(name_index, length, file, constant_pool);
case Const.ATTR_SIGNATURE:
return new Signature(name_index, length, file, constant_pool);
case Const.ATTR_STACK_MAP:
return new StackMap(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:
return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:
return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:
return new RuntimeVisibleParameterAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:
return new RuntimeInvisibleParameterAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_ANNOTATION_DEFAULT:
return new AnnotationDefault(name_index, length, file, constant_pool);
case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:
return new LocalVariableTypeTable(name_index, length, file, constant_pool);
case Const.ATTR_ENCLOSING_METHOD:
return new EnclosingMethod(name_index, length, file, constant_pool);
case Const.ATTR_STACK_MAP_TABLE:
return new StackMap(name_index, length, file, constant_pool);
case Const.ATTR_BOOTSTRAP_METHODS:
return new BootstrapMethods(name_index, length, file, constant_pool);
case Const.ATTR_METHOD_PARAMETERS:
return new MethodParameters(name_index, length, file, constant_pool);
default:
throw new IllegalStateException(""Unrecognized attribute type tag parsed: "" + tag);
}
}",0
102,"public BootstrapMethod(int bootstrap_method_ref, int[] bootstrap_arguments) {
this.bootstrap_method_ref = bootstrap_method_ref;
this.bootstrap_arguments = bootstrap_arguments;
}",0
103,"public int[] getBootstrapArguments() {
return bootstrap_arguments;
}",0
104,"public void setBootstrapArguments(int[] bootstrap_arguments) {
this.bootstrap_arguments = bootstrap_arguments;
}",0
105,"public final BootstrapMethod[] getBootstrapMethods() {
return bootstrap_methods;
}",0
106,"public final void setBootstrapMethods(BootstrapMethod[] bootstrap_methods) {
this.bootstrap_methods = bootstrap_methods;
}",0
107,"public BootstrapMethods(int name_index, int length, BootstrapMethod[] bootstrap_methods, ConstantPool constant_pool) {
super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);
this.bootstrap_methods = bootstrap_methods;
}",0
108,"public JavaClass parse() throws IOException, ClassFormatException {
ZipFile zip = null;
try {
if (fileOwned) {
if (is_zip) {
zip = new ZipFile(zip_file);
ZipEntry entry = zip.getEntry(file_name);
if (entry == null) {
throw new IOException(""File "" + file_name + "" not found"");
}
dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry), BUFSIZE));
} else {
dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(file_name), BUFSIZE));
}
}
readID();
readVersion();
readConstantPool();
readClassInfo();
readInterfaces();
readFields();
readMethods();
readAttributes();
// System.err.println(""WARNING: "" + u[i]);
// System.err.println(""WARNING: Trailing garbage at end of "" + file_name);
// System.err.println(bytes + "" extra bytes: "" + Utility.toHexString(buf));
} finally {
if (fileOwned) {
try {
if (dataInputStream != null) {
dataInputStream.close();
}
if (zip != null) {
zip.close();
}
} catch (IOException ioe) {
}
}
}
return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor, access_flags, constant_pool, interfaces, fields, methods, attributes, is_zip ? JavaClass.ZIP : JavaClass.FILE);
}",0
109,"public final CodeException[] getExceptionTable() {
return exception_table;
}",0
110,"public final byte[] getCode() {
return code;
}",0
111,"public final Attribute[] getAttributes() {
return attributes;
}",0
112,"public final int getEndPC() {
return end_pc;
}",0
113,"@Override
public Object getConstantValue(ConstantPool cp) {
return new Double(bytes);
}",0
114,"@Override
public Object getConstantValue(ConstantPool cp) {
return new Float(bytes);
}",0
115,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
116,"public Constant[] getConstantPool() {
return constant_pool;
}",0
117,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
118,"public void setConstantPool(Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0
119,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
120,"public ConstantPool(Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0
121,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
122,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
123,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
124,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
125,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
126,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
127,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
128,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
129,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
130,"ConstantUtf8(DataInput file) throws IOException {
super(Const.CONSTANT_Utf8);
bytes = file.readUTF();
created++;
}",0
131,"public ConstantUtf8(String bytes) {
super(Const.CONSTANT_Utf8);
if (bytes == null) {
throw new IllegalArgumentException(""bytes must not be null!"");
}
this.bytes = bytes;
created++;
}",0
132,"public final void setBytes(byte[] bytes) {
this.bytes = bytes;
}",0
133,"public Deprecated(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {
super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);
this.bytes = bytes;
}",0
134,"public final byte[] getBytes() {
return bytes;
}",0
135,"public final int[] getExceptionIndexTable() {
return exception_index_table;
}",0
136,"public AnnotationEntry[] getAnnotationEntries() {
if (annotationEntries == null) {
annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotationEntries;
}",0
137,"public final void setAttributes(Attribute[] attributes) {
this.attributes = attributes;
this.attributes_count = attributes != null ? attributes.length : 0;
}",0
138,"public final Attribute[] getAttributes() {
return attributes;
}",0
139,"public final InnerClass[] getInnerClasses() {
return inner_classes;
}",0
140,"public void setInterfaceNames(String[] interface_names) {
this.interface_names = interface_names;
}",0
141,"public Field[] getFields() {
return fields;
}",0
142,"public void setInterfaces(int[] interfaces) {
this.interfaces = interfaces;
}",0
143,"public Attribute[] getAttributes() {
return attributes;
}",0
144,"public void setAttributes(Attribute[] attributes) {
this.attributes = attributes;
}",0
145,"public AnnotationEntry[] getAnnotationEntries() {
if (annotations == null) {
annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotations;
}",0
146,"public void setMethods(Method[] methods) {
this.methods = methods;
}",0
147,"public String[] getInterfaceNames() {
return interface_names;
}",0
148,"public Method[] getMethods() {
return methods;
}",0
149,"public int[] getInterfaceIndices() {
return interfaces;
}",0
150,"static void Debug(String str) {
if (debug) {
System.out.println(str);
}
}",0
151,"public void setFields(Field[] fields) {
this.fields = fields;
}",0
152,"public final LineNumber[] getLineNumberTable() {
return line_number_table;
}",0
153,"public LineNumberTable(int name_index, int length, LineNumber[] line_number_table, ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.line_number_table = line_number_table;
}",0
154,"public int getSourceLine(int pos) {
int l = 0;
int r = line_number_table.length - 1;
if (r < 0) {
return -1;
}
int min_index = -1;
int min = -1;
do {
int i = (l + r) / 2;
int j = line_number_table[i].getStartPC();
if (j == pos) {
return line_number_table[i].getLineNumber();
} else if (pos < j) {
r = i - 1;
} else {
l = i + 1;
}
if (j < pos && j > min) {
min = j;
min_index = i;
}
} while (l <= r);
if (min_index < 0) {
return -1;
}
return line_number_table[min_index].getLineNumber();
}",0
155,"public final void setLineNumberTable(LineNumber[] line_number_table) {
this.line_number_table = line_number_table;
}",0
156,"public final void setLocalVariableTable(LocalVariable[] local_variable_table) {
this.local_variable_table = local_variable_table;
}",0
157,"public final LocalVariable[] getLocalVariableTable() {
return local_variable_table;
}",0
158,"public LocalVariableTable(int name_index, int length, LocalVariable[] local_variable_table, ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TABLE, name_index, length, constant_pool);
this.local_variable_table = local_variable_table;
}",0
159,"public LocalVariableTypeTable(int name_index, int length, LocalVariable[] local_variable_table, ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);
this.local_variable_type_table = local_variable_table;
}",0
160,"public final void setLocalVariableTable(LocalVariable[] local_variable_table) {
this.local_variable_type_table = local_variable_table;
}",0
161,"public final LocalVariable[] getLocalVariableTypeTable() {
return local_variable_type_table;
}",0
162,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
if (parameterAnnotationEntries == null) {
parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());
}
return parameterAnnotationEntries;
}",0
163,"public MethodParameter[] getParameters() {
return parameters;
}",0
164,"public void setParameters(MethodParameter[] parameters) {
this.parameters = parameters;
}",0
165,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0
166,"public ParameterAnnotations(byte parameter_annotation_type, int name_index, int length, ParameterAnnotationEntry[] parameter_annotation_table, ConstantPool constant_pool) {
super(parameter_annotation_type, name_index, length, constant_pool);
this.parameter_annotation_table = parameter_annotation_table;
}",0
167,"public final void setParameterAnnotationTable(ParameterAnnotationEntry[] parameter_annotation_table) {
this.parameter_annotation_table = parameter_annotation_table;
}",0
168,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
return parameter_annotation_table;
}",0
169,"public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
return parameter_annotation_table;
}",0
170,"final String getData() {
return new String(buf);
}",0
171,"private static void matchIdent(MyByteArrayInputStream in, StringBuilder buf) {
int ch;
if ((ch = in.read()) == -1) {
throw new RuntimeException(""Illegal signature: "" + in.getData() + "" no ident, reaching EOF"");
}
// System.out.println(""return from ident:"" + (char)ch);
if (!identStart(ch)) {
StringBuilder buf2 = new StringBuilder();
int count = 1;
while (Character.isJavaIdentifierPart((char) ch)) {
buf2.append((char) ch);
count++;
ch = in.read();
}
if (ch == ':') {
in.skip(""Ljava/lang/Object"".length());
buf.append(buf2);
ch = in.read();
in.unread();
// System.out.println(""so far:"" + buf2 + "":next:"" +(char)ch);
} else {
for (int i = 0; i < count; i++) {
in.unread();
}
}
return;
}
StringBuilder buf2 = new StringBuilder();
ch = in.read();
do {
buf2.append((char) ch);
ch = in.read();
// System.out.println(""within ident:""+ (char)ch);
} while ((ch != -1) && (Character.isJavaIdentifierPart((char) ch) || (ch == '/')));
buf.append(buf2.toString().replace('/', '.'));
// System.out.println(""regular return ident:""+ (char)ch + "":"" + buf2);
if (ch != -1) {
in.unread();
}
}",0
172,"public StackMap(int name_index, int length, StackMapEntry[] map, ConstantPool constant_pool) {
super(Const.ATTR_STACK_MAP, name_index, length, constant_pool);
this.map = map;
}",0
173,"public final StackMapEntry[] getStackMap() {
return map;
}",0
174,"public final void setStackMap(StackMapEntry[] map) {
this.map = map;
int len = 2;
for (int i = 0; i < map.length; i++) {
len += map[i].getMapEntrySize();
}
setLength(len);
}",0
175,"public StackMapType[] getTypesOfStackItems() {
return types_of_stack_items;
}",0
176,"public StackMapType[] getTypesOfLocals() {
return types_of_locals;
}",0
177,"public final byte[] getBytes() {
return bytes;
}",0
178,"public Synthetic(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {
super(Const.ATTR_SYNTHETIC, name_index, length, constant_pool);
this.bytes = bytes;
}",0
179,"public final void setBytes(byte[] bytes) {
this.bytes = bytes;
}",0
180,"public final void setBytes(byte[] bytes) {
this.bytes = bytes;
}",0
181,"public Unknown(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {
super(Const.ATTR_UNKNOWN, name_index, length, constant_pool);
this.bytes = bytes;
name = ((ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8)).getBytes();
unknown_attributes.put(name, this);
}",0
182,"public final byte[] getBytes() {
return bytes;
}",0
183,"public static String codeToString(ByteSequence bytes, ConstantPool constant_pool, boolean verbose) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
System.err.println(""Unreachable default case reached!"");
System.exit(-1);
}
}
}
}
return buf.toString();
}",0
184,"public static String codeToString(ByteSequence bytes, ConstantPool constant_pool, boolean verbose) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
System.err.println(""Unreachable default case reached!"");
System.exit(-1);
}
}
}
}
return buf.toString();
}",0
185,"static Attribute[] getParameterAnnotationAttributes(ConstantPoolGen cp, List<AnnotationEntryGen>[] vec) {
int[] visCount = new int[vec.length];
int totalVisCount = 0;
int[] invisCount = new int[vec.length];
int totalInvisCount = 0;
try {
for (int i = 0; i < vec.length; i++) {
if (vec[i] != null) {
for (AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
visCount[i]++;
totalVisCount++;
} else {
invisCount[i]++;
totalInvisCount++;
}
}
}
}
ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
rvaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
rvaDos.writeShort(visCount[i]);
if (visCount[i] > 0) {
for (AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
element.dump(rvaDos);
}
}
}
}
rvaDos.close();
ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
DataOutputStream riaDos = new DataOutputStream(riaBytes);
riaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
riaDos.writeShort(invisCount[i]);
if (invisCount[i] > 0) {
for (AnnotationEntryGen element : vec[i]) {
if (!element.isRuntimeVisible()) {
element.dump(riaDos);
}
}
}
}
riaDos.close();
byte[] rvaData = rvaBytes.toByteArray();
byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (totalVisCount > 0) {
rvaIndex = cp.addUtf8(""RuntimeVisibleParameterAnnotations"");
}
if (totalInvisCount > 0) {
riaIndex = cp.addUtf8(""RuntimeInvisibleParameterAnnotations"");
}
List<Attribute> newAttributes = new ArrayList<>();
if (totalVisCount > 0) {
newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (totalInvisCount > 0) {
newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (IOException e) {
System.err.println(""IOException whilst processing parameter annotations"");
e.printStackTrace();
}
return null;
}",0
186,"static Attribute[] getAnnotationAttributes(ConstantPoolGen cp, AnnotationEntryGen[] annotationEntryGens) {
if (annotationEntryGens.length == 0) {
return new Attribute[0];
}
try {
int countVisible = 0;
int countInvisible = 0;
for (AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
countVisible++;
} else {
countInvisible++;
}
}
ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
DataOutputStream riaDos = new DataOutputStream(riaBytes);
rvaDos.writeShort(countVisible);
riaDos.writeShort(countInvisible);
for (AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
a.dump(rvaDos);
} else {
a.dump(riaDos);
}
}
rvaDos.close();
riaDos.close();
byte[] rvaData = rvaBytes.toByteArray();
byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (rvaData.length > 2) {
rvaIndex = cp.addUtf8(""RuntimeVisibleAnnotations"");
}
if (riaData.length > 2) {
riaIndex = cp.addUtf8(""RuntimeInvisibleAnnotations"");
}
List<Attribute> newAttributes = new ArrayList<>();
if (rvaData.length > 2) {
newAttributes.add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (riaData.length > 2) {
newAttributes.add(new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (IOException e) {
System.err.println(""IOException whilst processing annotations"");
e.printStackTrace();
}
return null;
}",0
187,"public ArrayType(Type type, int dimensions) {
super(Const.T_ARRAY, ""<dummy>"");
if ((dimensions < 1) || (dimensions > Const.MAX_BYTE)) {
throw new ClassGenException(""Invalid number of dimensions: "" + dimensions);
}
switch(type.getType()) {
case Const.T_ARRAY:
ArrayType array = (ArrayType) type;
this.dimensions = dimensions + array.dimensions;
basic_type = array.basic_type;
break;
case Const.T_VOID:
throw new ClassGenException(""Invalid type: void[]"");
default:
// Basic type or reference
this.dimensions = dimensions;
basic_type = type;
break;
}
StringBuilder buf = new StringBuilder();
for (int i = 0; i < this.dimensions; i++) {
buf.append('[');
}
buf.append(basic_type.getSignature());
super.setSignature(buf.toString());
}",0
188,"@Override
protected void addHandle() {
super.setNext(bh_list);
bh_list = this;
}",0
189,"static BranchHandle getBranchHandle(BranchInstruction i) {
if (bh_list == null) {
return new BranchHandle(i);
}
BranchHandle bh = bh_list;
bh_list = (BranchHandle) bh.getNext();
bh.setInstruction(i);
return bh;
}",0
190,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
191,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
192,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
193,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
194,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
195,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
196,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
197,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
198,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
199,"@Override
public Number getValue() {
return new Double(value);
}",0
200,"public static ElementValueGen copy(ElementValue value, ConstantPoolGen cpool, boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
201,"public static ElementValueGen copy(ElementValue value, ConstantPoolGen cpool, boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
202,"public static ElementValueGen copy(ElementValue value, ConstantPoolGen cpool, boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
203,"public static ElementValueGen copy(ElementValue value, ConstantPoolGen cpool, boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
204,"public static ElementValueGen copy(ElementValue value, ConstantPoolGen cpool, boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
205,"@Override
public Number getValue() {
return new Float(value);
}",0
206,"public void setInitValue(double d) {
checkType(Type.DOUBLE);
if (d != 0.0) {
value = new Double(d);
}
}",0
207,"public void setInitValue(float f) {
checkType(Type.FLOAT);
if (f != 0.0) {
value = new Float(f);
}
}",0
208,"@Override
public boolean equals(Instruction i1, Instruction i2) {
if (i1.getOpcode() == i2.getOpcode()) {
if (i1 instanceof BranchInstruction) {
return false;
} else if (i1 instanceof ConstantPushInstruction) {
return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());
} else if (i1 instanceof IndexedInstruction) {
return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();
} else if (i1 instanceof NEWARRAY) {
return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
} else {
return true;
}
}
return false;
}",0
209,"public CHECKCAST createCheckCast(ReferenceType t) {
if (t instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) t));
}
return new CHECKCAST(cp.addClass((ObjectType) t));
}",0
210,"public INSTANCEOF createInstanceOf(ReferenceType t) {
if (t instanceof ArrayType) {
return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
}
return new INSTANCEOF(cp.addClass((ObjectType) t));
}",0
211,"public Instruction createCast(Type src_type, Type dest_type) {
if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {
byte dest = dest_type.getType();
byte src = src_type.getType();
if (dest == Const.T_LONG && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
src = Const.T_INT;
}
String name = ""org.apache.commons.bcel6.generic."" + short_names[src - Const.T_CHAR] + ""2"" + short_names[dest - Const.T_CHAR];
Instruction i = null;
try {
i = (Instruction) java.lang.Class.forName(name).newInstance();
} catch (Exception e) {
throw new RuntimeException(""Could not find instruction: "" + name, e);
}
return i;
} else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {
if (dest_type instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));
}
return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
} else {
throw new RuntimeException(""Can not cast "" + src_type + "" to "" + dest_type);
}
}",0
212,"protected void addHandle() {
next = ih_list;
ih_list = this;
}",0
213,"public int[] getInstructionPositions() {
return byte_positions;
}",0
214,"public static InstructionHandle findHandle(InstructionHandle[] ihs, int[] pos, int count, int target) {
int l = 0;
int r = count - 1;
do {
int i = (l + r) / 2;
int j = pos[i];
if (j == target) {
return ihs[i];
} else if (target < j) {
r = i - 1;
} else {
l = i + 1;
}
} while (l <= r);
return null;
}",0
215,"public Object getValue(ConstantPoolGen cpg) {
org.apache.commons.bcel6.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.commons.bcel6.Const.CONSTANT_String:
int i = ((org.apache.commons.bcel6.classfile.ConstantString) c).getStringIndex();
c = cpg.getConstantPool().getConstant(i);
return ((org.apache.commons.bcel6.classfile.ConstantUtf8) c).getBytes();
case org.apache.commons.bcel6.Const.CONSTANT_Float:
return new Float(((org.apache.commons.bcel6.classfile.ConstantFloat) c).getBytes());
case org.apache.commons.bcel6.Const.CONSTANT_Integer:
return Integer.valueOf(((org.apache.commons.bcel6.classfile.ConstantInteger) c).getBytes());
case org.apache.commons.bcel6.Const.CONSTANT_Class:
int nameIndex = ((org.apache.commons.bcel6.classfile.ConstantClass) c).getNameIndex();
c = cpg.getConstantPool().getConstant(nameIndex);
return new ObjectType(((org.apache.commons.bcel6.classfile.ConstantUtf8) c).getBytes());
default:
// Never reached
throw new RuntimeException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0
216,"public Number getValue(ConstantPoolGen cpg) {
org.apache.commons.bcel6.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.commons.bcel6.Const.CONSTANT_Long:
return Long.valueOf(((org.apache.commons.bcel6.classfile.ConstantLong) c).getBytes());
case org.apache.commons.bcel6.Const.CONSTANT_Double:
return new Double(((org.apache.commons.bcel6.classfile.ConstantDouble) c).getBytes());
default:
// Never reached
throw new RuntimeException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0
217,"public void setArgumentTypes(Type[] arg_types) {
this.arg_types = arg_types;
}",0
218,"public void setArgumentNames(String[] arg_names) {
this.arg_names = arg_names;
}",0
219,"public void setArgumentNames(String[] arg_names) {
this.arg_names = arg_names;
}",0
220,"private void sort(int l, int r) {
int i = l;
int j = r;
int h;
int m = match[(l + r) / 2];
InstructionHandle h2;
do {
while (match[i] < m) {
i++;
}
while (m < match[j]) {
j--;
}
if (i <= j) {
h = match[i];
match[i] = match[j];
match[j] = h;
h2 = targets[i];
targets[i] = targets[j];
targets[j] = h2;
i++;
j--;
}
} while (i <= j);
if (l < j) {
sort(l, j);
}
if (i < r) {
sort(i, r);
}
}",0
221,"public InstructionHandle[] getTargets() {
return targets;
}",0
222,"public int[] getMatchs() {
return match;
}",0
223,"public int[] getIndices() {
return indices;
}",0
224,private final InstructionHandle[] targets;,0
225,"public InstructionHandle[] getTargets() {
return targets;
}",0
226,"AttributeHTML(String dir, String class_name, ConstantPool constant_pool, ConstantHTML constant_html) throws IOException {
this.class_name = class_name;
this.constant_pool = constant_pool;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_attributes.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
}",0
227,"@Override
public void visitLocalVariableInstruction(LocalVariableInstruction i) {
short opcode = i.getOpcode();
Type type = i.getType(_cp);
if (opcode == Const.IINC) {
_out.println(""il.append(new IINC("" + i.getIndex() + "", "" + ((IINC) i).getIncrement() + ""));"");
} else {
String kind = (opcode < Const.ISTORE) ? ""Load"" : ""Store"";
_out.println(""il.append(_factory.create"" + kind + ""("" + BCELifier.printType(type) + "", "" + i.getIndex() + ""));"");
}
}",0
228,"private void updateBranchTargets() {
for (BranchInstruction bi : branches) {
BranchHandle bh = (BranchHandle) branch_map.get(bi);
int pos = bh.getPosition();
String name = bi.getName() + ""_"" + pos;
int t_pos = bh.getTarget().getPosition();
_out.println(""    "" + name + "".setTarget(ih_"" + t_pos + "");"");
if (bi instanceof Select) {
InstructionHandle[] ihs = ((Select) bi).getTargets();
for (int j = 0; j < ihs.length; j++) {
t_pos = ihs[j].getPosition();
_out.println(""    "" + name + "".setTarget("" + j + "", ih_"" + t_pos + "");"");
}
}
}
}",0
229,"@Override
public void visitAllocationInstruction(AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new RuntimeException(""Oops: "" + opcode);
}
}",0
230,"@Override
public void visitBranchInstruction(BranchInstruction bi) {
BranchHandle bh = (BranchHandle) branch_map.get(bi);
int pos = bh.getPosition();
String name = bi.getName() + ""_"" + pos;
if (bi instanceof Select) {
Select s = (Select) bi;
branches.add(bi);
StringBuilder args = new StringBuilder(""new int[] { "");
int[] matchs = s.getMatchs();
for (int i = 0; i < matchs.length; i++) {
args.append(matchs[i]);
if (i < matchs.length - 1) {
args.append("", "");
}
}
args.append("" }"");
_out.print(""Select "" + name + "" = new "" + bi.getName().toUpperCase(Locale.ENGLISH) + ""("" + args + "", new InstructionHandle[] { "");
for (int i = 0; i < matchs.length; i++) {
_out.print(""null"");
if (i < matchs.length - 1) {
_out.print("", "");
}
}
_out.println("" }, null);"");
} else {
int t_pos = bh.getTarget().getPosition();
String target;
if (pos > t_pos) {
target = ""ih_"" + t_pos;
} else {
branches.add(bi);
target = ""null"";
}
_out.println(""    BranchInstruction "" + name + "" = _factory.createBranchInstruction("" + ""Constants."" + bi.getName().toUpperCase(Locale.ENGLISH) + "", "" + target + "");"");
}
if (bh.hasTargeters()) {
_out.println(""    ih_"" + pos + "" = il.append("" + name + "");"");
} else {
_out.println(""    il.append("" + name + "");"");
}
}",0
231,"@Override
public void visitAllocationInstruction(AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new RuntimeException(""Oops: "" + opcode);
}
}",0
232,"public BCELifier(JavaClass clazz, OutputStream out) {
_clazz = clazz;
_out = new PrintWriter(out);
_cp = new ConstantPoolGen(_clazz.getConstantPool());
}",0
233,"public static String printFlags(int flags, FLAGS location) {
if (flags == 0) {
return ""0"";
}
StringBuilder buf = new StringBuilder();
for (int i = 0, pow = 1; pow <= Const.MAX_ACC_FLAG; i++) {
if ((flags & pow) != 0) {
if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {
buf.append(""ACC_SUPER | "");
} else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {
buf.append(""ACC_BRIDGE | "");
} else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {
buf.append(""ACC_VARARGS | "");
} else {
if (i < Const.ACCESS_NAMES_LENGTH) {
buf.append(""ACC_"").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append("" | "");
} else {
buf.append(String.format(""ACC_BIT %x | "", pow));
}
}
}
pow <<= 1;
}
String str = buf.toString();
return str.substring(0, str.length() - 3);
}",0
234,"public Class2HTML(JavaClass java_class, String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
235,"public Class2HTML(JavaClass java_class, String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
236,"public Class2HTML(JavaClass java_class, String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
237,"private void writeMainHTML(AttributeHTML attribute_html) throws IOException {
PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + "".html""));
Attribute[] attributes = java_class.getAttributes();
file.println(""<HTML>\n"" + ""<HEAD><TITLE>Documentation for "" + class_name + ""</TITLE>"" + ""</HEAD>\n"" + ""<FRAMESET BORDER=1 cols=\""30%,*\"">\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""ConstantPool\"" SRC=\"""" + class_name + ""_cp.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Attributes\"" SRC=\"""" + class_name + ""_attributes.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET>\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""Code\"" SRC=\"""" + class_name + ""_code.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Methods\"" SRC=\"""" + class_name + ""_methods.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET></FRAMESET></HTML>"");
file.close();
for (int i = 0; i < attributes.length; i++) {
attribute_html.writeAttribute(attributes[i], ""class"" + i);
}
}",0
238,"public InputStream getInputStream(String name, String suffix) throws IOException {
InputStream is = null;
try {
is = getClass().getClassLoader().getResourceAsStream(name + suffix);
} catch (Exception e) {
}
if (is != null) {
return is;
}
return getClassFile(name, suffix).getInputStream();
}",0
239,"CodeHTML(String dir, String class_name, Method[] methods, ConstantPool constant_pool, ConstantHTML constant_html) throws IOException {
this.class_name = class_name;
this.constant_pool = constant_pool;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_code.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\"">"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</BODY></HTML>"");
file.close();
}",0
240,"private String codeToHTML(ByteSequence bytes, int method_number) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constant_pool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
String field_name = constant_pool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(class_name)) {
buf.append(""<A HREF=\"""").append(class_name).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constant_html.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(index, Const.CONSTANT_NameAndType)));
ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constant_pool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
String[] args = Utility.methodSignatureArgumentTypes(signature, false);
String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
int dimensions = bytes.readByte();
buf.append(constant_html.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0
241,"private String codeToHTML(ByteSequence bytes, int method_number) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constant_pool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
String field_name = constant_pool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(class_name)) {
buf.append(""<A HREF=\"""").append(class_name).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constant_html.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(index, Const.CONSTANT_NameAndType)));
ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constant_pool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
String[] args = Utility.methodSignatureArgumentTypes(signature, false);
String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
int dimensions = bytes.readByte();
buf.append(constant_html.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0
242,"ConstantHTML(String dir, String class_name, String class_package, Method[] methods, ConstantPool constant_pool) throws IOException {
this.class_name = class_name;
this.class_package = class_package;
this.constant_pool = constant_pool;
this.methods = methods;
constants = constant_pool.getConstantPool();
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
constant_ref = new String[constants.length];
constant_ref[0] = ""&lt;unknown&gt;"";
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
for (int i = 1; i < constants.length; i++) {
if (i % 2 == 0) {
file.print(""<TR BGCOLOR=\""#C0C0C0\""><TD>"");
} else {
file.print(""<TR BGCOLOR=\""#A0A0A0\""><TD>"");
}
if (constants[i] != null) {
writeConstant(i);
}
file.print(""</TD></TR>\n"");
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0
243,"MethodHTML(String dir, String class_name, Method[] methods, Field[] fields, ConstantHTML constant_html, AttributeHTML attribute_html) throws IOException {
this.class_name = class_name;
this.attribute_html = attribute_html;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_methods.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
file.println(""<TR><TH ALIGN=LEFT>Access&nbsp;flags</TH><TH ALIGN=LEFT>Type</TH>"" + ""<TH ALIGN=LEFT>Field&nbsp;name</TH></TR>"");
for (Field field : fields) {
writeField(field);
}
file.println(""</TABLE>"");
file.println(""<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags</TH>"" + ""<TH ALIGN=LEFT>Return&nbsp;type</TH><TH ALIGN=LEFT>Method&nbsp;name</TH>"" + ""<TH ALIGN=LEFT>Arguments</TH></TR>"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0
244,"public static void main(String[] args) {
try {
UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
} catch (Exception e) {
e.printStackTrace();
}
new GraphicalVerifier();
}",0
245,"@Override
public void update(String classname) {
System.gc();
for (int i = 0; i < indent; i++) {
System.out.print("" "");
}
System.out.println(classname);
indent += 1;
Verifier v = VerifierFactory.getVerifier(classname);
VerificationResult vr;
vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 1:\n"" + vr);
}
vr = v.doPass2();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 2:\n"" + vr);
}
if (vr == VerificationResult.VR_OK) {
try {
JavaClass jc = Repository.lookupClass(v.getClassName());
for (int i = 0; i < jc.getMethods().length; i++) {
vr = v.doPass3a(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3a, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
vr = v.doPass3b(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3b, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
}
} catch (ClassNotFoundException e) {
System.err.println(""Could not find class "" + v.getClassName() + "" in Repository"");
}
}
indent -= 1;
}",0
246,"private void jbInit() throws Exception {
contentPane = (JPanel) this.getContentPane();
contentPane.setLayout(cardLayout1);
this.setJMenuBar(jMenuBar1);
this.setSize(new Dimension(708, 451));
this.setTitle(""JustIce"");
jPanel1.setMinimumSize(new Dimension(100, 100));
jPanel1.setPreferredSize(new Dimension(100, 100));
jPanel1.setLayout(gridLayout1);
jSplitPane2.setOrientation(JSplitPane.VERTICAL_SPLIT);
jPanel2.setLayout(gridLayout2);
jPanel3.setMinimumSize(new Dimension(200, 100));
jPanel3.setPreferredSize(new Dimension(400, 400));
jPanel3.setLayout(gridLayout4);
messagesPanel.setMinimumSize(new Dimension(100, 100));
messagesPanel.setLayout(gridLayout3);
jPanel2.setMinimumSize(new Dimension(200, 100));
jMenu1.setText(""File"");
jScrollPane1.getViewport().setBackground(Color.red);
messagesScrollPane.getViewport().setBackground(Color.red);
messagesScrollPane.setPreferredSize(new Dimension(10, 10));
classNamesJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
@Override
public void valueChanged(ListSelectionEvent e) {
classNamesJList_valueChanged(e);
}
});
classNamesJList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
jScrollPane3.setBorder(BorderFactory.createLineBorder(Color.black));
jScrollPane3.setPreferredSize(new Dimension(100, 100));
gridLayout4.setRows(4);
gridLayout4.setColumns(1);
gridLayout4.setHgap(1);
jScrollPane4.setBorder(BorderFactory.createLineBorder(Color.black));
jScrollPane4.setPreferredSize(new Dimension(100, 100));
pass1TextPane.setBorder(BorderFactory.createRaisedBevelBorder());
pass1TextPane.setToolTipText("""");
pass1TextPane.setEditable(false);
pass2TextPane.setBorder(BorderFactory.createRaisedBevelBorder());
pass2TextPane.setEditable(false);
messagesTextPane.setBorder(BorderFactory.createRaisedBevelBorder());
messagesTextPane.setEditable(false);
newFileMenuItem.setText(""New..."");
newFileMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(78, InputEvent.CTRL_MASK, true));
newFileMenuItem.addActionListener(new java.awt.event.ActionListener() {
@Override
public void actionPerformed(ActionEvent e) {
newFileMenuItem_actionPerformed(e);
}
});
pass3aTextPane.setEditable(false);
pass3bTextPane.setEditable(false);
pass3aJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
@Override
public void valueChanged(ListSelectionEvent e) {
pass3aJList_valueChanged(e);
}
});
pass3bJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
@Override
public void valueChanged(ListSelectionEvent e) {
pass3bJList_valueChanged(e);
}
});
jMenu2.setText(""Help"");
whatisMenuItem.setText(""What is..."");
whatisMenuItem.addActionListener(new java.awt.event.ActionListener() {
@Override
public void actionPerformed(ActionEvent e) {
whatisMenuItem_actionPerformed(e);
}
});
aboutMenuItem.setText(""About"");
aboutMenuItem.addActionListener(new java.awt.event.ActionListener() {
@Override
public void actionPerformed(ActionEvent e) {
aboutMenuItem_actionPerformed(e);
}
});
jSplitPane2.add(messagesPanel, JSplitPane.BOTTOM);
messagesPanel.add(messagesScrollPane, null);
messagesScrollPane.getViewport().add(messagesTextPane, null);
jSplitPane2.add(jPanel3, JSplitPane.TOP);
jPanel3.add(jScrollPane3, null);
jScrollPane3.getViewport().add(pass1TextPane, null);
jPanel3.add(jScrollPane4, null);
jPanel3.add(jSplitPane3, null);
jSplitPane3.add(jScrollPane2, JSplitPane.LEFT);
jScrollPane2.getViewport().add(pass3aJList, null);
jSplitPane3.add(jScrollPane5, JSplitPane.RIGHT);
jScrollPane5.getViewport().add(pass3aTextPane, null);
jPanel3.add(jSplitPane4, null);
jSplitPane4.add(jScrollPane6, JSplitPane.LEFT);
jScrollPane6.getViewport().add(pass3bJList, null);
jSplitPane4.add(jScrollPane7, JSplitPane.RIGHT);
jScrollPane7.getViewport().add(pass3bTextPane, null);
jScrollPane4.getViewport().add(pass2TextPane, null);
jSplitPane1.add(jPanel2, JSplitPane.TOP);
jPanel2.add(jScrollPane1, null);
jSplitPane1.add(jPanel1, JSplitPane.BOTTOM);
jPanel1.add(jSplitPane2, null);
jScrollPane1.getViewport().add(classNamesJList, null);
jMenuBar1.add(jMenu1);
jMenuBar1.add(jMenu2);
contentPane.add(jSplitPane1, ""jSplitPane1"");
jMenu1.add(newFileMenuItem);
jMenu2.add(whatisMenuItem);
jMenu2.add(aboutMenuItem);
jSplitPane2.setDividerLocation(300);
jSplitPane3.setDividerLocation(150);
jSplitPane4.setDividerLocation(150);
}",0
247,private final IvjEventHandler ivjEventHandler = new IvjEventHandler();,0
248,"@Override
public void visitMethod(Method obj) {
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
String name = obj.getName();
if (!validMethodName(name, true)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
Type t;
Type[] ts;
try {
t = Type.getReturnType(sig);
ts = Type.getArgumentTypes(sig);
} catch (ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by Method '"" + tostring(obj) + ""'."", cfe);
}
Type act = t;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has a return type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
for (Type element : ts) {
act = element;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has an argument type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
}
if (name.equals(Const.STATIC_INITIALIZER_NAME) && (ts.length != 0)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."" + "" Its name resembles the class or interface initialization method"" + "" which it isn't because of its arguments (==descriptor)."");
}
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isAbstract()) {
if (obj.isFinal()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_FINAL modifier set."");
}
if (obj.isNative()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_NATIVE modifier set."");
}
if (obj.isPrivate()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_PRIVATE modifier set."");
}
if (obj.isStatic()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STATIC modifier set."");
}
if (obj.isStrictfp()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STRICT modifier set."");
}
if (obj.isSynchronized()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_SYNCHRONIZED modifier set."");
}
}
if (name.equals(Const.CONSTRUCTOR_NAME)) {
// ..may have at most one of ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC set: is checked above.
if (obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isAbstract()) {
throw new ClassConstraintException(""Instance initialization method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set."");
}
}
} else {
if (!name.equals(Const.STATIC_INITIALIZER_NAME)) {
if (jc.getMajor() >= Const.MAJOR_1_8) {
if (!(obj.isPublic() ^ obj.isPrivate())) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have"" + "" exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set."");
}
if (obj.isProtected() || obj.isFinal() || obj.isSynchronized() || obj.isNative()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isAbstract()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_ABSTRACT modifier set but hasn't!"");
}
if (obj.isPrivate() || obj.isProtected() || obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isStrictfp()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED,"" + "" ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set."");
}
}
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_SYNCHRONIZED | Const.ACC_NATIVE | Const.ACC_ABSTRACT | Const.ACC_STRICT)) > 0) {
addMessage(""Method '"" + tostring(obj) + ""' has access flag(s) other than"" + "" ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,"" + "" ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored)."");
}
String nameanddesc = name + sig;
if (method_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two methods (like '"" + tostring(obj) + ""') are allowed have same names and desciptors!"");
}
method_names_and_desc.add(nameanddesc);
Attribute[] atts = obj.getAttributes();
int num_code_atts = 0;
for (Attribute att : atts) {
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is neither Code nor Exceptions and is therefore only of use for debuggers and such."");
}
if ((att instanceof Code) && (obj.isNative() || obj.isAbstract())) {
throw new ClassConstraintException(""Native or abstract methods like '"" + tostring(obj) + ""' must not have a Code attribute like '"" + tostring(att) + ""'."");
}
if (att instanceof Code) {
num_code_atts++;
}
}
if (!obj.isNative() && !obj.isAbstract() && num_code_atts != 1) {
throw new ClassConstraintException(""Non-native, non-abstract methods like '"" + tostring(obj) + ""' must have exactly one Code attribute (found: "" + num_code_atts + "")."");
}
}",0
249,"@Override
public void visitField(Field obj) {
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isFinal() && obj.isVolatile()) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isStatic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_STATIC modifier set but hasn't!"");
}
if (!obj.isFinal()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_FINAL modifier set but hasn't!"");
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_VOLATILE | Const.ACC_TRANSIENT)) > 0) {
addMessage(""Field '"" + tostring(obj) + ""' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED,"" + "" ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored)."");
}
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
String name = obj.getName();
if (!validFieldName(name)) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' has illegal name '"" + obj.getName() + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
try {
Type.getType(sig);
} catch (ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by '"" + tostring(obj) + ""'."", cfe);
}
String nameanddesc = name + sig;
if (field_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two fields (like '"" + tostring(obj) + ""') are allowed have same names and descriptors!"");
}
if (field_names.contains(name)) {
addMessage(""More than one field of name '"" + name + ""' detected (but with different type descriptors). This is very unusual."");
}
field_names_and_desc.add(nameanddesc);
field_names.add(name);
Attribute[] atts = obj.getAttributes();
for (Attribute att : atts) {
if ((!(att instanceof ConstantValue)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if (!(att instanceof ConstantValue)) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is not a ConstantValue and is therefore only of use for debuggers and such."");
}
}
}",0
250,"public LocalVariablesInfo getLocalVariablesInfo(int method_nr) {
if (this.verify() != VerificationResult.VR_OK) {
return null;
}
if (method_nr < 0 || method_nr >= localVariablesInfos.length) {
throw new AssertionViolatedException(""Method number out of range."");
}
return localVariablesInfos[method_nr];
}",0
251,"@Deprecated
protected static UninitializedObjectType _this;",0
252,"@Override
public void visitINVOKEINTERFACE(INVOKEINTERFACE o) {
int count = o.getCount();
if (count == 0) {
constraintViolated(o, ""The 'count' argument must not be 0."");
}
// TODO: Do we want to do anything with it?
Type t = o.getType(cpg);
if (t instanceof ObjectType) {
String name = ((ObjectType) t).getClassName();
Verifier v = VerifierFactory.getVerifier(name);
VerificationResult vr = v.doPass2();
if (vr.getStatus() != VerificationResult.VERIFIED_OK) {
constraintViolated(o, ""Class '"" + name + ""' is referenced, but cannot be loaded and resolved: '"" + vr + ""'."");
}
}
Type[] argtypes = o.getArgumentTypes(cpg);
int nargs = argtypes.length;
for (int i = nargs - 1; i >= 0; i--) {
Type fromStack = stack().peek((nargs - 1) - i);
Type fromDesc = argtypes[i];
if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {
fromDesc = Type.INT;
}
if (!fromStack.equals(fromDesc)) {
if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {
ReferenceType rFromStack = (ReferenceType) fromStack;
// TODO: This can only be checked when using Staerk-et-al's ""set of object types""
referenceTypeIsInitialized(o, rFromStack);
} else {
constraintViolated(o, ""Expecting a '"" + fromDesc + ""' but found a '"" + fromStack + ""' on the stack."");
}
}
}
Type objref = stack().peek(nargs);
if (objref == Type.NULL) {
return;
}
if (!(objref instanceof ReferenceType)) {
constraintViolated(o, ""Expecting a reference type as 'objectref' on the stack, not a '"" + objref + ""'."");
}
referenceTypeIsInitialized(o, (ReferenceType) objref);
if (!(objref instanceof ObjectType)) {
if (!(objref instanceof ArrayType)) {
constraintViolated(o, ""Expecting an ObjectType as 'objectref' on the stack, not a '"" + objref + ""'."");
} else {
objref = GENERIC_ARRAY;
}
}
// TODO: This can only be checked if we're using Staerk-et-al's ""set of object types""
int counted_count = 1;
for (int i = 0; i < nargs; i++) {
counted_count += argtypes[i].getSize();
}
if (count != counted_count) {
constraintViolated(o, ""The 'count' argument should probably read '"" + counted_count + ""' but is '"" + count + ""'."");
}
}",0
253,"@Override
public void visitGETFIELD(GETFIELD o) {
try {
Type objectref = stack().peek();
if (!((objectref instanceof ObjectType) || (objectref == Type.NULL))) {
constraintViolated(o, ""Stack top should be an object reference that's not an array reference, but is '"" + objectref + ""'."");
}
String field_name = o.getFieldName(cpg);
JavaClass jc = Repository.lookupClass(getObjectType(o).getClassName());
Field[] fields = jc.getFields();
Field f = null;
for (Field field : fields) {
if (field.getName().equals(field_name)) {
Type f_type = Type.getType(field.getSignature());
Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
break;
}
}
}
if (f == null) {
JavaClass[] superclasses = jc.getSuperClasses();
outer: for (JavaClass superclass : superclasses) {
fields = superclass.getFields();
for (Field field : fields) {
if (field.getName().equals(field_name)) {
Type f_type = Type.getType(field.getSignature());
Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
if ((f.getAccessFlags() & (Const.ACC_PUBLIC | Const.ACC_PROTECTED)) == 0) {
f = null;
}
break outer;
}
}
}
}
if (f == null) {
throw new AssertionViolatedException(""Field '"" + field_name + ""' not found in "" + jc.getClassName());
}
}
if (f.isProtected()) {
ObjectType classtype = getObjectType(o);
ObjectType curr = ObjectType.getInstance(mg.getClassName());
if (classtype.equals(curr) || curr.subclassOf(classtype)) {
Type t = stack().peek();
if (t == Type.NULL) {
return;
}
if (!(t instanceof ObjectType)) {
constraintViolated(o, ""The 'objectref' must refer to an object that's not an array. Found instead: '"" + t + ""'."");
}
ObjectType objreftype = (ObjectType) t;
if (!(objreftype.equals(curr) || objreftype.subclassOf(curr))) {
// TODO: One day move to Staerk-et-al's ""Set of object types"" instead of ""wider"" object types
}
}
}
// TODO: Could go into Pass 3a.
if (f.isStatic()) {
constraintViolated(o, ""Referenced field '"" + f + ""' is static which it shouldn't be."");
}
} catch (ClassNotFoundException e) {
// FIXME: maybe not the best way to handle this
throw new AssertionViolatedException(""Missing class: "" + e, e);
}
}",0
254,"@Override
public Object clone() {
LocalVariables lvs = new LocalVariables(locals.length);
for (int i = 0; i < locals.length; i++) {
lvs.locals[i] = this.locals[i];
}
return lvs;
}",0
255,"String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"" };",0
256,"String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0
257,"String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",0
258,"String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
259,"short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",0
260,"int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0
261,"String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0
262,"// TODO: mutable public array!!
String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"" };",0
263,"String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
264,"short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",0
265,"String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0
266,"String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",0
267,"int[] CONSUME_STACK = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 3, 4, 3, 4, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 3, 4, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 2, 1, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 4, 2, 4, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 4, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 1, 2, 1, 0, 0, UNPREDICTABLE, 1, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, UNPREDICTABLE, 1, 1, 0, 0, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0
268,"@Deprecated
Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = { NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR };",0
269,"@Deprecated
Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = { NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR, EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR };",0
270,"@Deprecated
Class<?>[] EXCS_ARRAY_EXCEPTION = { NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION };",0
271,"public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {
this.annotationTable = annotationTable;
}",0
272,"public AnnotationEntry[] getAnnotationEntries() {
return annotationTable;
}",0
273,"public Annotations(final byte annotationType, final int nameIndex, final int length, final AnnotationEntry[] annotationTable, final ConstantPool constantPool, final boolean isRuntimeVisible) {
super(annotationType, nameIndex, length, constantPool);
this.annotationTable = annotationTable;
this.isRuntimeVisible = isRuntimeVisible;
}",0
274,"public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {
super(type, cpool);
if (type != ARRAY) {
throw new IllegalArgumentException(""Only element values of type array can be built with this ctor - type specified: "" + type);
}
this.elementValues = datums;
}",0
275,"public ElementValue[] getElementValuesArray() {
return elementValues;
}",0
276,"public BootstrapMethod(final int bootstrapMethodRef, final int[] bootstrapArguments) {
this.bootstrapMethodRef = bootstrapMethodRef;
this.bootstrapArguments = bootstrapArguments;
}",0
277,"public int[] getBootstrapArguments() {
return bootstrapArguments;
}",0
278,"public void setBootstrapArguments(final int[] bootstrapArguments) {
this.bootstrapArguments = bootstrapArguments;
}",0
279,"public final void setBootstrapMethods(final BootstrapMethod[] bootstrapMethods) {
this.bootstrapMethods = bootstrapMethods;
}",0
280,"public final BootstrapMethod[] getBootstrapMethods() {
return bootstrapMethods;
}",0
281,"public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrapMethods, final ConstantPool constant_pool) {
super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);
this.bootstrapMethods = bootstrapMethods;
}",0
282,"public CodeException[] getExceptionTable() {
return exceptionTable;
}",0
283,"public Attribute[] getAttributes() {
return attributes;
}",0
284,"public byte[] getCode() {
return code;
}",0
285,"public int getEndPC() {
return endPc;
}",0
286,"@Override
public Object getConstantValue(final ConstantPool cp) {
return new Double(bytes);
}",0
287,"@Override
public Object getConstantValue(final ConstantPool cp) {
return new Float(bytes);
}",0
288,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
289,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
290,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
291,"public Constant[] getConstantPool() {
return constantPool;
}",0
292,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
293,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
294,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
295,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
296,"public void setConstantPool(final Constant[] constantPool) {
this.constantPool = constantPool;
}",0
297,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
298,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
299,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
300,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
301,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
302,"public ConstantPool(final Constant[] constantPool) {
this.constantPool = constantPool;
}",0
303,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
304,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0
305,"public ConstantUtf8(final String value) {
super(Const.CONSTANT_Utf8);
if (value == null) {
throw new IllegalArgumentException(""Value must not be null."");
}
this.value = value;
created++;
}",0
306,"ConstantUtf8(final DataInput dataInput) throws IOException {
super(Const.CONSTANT_Utf8);
value = dataInput.readUTF();
created++;
}",0
307,"public void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0
308,"public Deprecated(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);
this.bytes = bytes;
}",0
309,"public byte[] getBytes() {
return bytes;
}",0
310,"public int[] getExceptionIndexTable() {
return exceptionIndexTable;
}",0
311,"public AnnotationEntry[] getAnnotationEntries() {
if (annotationEntries == null) {
annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotationEntries;
}",0
312,"public final Attribute[] getAttributes() {
return attributes;
}",0
313,"public final void setAttributes(final Attribute[] attributes) {
this.attributes = attributes;
this.attributes_count = attributes != null ? attributes.length : 0;
}",0
314,"public InnerClass[] getInnerClasses() {
return innerClasses;
}",0
315,"public AnnotationEntry[] getAnnotationEntries() {
if (annotations == null) {
annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotations;
}",0
316,"public Field[] getFields() {
return fields;
}",0
317,"public Method[] getMethods() {
return methods;
}",0
318,"public void setAttributes(final Attribute[] attributes) {
this.attributes = attributes;
}",0
319,"public int[] getInterfaceIndices() {
return interfaces;
}",0
320,"public Attribute[] getAttributes() {
return attributes;
}",0
321,"public void setInterfaceNames(final String[] interfaceNames) {
this.interfaceNames = interfaceNames;
}",0
322,"public void setFields(final Field[] fields) {
this.fields = fields;
}",0
323,"static void Debug(final String str) {
if (debug) {
System.out.println(str);
}
}",0
324,"public void setMethods(final Method[] methods) {
this.methods = methods;
}",0
325,"public String[] getInterfaceNames() {
return interfaceNames;
}",0
326,"public void setInterfaces(final int[] interfaces) {
this.interfaces = interfaces;
}",0
327,"public void setLineNumberTable(final LineNumber[] lineNumberTable) {
this.lineNumberTable = lineNumberTable;
}",0
328,"public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table, final ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.lineNumberTable = line_number_table;
}",0
329,"public LineNumber[] getLineNumberTable() {
return lineNumberTable;
}",0
330,"public final LocalVariable[] getLocalVariableTable() {
return localVariableTable;
}",0
331,"public LocalVariableTable(final int nameIndex, final int length, final LocalVariable[] localVariableTable, final ConstantPool constantPool) {
super(Const.ATTR_LOCAL_VARIABLE_TABLE, nameIndex, length, constantPool);
this.localVariableTable = localVariableTable;
}",0
332,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.localVariableTable = local_variable_table;
}",0
333,"public final LocalVariable[] getLocalVariableTypeTable() {
return localVariableTypeTable;
}",0
334,"public LocalVariableTypeTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);
this.localVariableTypeTable = local_variable_table;
}",0
335,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.localVariableTypeTable = local_variable_table;
}",0
336,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
if (parameterAnnotationEntries == null) {
parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());
}
return parameterAnnotationEntries;
}",0
337,"public MethodParameter[] getParameters() {
return parameters;
}",0
338,"public void setParameters(final MethodParameter[] parameters) {
this.parameters = parameters;
}",0
339,"public ModuleExports[] getExportsTable() {
return exportsTable;
}",0
340,"public ModuleOpens[] getOpensTable() {
return opensTable;
}",0
341,"public ModuleRequires[] getRequiresTable() {
return requiresTable;
}",0
342,"public ModuleProvides[] getProvidesTable() {
return providesTable;
}",0
343,"public int[] getPackageIndexTable() {
return packageIndexTable;
}",0
344,"public int[] getClasses() {
return classes;
}",0
345,"public AnnotationEntry[] getAnnotationEntries() {
return annotationTable;
}",0
346,"public ParameterAnnotations(final byte parameterAnnotationType, final int nameIndex, final int length, final ParameterAnnotationEntry[] parameterAnnotationTable, final ConstantPool constantPool) {
super(parameterAnnotationType, nameIndex, length, constantPool);
this.parameterAnnotationTable = parameterAnnotationTable;
}",0
347,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
return parameterAnnotationTable;
}",0
348,"public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
return parameterAnnotationTable;
}",0
349,"public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameterAnnotationTable) {
this.parameterAnnotationTable = parameterAnnotationTable;
}",0
350,"private static void matchIdent(final MyByteArrayInputStream in, final StringBuilder buf) {
int ch;
if ((ch = in.read()) == -1) {
throw new IllegalArgumentException(""Illegal signature: "" + in.getData() + "" no ident, reaching EOF"");
}
// System.out.println(""return from ident:"" + (char)ch);
if (!identStart(ch)) {
final StringBuilder buf2 = new StringBuilder();
int count = 1;
while (Character.isJavaIdentifierPart((char) ch)) {
buf2.append((char) ch);
count++;
ch = in.read();
}
if (ch == ':') {
in.skip(""Ljava/lang/Object"".length());
buf.append(buf2);
ch = in.read();
in.unread();
// System.out.println(""so far:"" + buf2 + "":next:"" +(char)ch);
} else {
for (int i = 0; i < count; i++) {
in.unread();
}
}
return;
}
final StringBuilder buf2 = new StringBuilder();
ch = in.read();
do {
buf2.append((char) ch);
ch = in.read();
// System.out.println(""within ident:""+ (char)ch);
} while ((ch != -1) && (Character.isJavaIdentifierPart((char) ch) || (ch == '/')));
buf.append(buf2.toString().replace('/', '.'));
// System.out.println(""regular return ident:""+ (char)ch + "":"" + buf2);
if (ch != -1) {
in.unread();
}
}",0
351,"String getData() {
return new String(buf);
}",0
352,"public StackMapEntry[] getStackMap() {
return map;
}",0
353,"public void setStackMap(final StackMapEntry[] map) {
this.map = map;
int len = 2;
for (final StackMapEntry element : map) {
len += element.getMapEntrySize();
}
setLength(len);
}",0
354,"public StackMap(final int name_index, final int length, final StackMapEntry[] map, final ConstantPool constant_pool) {
super(Const.ATTR_STACK_MAP, name_index, length, constant_pool);
this.map = map;
}",0
355,"public StackMapType[] getTypesOfStackItems() {
return typesOfStackItems;
}",0
356,"public StackMapType[] getTypesOfLocals() {
return typesOfLocals;
}",0
357,"public Synthetic(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_SYNTHETIC, name_index, length, constant_pool);
this.bytes = bytes;
}",0
358,"public void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0
359,"public byte[] getBytes() {
return bytes;
}",0
360,"public void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0
361,"public Unknown(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_UNKNOWN, name_index, length, constant_pool);
this.bytes = bytes;
name = ((ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8)).getBytes();
unknownAttributes.put(name, this);
}",0
362,"public byte[] getBytes() {
return bytes;
}",0
363,"public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool, final boolean verbose) throws IOException {
final short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
final StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
final int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
final Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
final int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
final int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached!"");
}
}
}
}
return buf.toString();
}",0
364,"public static String signatureToString(final String signature, final boolean chopit) {
String type = """";
String typeParams = """";
int index = 0;
if (signature.charAt(0) == '<') {
typeParams = typeParamTypesToString(signature, chopit);
index += unwrap(consumed_chars);
}
if (signature.charAt(index) == '(') {
type = typeParams + typeSignaturesToString(signature.substring(index), chopit, ')');
index += unwrap(consumed_chars);
type = type + typeSignatureToString(signature.substring(index), chopit);
index += unwrap(consumed_chars);
return type;
}
type = typeSignatureToString(signature.substring(index), chopit);
index += unwrap(consumed_chars);
if ((typeParams.length() == 0) && (index == signature.length())) {
return type;
}
final StringBuilder typeClass = new StringBuilder(typeParams);
typeClass.append("" extends "");
typeClass.append(type);
if (index < signature.length()) {
typeClass.append("" implements "");
typeClass.append(typeSignatureToString(signature.substring(index), chopit));
index += unwrap(consumed_chars);
}
while (index < signature.length()) {
typeClass.append("", "");
typeClass.append(typeSignatureToString(signature.substring(index), chopit));
index += unwrap(consumed_chars);
}
return typeClass.toString();
}",0
365,"static Attribute[] getParameterAnnotationAttributes(final ConstantPoolGen cp, final List<AnnotationEntryGen>[] vec) {
final int[] visCount = new int[vec.length];
int totalVisCount = 0;
final int[] invisCount = new int[vec.length];
int totalInvisCount = 0;
try {
for (int i = 0; i < vec.length; i++) {
if (vec[i] != null) {
for (final AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
visCount[i]++;
totalVisCount++;
} else {
invisCount[i]++;
totalInvisCount++;
}
}
}
}
final ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes)) {
rvaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
rvaDos.writeShort(visCount[i]);
if (visCount[i] > 0) {
for (final AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
element.dump(rvaDos);
}
}
}
}
}
final ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
try (DataOutputStream riaDos = new DataOutputStream(riaBytes)) {
riaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
riaDos.writeShort(invisCount[i]);
if (invisCount[i] > 0) {
for (final AnnotationEntryGen element : vec[i]) {
if (!element.isRuntimeVisible()) {
element.dump(riaDos);
}
}
}
}
}
final byte[] rvaData = rvaBytes.toByteArray();
final byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (totalVisCount > 0) {
rvaIndex = cp.addUtf8(""RuntimeVisibleParameterAnnotations"");
}
if (totalInvisCount > 0) {
riaIndex = cp.addUtf8(""RuntimeInvisibleParameterAnnotations"");
}
final List<Attribute> newAttributes = new ArrayList<>();
if (totalVisCount > 0) {
newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (totalInvisCount > 0) {
newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (final IOException e) {
System.err.println(""IOException whilst processing parameter annotations"");
e.printStackTrace();
}
return null;
}",0
366,"static Attribute[] getAnnotationAttributes(final ConstantPoolGen cp, final AnnotationEntryGen[] annotationEntryGens) {
if (annotationEntryGens.length == 0) {
return new Attribute[0];
}
try {
int countVisible = 0;
int countInvisible = 0;
for (final AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
countVisible++;
} else {
countInvisible++;
}
}
final ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
final ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
DataOutputStream riaDos = new DataOutputStream(riaBytes)) {
rvaDos.writeShort(countVisible);
riaDos.writeShort(countInvisible);
for (final AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
a.dump(rvaDos);
} else {
a.dump(riaDos);
}
}
}
final byte[] rvaData = rvaBytes.toByteArray();
final byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (rvaData.length > 2) {
rvaIndex = cp.addUtf8(""RuntimeVisibleAnnotations"");
}
if (riaData.length > 2) {
riaIndex = cp.addUtf8(""RuntimeInvisibleAnnotations"");
}
final List<Attribute> newAttributes = new ArrayList<>();
if (rvaData.length > 2) {
newAttributes.add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (riaData.length > 2) {
newAttributes.add(new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (final IOException e) {
System.err.println(""IOException whilst processing annotations"");
e.printStackTrace();
}
return null;
}",0
367,"public ArrayType(final Type type, final int dimensions) {
super(Const.T_ARRAY, ""<dummy>"");
if ((dimensions < 1) || (dimensions > Const.MAX_BYTE)) {
throw new ClassGenException(""Invalid number of dimensions: "" + dimensions);
}
switch(type.getType()) {
case Const.T_ARRAY:
final ArrayType array = (ArrayType) type;
this.dimensions = dimensions + array.dimensions;
basicType = array.basicType;
break;
case Const.T_VOID:
throw new ClassGenException(""Invalid type: void[]"");
default:
// Basic type or reference
this.dimensions = dimensions;
basicType = type;
break;
}
final StringBuilder buf = new StringBuilder();
for (int i = 0; i < this.dimensions; i++) {
buf.append('[');
}
buf.append(basicType.getSignature());
super.setSignature(buf.toString());
}",0
368,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
369,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
370,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
371,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
372,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
373,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
374,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
375,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
376,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0
377,"@Override
public Number getValue() {
return new Double(value);
}",0
378,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new UnsupportedOperationException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
379,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new UnsupportedOperationException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
380,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new UnsupportedOperationException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
381,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new UnsupportedOperationException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
382,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new UnsupportedOperationException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
383,"@Override
public Number getValue() {
return new Float(value);
}",0
384,"public void setInitValue(final double d) {
checkType(Type.DOUBLE);
if (d != 0.0) {
value = new Double(d);
}
}",0
385,"public void setInitValue(final float f) {
checkType(Type.FLOAT);
if (f != 0.0) {
value = new Float(f);
}
}",0
386,Instruction[] INSTRUCTIONS = new Instruction[256];,0
387,"public INSTANCEOF createInstanceOf(final ReferenceType t) {
if (t instanceof ArrayType) {
return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
}
return new INSTANCEOF(cp.addClass((ObjectType) t));
}",0
388,"public Instruction createCast(final Type src_type, final Type dest_type) {
if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {
final byte dest = dest_type.getType();
byte src = src_type.getType();
if (dest == Const.T_LONG && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
src = Const.T_INT;
}
final String name = ""org.apache.bcel.generic."" + short_names[src - Const.T_CHAR] + ""2"" + short_names[dest - Const.T_CHAR];
Instruction i = null;
try {
i = (Instruction) java.lang.Class.forName(name).newInstance();
} catch (final Exception e) {
throw new IllegalArgumentException(""Could not find instruction: "" + name, e);
}
return i;
} else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {
if (dest_type instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));
}
return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
} else {
throw new IllegalArgumentException(""Cannot cast "" + src_type + "" to "" + dest_type);
}
}",0
389,"public CHECKCAST createCheckCast(final ReferenceType t) {
if (t instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) t));
}
return new CHECKCAST(cp.addClass((ObjectType) t));
}",0
390,"public int[] getInstructionPositions() {
return bytePositions;
}",0
391,"public void setPositions(final boolean check) {
int max_additional_bytes = 0;
int additional_bytes = 0;
int index = 0;
int count = 0;
final int[] pos = new int[length];
if (check) {
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
final Instruction i = ih.getInstruction();
if (i instanceof BranchInstruction) {
Instruction inst = ((BranchInstruction) i).getTarget().getInstruction();
if (!contains(inst)) {
throw new ClassGenException(""Branch target of "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not in instruction list"");
}
if (i instanceof Select) {
final InstructionHandle[] targets = ((Select) i).getTargets();
for (final InstructionHandle target : targets) {
inst = target.getInstruction();
if (!contains(inst)) {
throw new ClassGenException(""Branch target of "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not in instruction list"");
}
}
}
if (!(ih instanceof BranchHandle)) {
throw new ClassGenException(""Branch instruction "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not contained in BranchHandle."");
}
}
}
}
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
final Instruction i = ih.getInstruction();
ih.setPosition(index);
pos[count++] = index;
switch(i.getOpcode()) {
case Const.JSR:
case Const.GOTO:
max_additional_bytes += 2;
break;
case Const.TABLESWITCH:
case Const.LOOKUPSWITCH:
max_additional_bytes += 3;
break;
}
index += i.getLength();
}
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);
}
index = count = 0;
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
final Instruction i = ih.getInstruction();
ih.setPosition(index);
pos[count++] = index;
index += i.getLength();
}
bytePositions = new int[count];
System.arraycopy(pos, 0, bytePositions, 0, count);
}",0
392,"public Object getValue(final ConstantPoolGen cpg) {
org.apache.bcel.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.bcel.Const.CONSTANT_String:
final int i = ((org.apache.bcel.classfile.ConstantString) c).getStringIndex();
c = cpg.getConstantPool().getConstant(i);
return ((org.apache.bcel.classfile.ConstantUtf8) c).getBytes();
case org.apache.bcel.Const.CONSTANT_Float:
return new Float(((org.apache.bcel.classfile.ConstantFloat) c).getBytes());
case org.apache.bcel.Const.CONSTANT_Integer:
return Integer.valueOf(((org.apache.bcel.classfile.ConstantInteger) c).getBytes());
case org.apache.bcel.Const.CONSTANT_Class:
final int nameIndex = ((org.apache.bcel.classfile.ConstantClass) c).getNameIndex();
c = cpg.getConstantPool().getConstant(nameIndex);
return new ObjectType(((org.apache.bcel.classfile.ConstantUtf8) c).getBytes());
default:
// Never reached
throw new IllegalArgumentException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0
393,"public Number getValue(final ConstantPoolGen cpg) {
final org.apache.bcel.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.bcel.Const.CONSTANT_Long:
return Long.valueOf(((org.apache.bcel.classfile.ConstantLong) c).getBytes());
case org.apache.bcel.Const.CONSTANT_Double:
return new Double(((org.apache.bcel.classfile.ConstantDouble) c).getBytes());
default:
// Never reached
throw new IllegalArgumentException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0
394,"public void setArgumentTypes(final Type[] arg_types) {
this.argTypes = arg_types;
}",0
395,"public MethodGen(final int access_flags, final Type return_type, final Type[] argTypes, String[] argNames, final String method_name, final String className, final InstructionList il, final ConstantPoolGen cp) {
super(access_flags);
setType(return_type);
setArgumentTypes(argTypes);
setArgumentNames(argNames);
setName(method_name);
setClassName(className);
setInstructionList(il);
setConstantPool(cp);
final boolean abstract_ = isAbstract() || isNative();
InstructionHandle start = null;
final InstructionHandle end = null;
if (!abstract_) {
start = il.getStart();
if (!isStatic() && (className != null)) {
addLocalVariable(""this"", ObjectType.getInstance(className), start, end);
}
}
if (argTypes != null) {
final int size = argTypes.length;
for (final Type arg_type : argTypes) {
if (Type.VOID == arg_type) {
throw new ClassGenException(""'void' is an illegal argument type for a method"");
}
}
if (argNames != null) {
if (size != argNames.length) {
throw new ClassGenException(""Mismatch in argument array lengths: "" + size + "" vs. "" + argNames.length);
}
} else {
argNames = new String[size];
for (int i = 0; i < size; i++) {
argNames[i] = ""arg"" + i;
}
setArgumentNames(argNames);
}
if (!abstract_) {
for (int i = 0; i < size; i++) {
addLocalVariable(argNames[i], argTypes[i], start, end);
}
}
}
}",0
396,"public void setArgumentNames(final String[] arg_names) {
this.argNames = arg_names;
}",0
397,"public InstructionHandle[] getTargets() {
return targets;
}",0
398,"public int[] getMatchs() {
return match;
}",0
399,"public int[] getIndices() {
return indices;
}",0
400,"public InstructionHandle[] getTargets() {
return targets;
}",0
401,private final InstructionHandle[] targets;,0
402,"AttributeHTML(final String dir, final String class_name, final ConstantPool constant_pool, final ConstantHTML constant_html) throws IOException {
this.class_name = class_name;
this.constant_pool = constant_pool;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_attributes.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
}",0
403,"@Override
public void visitAllocationInstruction(final AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
final short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new IllegalArgumentException(""Unhandled opcode: "" + opcode);
}
}",0
404,"@Override
public void visitAllocationInstruction(final AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
final short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new IllegalArgumentException(""Unhandled opcode: "" + opcode);
}
}",0
405,"@Override
public void visitBranchInstruction(final BranchInstruction bi) {
final BranchHandle bh = (BranchHandle) branch_map.get(bi);
final int pos = bh.getPosition();
final String name = bi.getName() + ""_"" + pos;
if (bi instanceof Select) {
final Select s = (Select) bi;
branches.add(bi);
final StringBuilder args = new StringBuilder(""new int[] { "");
final int[] matchs = s.getMatchs();
for (int i = 0; i < matchs.length; i++) {
args.append(matchs[i]);
if (i < matchs.length - 1) {
args.append("", "");
}
}
args.append("" }"");
_out.print(""Select "" + name + "" = new "" + bi.getName().toUpperCase(Locale.ENGLISH) + ""("" + args + "", new InstructionHandle[] { "");
for (int i = 0; i < matchs.length; i++) {
_out.print(""null"");
if (i < matchs.length - 1) {
_out.print("", "");
}
}
_out.println("" }, null);"");
} else {
final int t_pos = bh.getTarget().getPosition();
String target;
if (pos > t_pos) {
target = ""ih_"" + t_pos;
} else {
branches.add(bi);
target = ""null"";
}
_out.println(""    BranchInstruction "" + name + "" = _factory.createBranchInstruction("" + CONSTANT_PREFIX + bi.getName().toUpperCase(Locale.ENGLISH) + "", "" + target + "");"");
}
if (bh.hasTargeters()) {
_out.println(""    ih_"" + pos + "" = il.append("" + name + "");"");
} else {
_out.println(""    il.append("" + name + "");"");
}
}",0
406,"private void updateBranchTargets() {
for (final BranchInstruction bi : branches) {
final BranchHandle bh = (BranchHandle) branch_map.get(bi);
final int pos = bh.getPosition();
final String name = bi.getName() + ""_"" + pos;
int t_pos = bh.getTarget().getPosition();
_out.println(""    "" + name + "".setTarget(ih_"" + t_pos + "");"");
if (bi instanceof Select) {
final InstructionHandle[] ihs = ((Select) bi).getTargets();
for (int j = 0; j < ihs.length; j++) {
t_pos = ihs[j].getPosition();
_out.println(""    "" + name + "".setTarget("" + j + "", ih_"" + t_pos + "");"");
}
}
}
}",0
407,"@Override
public void visitLocalVariableInstruction(final LocalVariableInstruction i) {
final short opcode = i.getOpcode();
final Type type = i.getType(_cp);
if (opcode == Const.IINC) {
_out.println(""il.append(new IINC("" + i.getIndex() + "", "" + ((IINC) i).getIncrement() + ""));"");
} else {
final String kind = (opcode < Const.ISTORE) ? ""Load"" : ""Store"";
_out.println(""il.append(_factory.create"" + kind + ""("" + BCELifier.printType(type) + "", "" + i.getIndex() + ""));"");
}
}",0
408,"public static String printFlags(final int flags, final FLAGS location) {
if (flags == 0) {
return ""0"";
}
final StringBuilder buf = new StringBuilder();
for (int i = 0, pow = 1; pow <= Const.MAX_ACC_FLAG_I; i++) {
if ((flags & pow) != 0) {
if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {
buf.append(CONSTANT_PREFIX + ""ACC_SUPER | "");
} else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {
buf.append(CONSTANT_PREFIX + ""ACC_BRIDGE | "");
} else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {
buf.append(CONSTANT_PREFIX + ""ACC_VARARGS | "");
} else {
if (i < Const.ACCESS_NAMES_LENGTH) {
buf.append(CONSTANT_PREFIX + ""ACC_"").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append("" | "");
} else {
buf.append(String.format(CONSTANT_PREFIX + ""ACC_BIT %x | "", pow));
}
}
}
pow <<= 1;
}
final String str = buf.toString();
return str.substring(0, str.length() - 3);
}",0
409,"public BCELifier(final JavaClass clazz, final OutputStream out) {
_clazz = clazz;
_out = new PrintWriter(out);
_cp = new ConstantPoolGen(_clazz.getConstantPool());
}",0
410,"private void writeMainHTML(final AttributeHTML attribute_html) throws IOException {
try (PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + "".html""))) {
file.println(""<HTML>\n"" + ""<HEAD><TITLE>Documentation for "" + class_name + ""</TITLE>"" + ""</HEAD>\n"" + ""<FRAMESET BORDER=1 cols=\""30%,*\"">\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""ConstantPool\"" SRC=\"""" + class_name + ""_cp.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Attributes\"" SRC=\"""" + class_name + ""_attributes.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET>\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""Code\"" SRC=\"""" + class_name + ""_code.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Methods\"" SRC=\"""" + class_name + ""_methods.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET></FRAMESET></HTML>"");
}
final Attribute[] attributes = java_class.getAttributes();
for (int i = 0; i < attributes.length; i++) {
attribute_html.writeAttribute(attributes[i], ""class"" + i);
}
}",0
411,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
final Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
final int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
412,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
final Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
final int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
413,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
final Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
final int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
414,"public static final String[] DEFAULT_IGNORED_PACKAGES = { ""java."", ""javax."", ""sun."" };",0
415,"public static final String[] DEFAULT_IGNORED_PACKAGES = { ""java."", ""javax."", ""sun."" };",0
416,"public ClassLoader(final String[] ignored_packages) {
this.ignored_packages = ignored_packages;
}",0
417,"@Override
public String getBase() {
return resolved.getFileName().toString();
}",0
418,"@Override
public String getBase() {
return resolved.getFileName().toString();
}",0
419,"private static void addJdkModules(final String javaHome, final List<String> list) {
String modulesPath = System.getProperty(""java.modules.path"");
if (modulesPath == null || modulesPath.trim().isEmpty()) {
modulesPath = javaHome + File.separator + ""jmods"";
}
final File modulesDir = new File(modulesPath);
if (modulesDir.exists()) {
final String[] modules = modulesDir.list(MODULES_FILTER);
for (String module : modules) {
list.add(modulesDir.getPath() + File.separatorChar + module);
}
}
}",0
420,"public InputStream getInputStream(final String name, final String suffix) throws IOException {
InputStream inputStream = null;
try {
inputStream = getClass().getClassLoader().getResourceAsStream(name + suffix);
} catch (final Exception e) {
}
if (inputStream != null) {
return inputStream;
}
return getClassFile(name, suffix).getInputStream();
}",0
421,"@Deprecated
protected List<JavaClass> vec = new ArrayList<>();",0
422,"private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {
final short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
final StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
final int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (final int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
final int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
final int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
final int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
final ConstantFieldref c1 = (ConstantFieldref) constantPool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constantPool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
final String field_name = constantPool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(className)) {
buf.append(""<A HREF=\"""").append(className).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constantHtml.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
final int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
final ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constantPool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
final ConstantInvokeDynamic c = (ConstantInvokeDynamic) constantPool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(index, Const.CONSTANT_NameAndType)));
final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
final String[] args = Utility.methodSignatureArgumentTypes(signature, false);
final String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(className).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(className).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(className).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
final int dimensions = bytes.readByte();
buf.append(constantHtml.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0
423,"CodeHTML(final String dir, final String class_name, final Method[] methods, final ConstantPool constant_pool, final ConstantHTML constant_html) throws IOException {
this.className = class_name;
this.constantPool = constant_pool;
this.constantHtml = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_code.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\"">"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</BODY></HTML>"");
file.close();
}",0
424,"private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {
final short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
final StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
final int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (final int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
final int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
final int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
final int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
final ConstantFieldref c1 = (ConstantFieldref) constantPool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constantPool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
final String field_name = constantPool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(className)) {
buf.append(""<A HREF=\"""").append(className).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constantHtml.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
final int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
final ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constantPool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
final ConstantInvokeDynamic c = (ConstantInvokeDynamic) constantPool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(index, Const.CONSTANT_NameAndType)));
final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
final String[] args = Utility.methodSignatureArgumentTypes(signature, false);
final String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(className).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(className).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(className).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
final int dimensions = bytes.readByte();
buf.append(constantHtml.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0
425,"ConstantHTML(final String dir, final String class_name, final String class_package, final Method[] methods, final ConstantPool constant_pool) throws IOException {
this.className = class_name;
this.classPackage = class_package;
this.constantPool = constant_pool;
this.methods = methods;
constants = constant_pool.getConstantPool();
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
constantRef = new String[constants.length];
constantRef[0] = ""&lt;unknown&gt;"";
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
for (int i = 1; i < constants.length; i++) {
if (i % 2 == 0) {
file.print(""<TR BGCOLOR=\""#C0C0C0\""><TD>"");
} else {
file.print(""<TR BGCOLOR=\""#A0A0A0\""><TD>"");
}
if (constants[i] != null) {
writeConstant(i);
}
file.print(""</TD></TR>\n"");
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0
426,"@Override
public JavaClass findClass(final String className) {
return loadedClasses.get(className);
}",0
427,"MethodHTML(final String dir, final String class_name, final Method[] methods, final Field[] fields, final ConstantHTML constant_html, final AttributeHTML attribute_html) throws IOException {
this.className = class_name;
this.attribute_html = attribute_html;
this.constantHtml = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_methods.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
file.println(""<TR><TH ALIGN=LEFT>Access&nbsp;flags</TH><TH ALIGN=LEFT>Type</TH>"" + ""<TH ALIGN=LEFT>Field&nbsp;name</TH></TR>"");
for (final Field field : fields) {
writeField(field);
}
file.println(""</TABLE>"");
file.println(""<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags</TH>"" + ""<TH ALIGN=LEFT>Return&nbsp;type</TH><TH ALIGN=LEFT>Method&nbsp;name</TH>"" + ""<TH ALIGN=LEFT>Arguments</TH></TR>"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0
428,"public ModularRuntimeImage(final String javaHome) throws IOException {
final Map<String, ?> emptyMap = Collections.emptyMap();
final Path jrePath = Paths.get(javaHome);
final Path jrtFsPath = jrePath.resolve(""lib"").resolve(""jrt-fs.jar"");
this.classLoader = new URLClassLoader(new URL[] { jrtFsPath.toUri().toURL() });
this.fileSystem = FileSystems.newFileSystem(URI.create(""jrt:/""), emptyMap, classLoader);
}",0
429,"public static void main(final String[] args) {
try {
UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
} catch (final Exception e) {
e.printStackTrace();
}
new GraphicalVerifier();
}",0
430,private final boolean packFrame = false;,0
431,"@Override
public void update(final String classname) {
System.gc();
for (int i = 0; i < indent; i++) {
System.out.print("" "");
}
System.out.println(classname);
indent += 1;
final Verifier v = VerifierFactory.getVerifier(classname);
VerificationResult vr;
vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 1:\n"" + vr);
}
vr = v.doPass2();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 2:\n"" + vr);
}
if (vr == VerificationResult.VR_OK) {
try {
final JavaClass jc = Repository.lookupClass(v.getClassName());
for (int i = 0; i < jc.getMethods().length; i++) {
vr = v.doPass3a(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3a, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
vr = v.doPass3b(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3b, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
}
} catch (final ClassNotFoundException e) {
System.err.println(""Could not find class "" + v.getClassName() + "" in Repository"");
}
}
indent -= 1;
}",0
432,"private void jbInit() throws Exception {
contentPane = (JPanel) this.getContentPane();
contentPane.setLayout(cardLayout1);
this.setJMenuBar(jMenuBar1);
this.setSize(new Dimension(708, 451));
this.setTitle(""JustIce"");
jPanel1.setMinimumSize(new Dimension(100, 100));
jPanel1.setPreferredSize(new Dimension(100, 100));
jPanel1.setLayout(gridLayout1);
jSplitPane2.setOrientation(JSplitPane.VERTICAL_SPLIT);
jPanel2.setLayout(gridLayout2);
jPanel3.setMinimumSize(new Dimension(200, 100));
jPanel3.setPreferredSize(new Dimension(400, 400));
jPanel3.setLayout(gridLayout4);
messagesPanel.setMinimumSize(new Dimension(100, 100));
messagesPanel.setLayout(gridLayout3);
jPanel2.setMinimumSize(new Dimension(200, 100));
jMenu1.setText(""File"");
jScrollPane1.getViewport().setBackground(Color.red);
messagesScrollPane.getViewport().setBackground(Color.red);
messagesScrollPane.setPreferredSize(new Dimension(10, 10));
classNamesJList.addListSelectionListener(e -> classNamesJList_valueChanged(e));
classNamesJList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
jScrollPane3.setBorder(BorderFactory.createLineBorder(Color.black));
jScrollPane3.setPreferredSize(new Dimension(100, 100));
gridLayout4.setRows(4);
gridLayout4.setColumns(1);
gridLayout4.setHgap(1);
jScrollPane4.setBorder(BorderFactory.createLineBorder(Color.black));
jScrollPane4.setPreferredSize(new Dimension(100, 100));
pass1TextPane.setBorder(BorderFactory.createRaisedBevelBorder());
pass1TextPane.setToolTipText("""");
pass1TextPane.setEditable(false);
pass2TextPane.setBorder(BorderFactory.createRaisedBevelBorder());
pass2TextPane.setEditable(false);
messagesTextPane.setBorder(BorderFactory.createRaisedBevelBorder());
messagesTextPane.setEditable(false);
newFileMenuItem.setText(""New..."");
newFileMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(78, InputEvent.CTRL_MASK, true));
newFileMenuItem.addActionListener(e -> newFileMenuItem_actionPerformed(e));
pass3aTextPane.setEditable(false);
pass3bTextPane.setEditable(false);
pass3aJList.addListSelectionListener(e -> pass3aJList_valueChanged(e));
pass3bJList.addListSelectionListener(e -> pass3bJList_valueChanged(e));
jMenu2.setText(""Help"");
whatisMenuItem.setText(""What is..."");
whatisMenuItem.addActionListener(e -> whatisMenuItem_actionPerformed(e));
aboutMenuItem.setText(""About"");
aboutMenuItem.addActionListener(e -> aboutMenuItem_actionPerformed(e));
jSplitPane2.add(messagesPanel, JSplitPane.BOTTOM);
messagesPanel.add(messagesScrollPane, null);
messagesScrollPane.getViewport().add(messagesTextPane, null);
jSplitPane2.add(jPanel3, JSplitPane.TOP);
jPanel3.add(jScrollPane3, null);
jScrollPane3.getViewport().add(pass1TextPane, null);
jPanel3.add(jScrollPane4, null);
jPanel3.add(jSplitPane3, null);
jSplitPane3.add(jScrollPane2, JSplitPane.LEFT);
jScrollPane2.getViewport().add(pass3aJList, null);
jSplitPane3.add(jScrollPane5, JSplitPane.RIGHT);
jScrollPane5.getViewport().add(pass3aTextPane, null);
jPanel3.add(jSplitPane4, null);
jSplitPane4.add(jScrollPane6, JSplitPane.LEFT);
jScrollPane6.getViewport().add(pass3bJList, null);
jSplitPane4.add(jScrollPane7, JSplitPane.RIGHT);
jScrollPane7.getViewport().add(pass3bTextPane, null);
jScrollPane4.getViewport().add(pass2TextPane, null);
jSplitPane1.add(jPanel2, JSplitPane.TOP);
jPanel2.add(jScrollPane1, null);
jSplitPane1.add(jPanel1, JSplitPane.BOTTOM);
jPanel1.add(jSplitPane2, null);
jScrollPane1.getViewport().add(classNamesJList, null);
jMenuBar1.add(jMenu1);
jMenuBar1.add(jMenu2);
contentPane.add(jSplitPane1, ""jSplitPane1"");
jMenu1.add(newFileMenuItem);
jMenu2.add(whatisMenuItem);
jMenu2.add(aboutMenuItem);
jSplitPane2.setDividerLocation(300);
jSplitPane3.setDividerLocation(150);
jSplitPane4.setDividerLocation(150);
}",0
433,private final IvjEventHandler ivjEventHandler = new IvjEventHandler();,0
434,"public LocalVariablesInfo getLocalVariablesInfo(final int methodNr) {
if (this.verify() != VerificationResult.VR_OK) {
return null;
}
if (methodNr < 0 || methodNr >= localVariablesInfos.length) {
throw new AssertionViolatedException(""Method number out of range."");
}
return localVariablesInfos[methodNr];
}",0
435,"@Override
public void visitField(final Field obj) {
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isFinal() && obj.isVolatile()) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isStatic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_STATIC modifier set but hasn't!"");
}
if (!obj.isFinal()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_FINAL modifier set but hasn't!"");
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_VOLATILE | Const.ACC_TRANSIENT)) > 0) {
addMessage(""Field '"" + tostring(obj) + ""' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED,"" + "" ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored)."");
}
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
final String name = obj.getName();
if (!validFieldName(name)) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' has illegal name '"" + obj.getName() + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
final String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
try {
Type.getType(sig);
} catch (final ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by '"" + tostring(obj) + ""'."", cfe);
}
final String nameanddesc = name + sig;
if (field_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two fields (like '"" + tostring(obj) + ""') are allowed have same names and descriptors!"");
}
if (field_names.contains(name)) {
addMessage(""More than one field of name '"" + name + ""' detected (but with different type descriptors). This is very unusual."");
}
field_names_and_desc.add(nameanddesc);
field_names.add(name);
final Attribute[] atts = obj.getAttributes();
for (final Attribute att : atts) {
if ((!(att instanceof ConstantValue)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if (!(att instanceof ConstantValue)) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is not a ConstantValue and is therefore only of use for debuggers and such."");
}
}
}",0
436,"@Override
public void visitMethod(final Method obj) {
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
final String name = obj.getName();
if (!validMethodName(name, true)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
final String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
Type t;
Type[] ts;
try {
t = Type.getReturnType(sig);
ts = Type.getArgumentTypes(sig);
} catch (final ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by Method '"" + tostring(obj) + ""'."", cfe);
}
Type act = t;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
final Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
final VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has a return type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
for (final Type element : ts) {
act = element;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
final Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
final VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has an argument type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
}
if (name.equals(Const.STATIC_INITIALIZER_NAME) && (ts.length != 0)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."" + "" Its name resembles the class or interface initialization method"" + "" which it isn't because of its arguments (==descriptor)."");
}
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isAbstract()) {
if (obj.isFinal()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_FINAL modifier set."");
}
if (obj.isNative()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_NATIVE modifier set."");
}
if (obj.isPrivate()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_PRIVATE modifier set."");
}
if (obj.isStatic()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STATIC modifier set."");
}
if (obj.isStrictfp()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STRICT modifier set."");
}
if (obj.isSynchronized()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_SYNCHRONIZED modifier set."");
}
}
if (name.equals(Const.CONSTRUCTOR_NAME)) {
// ..may have at most one of ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC set: is checked above.
if (obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isAbstract()) {
throw new ClassConstraintException(""Instance initialization method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set."");
}
}
} else {
if (!name.equals(Const.STATIC_INITIALIZER_NAME)) {
if (jc.getMajor() >= Const.MAJOR_1_8) {
if (!(obj.isPublic() ^ obj.isPrivate())) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have"" + "" exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set."");
}
if (obj.isProtected() || obj.isFinal() || obj.isSynchronized() || obj.isNative()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isAbstract()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_ABSTRACT modifier set but hasn't!"");
}
if (obj.isPrivate() || obj.isProtected() || obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isStrictfp()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED,"" + "" ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set."");
}
}
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_SYNCHRONIZED | Const.ACC_NATIVE | Const.ACC_ABSTRACT | Const.ACC_STRICT)) > 0) {
addMessage(""Method '"" + tostring(obj) + ""' has access flag(s) other than"" + "" ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,"" + "" ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored)."");
}
final String nameanddesc = name + sig;
if (method_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two methods (like '"" + tostring(obj) + ""') are allowed have same names and desciptors!"");
}
method_names_and_desc.add(nameanddesc);
final Attribute[] atts = obj.getAttributes();
int num_code_atts = 0;
for (final Attribute att : atts) {
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is neither Code nor Exceptions and is therefore only of use for debuggers and such."");
}
if ((att instanceof Code) && (obj.isNative() || obj.isAbstract())) {
throw new ClassConstraintException(""Native or abstract methods like '"" + tostring(obj) + ""' must not have a Code attribute like '"" + tostring(att) + ""'."");
}
if (att instanceof Code) {
num_code_atts++;
}
}
if (!obj.isNative() && !obj.isAbstract() && num_code_atts != 1) {
throw new ClassConstraintException(""Non-native, non-abstract methods like '"" + tostring(obj) + ""' must have exactly one Code attribute (found: "" + num_code_atts + "")."");
}
}",0
437,"@Deprecated
protected static UninitializedObjectType _this;",0
438,"@Override
public void visitINVOKEINTERFACE(final INVOKEINTERFACE o) {
final int count = o.getCount();
if (count == 0) {
constraintViolated(o, ""The 'count' argument must not be 0."");
}
// TODO: Do we want to do anything with it?
final Type t = o.getType(cpg);
if (t instanceof ObjectType) {
final String name = ((ObjectType) t).getClassName();
final Verifier v = VerifierFactory.getVerifier(name);
final VerificationResult vr = v.doPass2();
if (vr.getStatus() != VerificationResult.VERIFIED_OK) {
constraintViolated(o, ""Class '"" + name + ""' is referenced, but cannot be loaded and resolved: '"" + vr + ""'."");
}
}
final Type[] argtypes = o.getArgumentTypes(cpg);
final int nargs = argtypes.length;
for (int i = nargs - 1; i >= 0; i--) {
final Type fromStack = stack().peek((nargs - 1) - i);
Type fromDesc = argtypes[i];
if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {
fromDesc = Type.INT;
}
if (!fromStack.equals(fromDesc)) {
if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {
final ReferenceType rFromStack = (ReferenceType) fromStack;
// TODO: This can only be checked when using Staerk-et-al's ""set of object types""
referenceTypeIsInitialized(o, rFromStack);
} else {
constraintViolated(o, ""Expecting a '"" + fromDesc + ""' but found a '"" + fromStack + ""' on the stack."");
}
}
}
Type objref = stack().peek(nargs);
if (objref == Type.NULL) {
return;
}
if (!(objref instanceof ReferenceType)) {
constraintViolated(o, ""Expecting a reference type as 'objectref' on the stack, not a '"" + objref + ""'."");
}
referenceTypeIsInitialized(o, (ReferenceType) objref);
if (!(objref instanceof ObjectType)) {
if (!(objref instanceof ArrayType)) {
constraintViolated(o, ""Expecting an ObjectType as 'objectref' on the stack, not a '"" + objref + ""'."");
} else {
objref = GENERIC_ARRAY;
}
}
// TODO: This can only be checked if we're using Staerk-et-al's ""set of object types""
int counted_count = 1;
for (int i = 0; i < nargs; i++) {
counted_count += argtypes[i].getSize();
}
if (count != counted_count) {
constraintViolated(o, ""The 'count' argument should probably read '"" + counted_count + ""' but is '"" + count + ""'."");
}
}",0
439,"@Override
public void visitGETFIELD(final GETFIELD o) {
try {
final Type objectref = stack().peek();
if (!((objectref instanceof ObjectType) || (objectref == Type.NULL))) {
constraintViolated(o, ""Stack top should be an object reference that's not an array reference, but is '"" + objectref + ""'."");
}
final String field_name = o.getFieldName(cpg);
final JavaClass jc = Repository.lookupClass(getObjectType(o).getClassName());
Field[] fields = jc.getFields();
Field f = null;
for (final Field field : fields) {
if (field.getName().equals(field_name)) {
final Type f_type = Type.getType(field.getSignature());
final Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
break;
}
}
}
if (f == null) {
final JavaClass[] superclasses = jc.getSuperClasses();
outer: for (final JavaClass superclass : superclasses) {
fields = superclass.getFields();
for (final Field field : fields) {
if (field.getName().equals(field_name)) {
final Type f_type = Type.getType(field.getSignature());
final Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
if ((f.getAccessFlags() & (Const.ACC_PUBLIC | Const.ACC_PROTECTED)) == 0) {
f = null;
}
break outer;
}
}
}
}
if (f == null) {
throw new AssertionViolatedException(""Field '"" + field_name + ""' not found in "" + jc.getClassName());
}
}
if (f.isProtected()) {
final ObjectType classtype = getObjectType(o);
final ObjectType curr = ObjectType.getInstance(mg.getClassName());
if (classtype.equals(curr) || curr.subclassOf(classtype)) {
final Type t = stack().peek();
if (t == Type.NULL) {
return;
}
if (!(t instanceof ObjectType)) {
constraintViolated(o, ""The 'objectref' must refer to an object that's not an array. Found instead: '"" + t + ""'."");
}
final ObjectType objreftype = (ObjectType) t;
if (!(objreftype.equals(curr) || objreftype.subclassOf(curr))) {
// TODO: One day move to Staerk-et-al's ""Set of object types"" instead of ""wider"" object types
}
}
}
// TODO: Could go into Pass 3a.
if (f.isStatic()) {
constraintViolated(o, ""Referenced field '"" + f + ""' is static which it shouldn't be."");
}
} catch (final ClassNotFoundException e) {
// FIXME: maybe not the best way to handle this
throw new AssertionViolatedException(""Missing class: "" + e, e);
}
}",0
440,"@Override
public Object clone() {
final LocalVariables lvs = new LocalVariables(locals.length);
for (int i = 0; i < locals.length; i++) {
lvs.locals[i] = this.locals[i];
}
return lvs;
}",0
441,"@Override
public Object clone() {
final OperandStack newstack = new OperandStack(this.maxStack);
@SuppressWarnings(""unchecked"")
final ArrayList<Type> clone = (ArrayList<Type>) this.stack.clone();
newstack.stack = clone;
return newstack;
}",0
442,"public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0
443,"public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",0
444,"public static final short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",0
445,"public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",0
446,"public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",0
447,"public static final String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
448,"public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"" };",0
449,"public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0
450,"public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
451,"public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0
452,"// TODO: mutable public array!!
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"" };",0
453,"public static final int[] CONSUME_STACK = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 3, 4, 3, 4, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 3, 4, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 2, 1, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 4, 2, 4, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 4, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 1, 2, 1, 0, 0, UNPREDICTABLE, 1, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, UNPREDICTABLE, 1, 1, 0, 0, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0
454,"public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0
455,"@Deprecated
public static final Class<?>[] EXCS_ARRAY_EXCEPTION = { NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION };",0
456,"@Deprecated
public static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = { NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR };",0
457,"@Deprecated
public static final Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = { NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR, EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR };",0
458,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0
459,"public Annotations(final byte annotation_type, final int name_index, final int length, final AnnotationEntry[] annotation_table, final ConstantPool constant_pool, final boolean isRuntimeVisible) {
super(annotation_type, name_index, length, constant_pool);
this.annotation_table = annotation_table;
this.isRuntimeVisible = isRuntimeVisible;
}",0
460,"public final void setAnnotationTable(final AnnotationEntry[] annotation_table) {
this.annotation_table = annotation_table;
}",0
461,"public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {
super(type, cpool);
if (type != ARRAY) {
throw new RuntimeException(""Only element values of type array can be built with this ctor - type specified: "" + type);
}
this.evalues = datums;
}",0
462,"public ElementValue[] getElementValuesArray() {
return evalues;
}",0
463,"public static Attribute readAttribute(final DataInput file, final ConstantPool constant_pool) throws IOException, ClassFormatException {
byte tag = Const.ATTR_UNKNOWN;
int name_index = file.readUnsignedShort();
ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);
String name = c.getBytes();
int length = file.readInt();
for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++) {
if (name.equals(Const.getAttributeName(i))) {
tag = i;
break;
}
}
switch(tag) {
case Const.ATTR_UNKNOWN:
Object r = readers.get(name);
if (r instanceof UnknownAttributeReader) {
return ((UnknownAttributeReader) r).createAttribute(name_index, length, file, constant_pool);
}
return new Unknown(name_index, length, file, constant_pool);
case Const.ATTR_CONSTANT_VALUE:
return new ConstantValue(name_index, length, file, constant_pool);
case Const.ATTR_SOURCE_FILE:
return new SourceFile(name_index, length, file, constant_pool);
case Const.ATTR_CODE:
return new Code(name_index, length, file, constant_pool);
case Const.ATTR_EXCEPTIONS:
return new ExceptionTable(name_index, length, file, constant_pool);
case Const.ATTR_LINE_NUMBER_TABLE:
return new LineNumberTable(name_index, length, file, constant_pool);
case Const.ATTR_LOCAL_VARIABLE_TABLE:
return new LocalVariableTable(name_index, length, file, constant_pool);
case Const.ATTR_INNER_CLASSES:
return new InnerClasses(name_index, length, file, constant_pool);
case Const.ATTR_SYNTHETIC:
return new Synthetic(name_index, length, file, constant_pool);
case Const.ATTR_DEPRECATED:
return new Deprecated(name_index, length, file, constant_pool);
case Const.ATTR_PMG:
return new PMGClass(name_index, length, file, constant_pool);
case Const.ATTR_SIGNATURE:
return new Signature(name_index, length, file, constant_pool);
case Const.ATTR_STACK_MAP:
return new StackMap(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:
return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:
return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:
return new RuntimeVisibleParameterAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:
return new RuntimeInvisibleParameterAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_ANNOTATION_DEFAULT:
return new AnnotationDefault(name_index, length, file, constant_pool);
case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:
return new LocalVariableTypeTable(name_index, length, file, constant_pool);
case Const.ATTR_ENCLOSING_METHOD:
return new EnclosingMethod(name_index, length, file, constant_pool);
case Const.ATTR_STACK_MAP_TABLE:
return new StackMap(name_index, length, file, constant_pool);
case Const.ATTR_BOOTSTRAP_METHODS:
return new BootstrapMethods(name_index, length, file, constant_pool);
case Const.ATTR_METHOD_PARAMETERS:
return new MethodParameters(name_index, length, file, constant_pool);
default:
throw new IllegalStateException(""Unrecognized attribute type tag parsed: "" + tag);
}
}",0
464,"public void setBootstrapArguments(final int[] bootstrap_arguments) {
this.bootstrap_arguments = bootstrap_arguments;
}",0
465,"public BootstrapMethod(final int bootstrap_method_ref, final int[] bootstrap_arguments) {
this.bootstrap_method_ref = bootstrap_method_ref;
this.bootstrap_arguments = bootstrap_arguments;
}",0
466,"public int[] getBootstrapArguments() {
return bootstrap_arguments;
}",0
467,"public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrap_methods, final ConstantPool constant_pool) {
super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);
this.bootstrap_methods = bootstrap_methods;
}",0
468,"public final BootstrapMethod[] getBootstrapMethods() {
return bootstrap_methods;
}",0
469,"public final void setBootstrapMethods(final BootstrapMethod[] bootstrap_methods) {
this.bootstrap_methods = bootstrap_methods;
}",0
470,"public JavaClass parse() throws IOException, ClassFormatException {
ZipFile zip = null;
try {
if (fileOwned) {
if (is_zip) {
zip = new ZipFile(zip_file);
ZipEntry entry = zip.getEntry(file_name);
if (entry == null) {
throw new IOException(""File "" + file_name + "" not found"");
}
dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry), BUFSIZE));
} else {
dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(file_name), BUFSIZE));
}
}
readID();
readVersion();
readConstantPool();
readClassInfo();
readInterfaces();
readFields();
readMethods();
readAttributes();
// System.err.println(""WARNING: "" + u[i]);
// System.err.println(""WARNING: Trailing garbage at end of "" + file_name);
// System.err.println(bytes + "" extra bytes: "" + Utility.toHexString(buf));
} finally {
if (fileOwned) {
try {
if (dataInputStream != null) {
dataInputStream.close();
}
if (zip != null) {
zip.close();
}
} catch (IOException ioe) {
}
}
}
return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor, access_flags, constant_pool, interfaces, fields, methods, attributes, is_zip ? JavaClass.ZIP : JavaClass.FILE);
}",0
471,"public final CodeException[] getExceptionTable() {
return exception_table;
}",0
472,"public final byte[] getCode() {
return code;
}",0
473,"public final Attribute[] getAttributes() {
return attributes;
}",0
474,"public final int getEndPC() {
return end_pc;
}",0
475,"@Override
public Object getConstantValue(final ConstantPool cp) {
return new Double(bytes);
}",0
476,"@Override
public Object getConstantValue(final ConstantPool cp) {
return new Float(bytes);
}",0
477,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
478,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
479,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
480,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
481,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
482,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
483,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
484,"public void setConstantPool(final Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0
485,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
486,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
487,"public ConstantPool(final Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0
488,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
489,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
490,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0
491,"public Constant[] getConstantPool() {
return constant_pool;
}",0
492,"ConstantUtf8(final DataInput file) throws IOException {
super(Const.CONSTANT_Utf8);
bytes = file.readUTF();
created++;
}",0
493,"public ConstantUtf8(final String bytes) {
super(Const.CONSTANT_Utf8);
if (bytes == null) {
throw new IllegalArgumentException(""bytes must not be null!"");
}
this.bytes = bytes;
created++;
}",0
494,"public Deprecated(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);
this.bytes = bytes;
}",0
495,"public final void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0
496,"public final byte[] getBytes() {
return bytes;
}",0
497,"public final int[] getExceptionIndexTable() {
return exception_index_table;
}",0
498,"public final Attribute[] getAttributes() {
return attributes;
}",0
499,"public final void setAttributes(final Attribute[] attributes) {
this.attributes = attributes;
this.attributes_count = attributes != null ? attributes.length : 0;
}",0
500,"public AnnotationEntry[] getAnnotationEntries() {
if (annotationEntries == null) {
annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotationEntries;
}",0
501,"public final InnerClass[] getInnerClasses() {
return inner_classes;
}",0
502,"public Field[] getFields() {
return fields;
}",0
503,"public void setInterfaces(final int[] interfaces) {
this.interfaces = interfaces;
}",0
504,"public void setFields(final Field[] fields) {
this.fields = fields;
}",0
505,"public void setMethods(final Method[] methods) {
this.methods = methods;
}",0
506,"public AnnotationEntry[] getAnnotationEntries() {
if (annotations == null) {
annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotations;
}",0
507,"static void Debug(final String str) {
if (debug) {
System.out.println(str);
}
}",0
508,"public Attribute[] getAttributes() {
return attributes;
}",0
509,"public int[] getInterfaceIndices() {
return interfaces;
}",0
510,"public void setAttributes(final Attribute[] attributes) {
this.attributes = attributes;
}",0
511,"public void setInterfaceNames(final String[] interface_names) {
this.interface_names = interface_names;
}",0
512,"public String[] getInterfaceNames() {
return interface_names;
}",0
513,"public Method[] getMethods() {
return methods;
}",0
514,"public final void setLineNumberTable(final LineNumber[] line_number_table) {
this.line_number_table = line_number_table;
}",0
515,"public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table, final ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.line_number_table = line_number_table;
}",0
516,"public final LineNumber[] getLineNumberTable() {
return line_number_table;
}",0
517,"public int getSourceLine(final int pos) {
int l = 0;
int r = line_number_table.length - 1;
if (r < 0) {
return -1;
}
int min_index = -1;
int min = -1;
do {
int i = (l + r) / 2;
int j = line_number_table[i].getStartPC();
if (j == pos) {
return line_number_table[i].getLineNumber();
} else if (pos < j) {
r = i - 1;
} else {
l = i + 1;
}
if (j < pos && j > min) {
min = j;
min_index = i;
}
} while (l <= r);
if (min_index < 0) {
return -1;
}
return line_number_table[min_index].getLineNumber();
}",0
518,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.local_variable_table = local_variable_table;
}",0
519,"public final LocalVariable[] getLocalVariableTable() {
return local_variable_table;
}",0
520,"public LocalVariableTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TABLE, name_index, length, constant_pool);
this.local_variable_table = local_variable_table;
}",0
521,"public final LocalVariable[] getLocalVariableTypeTable() {
return local_variable_type_table;
}",0
522,"public LocalVariableTypeTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);
this.local_variable_type_table = local_variable_table;
}",0
523,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.local_variable_type_table = local_variable_table;
}",0
524,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
if (parameterAnnotationEntries == null) {
parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());
}
return parameterAnnotationEntries;
}",0
525,"public void setParameters(final MethodParameter[] parameters) {
this.parameters = parameters;
}",0
526,"public MethodParameter[] getParameters() {
return parameters;
}",0
527,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0
528,"public ParameterAnnotations(final byte parameter_annotation_type, final int name_index, final int length, final ParameterAnnotationEntry[] parameter_annotation_table, final ConstantPool constant_pool) {
super(parameter_annotation_type, name_index, length, constant_pool);
this.parameter_annotation_table = parameter_annotation_table;
}",0
529,"public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
return parameter_annotation_table;
}",0
530,"public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameter_annotation_table) {
this.parameter_annotation_table = parameter_annotation_table;
}",0
531,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
return parameter_annotation_table;
}",0
532,"final String getData() {
return new String(buf);
}",0
533,"private static void matchIdent(final MyByteArrayInputStream in, final StringBuilder buf) {
int ch;
if ((ch = in.read()) == -1) {
throw new RuntimeException(""Illegal signature: "" + in.getData() + "" no ident, reaching EOF"");
}
// System.out.println(""return from ident:"" + (char)ch);
if (!identStart(ch)) {
StringBuilder buf2 = new StringBuilder();
int count = 1;
while (Character.isJavaIdentifierPart((char) ch)) {
buf2.append((char) ch);
count++;
ch = in.read();
}
if (ch == ':') {
in.skip(""Ljava/lang/Object"".length());
buf.append(buf2);
ch = in.read();
in.unread();
// System.out.println(""so far:"" + buf2 + "":next:"" +(char)ch);
} else {
for (int i = 0; i < count; i++) {
in.unread();
}
}
return;
}
StringBuilder buf2 = new StringBuilder();
ch = in.read();
do {
buf2.append((char) ch);
ch = in.read();
// System.out.println(""within ident:""+ (char)ch);
} while ((ch != -1) && (Character.isJavaIdentifierPart((char) ch) || (ch == '/')));
buf.append(buf2.toString().replace('/', '.'));
// System.out.println(""regular return ident:""+ (char)ch + "":"" + buf2);
if (ch != -1) {
in.unread();
}
}",0
534,"public final StackMapEntry[] getStackMap() {
return map;
}",0
535,"public final void setStackMap(final StackMapEntry[] map) {
this.map = map;
int len = 2;
for (StackMapEntry element : map) {
len += element.getMapEntrySize();
}
setLength(len);
}",0
536,"public StackMap(final int name_index, final int length, final StackMapEntry[] map, final ConstantPool constant_pool) {
super(Const.ATTR_STACK_MAP, name_index, length, constant_pool);
this.map = map;
}",0
537,"public StackMapType[] getTypesOfLocals() {
return types_of_locals;
}",0
538,"public StackMapType[] getTypesOfStackItems() {
return types_of_stack_items;
}",0
539,"public final byte[] getBytes() {
return bytes;
}",0
540,"public Synthetic(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_SYNTHETIC, name_index, length, constant_pool);
this.bytes = bytes;
}",0
541,"public final void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0
542,"public final byte[] getBytes() {
return bytes;
}",0
543,"public Unknown(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_UNKNOWN, name_index, length, constant_pool);
this.bytes = bytes;
name = ((ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8)).getBytes();
unknown_attributes.put(name, this);
}",0
544,"public final void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0
545,"public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool, final boolean verbose) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
System.err.println(""Unreachable default case reached!"");
System.exit(-1);
}
}
}
}
return buf.toString();
}",0
546,"public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool, final boolean verbose) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
System.err.println(""Unreachable default case reached!"");
System.exit(-1);
}
}
}
}
return buf.toString();
}",0
547,"static Attribute[] getAnnotationAttributes(final ConstantPoolGen cp, final AnnotationEntryGen[] annotationEntryGens) {
if (annotationEntryGens.length == 0) {
return new Attribute[0];
}
try {
int countVisible = 0;
int countInvisible = 0;
for (AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
countVisible++;
} else {
countInvisible++;
}
}
ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
DataOutputStream riaDos = new DataOutputStream(riaBytes);
rvaDos.writeShort(countVisible);
riaDos.writeShort(countInvisible);
for (AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
a.dump(rvaDos);
} else {
a.dump(riaDos);
}
}
rvaDos.close();
riaDos.close();
byte[] rvaData = rvaBytes.toByteArray();
byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (rvaData.length > 2) {
rvaIndex = cp.addUtf8(""RuntimeVisibleAnnotations"");
}
if (riaData.length > 2) {
riaIndex = cp.addUtf8(""RuntimeInvisibleAnnotations"");
}
List<Attribute> newAttributes = new ArrayList<>();
if (rvaData.length > 2) {
newAttributes.add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (riaData.length > 2) {
newAttributes.add(new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (IOException e) {
System.err.println(""IOException whilst processing annotations"");
e.printStackTrace();
}
return null;
}",0
548,"static Attribute[] getParameterAnnotationAttributes(final ConstantPoolGen cp, final List<AnnotationEntryGen>[] vec) {
int[] visCount = new int[vec.length];
int totalVisCount = 0;
int[] invisCount = new int[vec.length];
int totalInvisCount = 0;
try {
for (int i = 0; i < vec.length; i++) {
if (vec[i] != null) {
for (AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
visCount[i]++;
totalVisCount++;
} else {
invisCount[i]++;
totalInvisCount++;
}
}
}
}
ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
rvaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
rvaDos.writeShort(visCount[i]);
if (visCount[i] > 0) {
for (AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
element.dump(rvaDos);
}
}
}
}
rvaDos.close();
ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
DataOutputStream riaDos = new DataOutputStream(riaBytes);
riaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
riaDos.writeShort(invisCount[i]);
if (invisCount[i] > 0) {
for (AnnotationEntryGen element : vec[i]) {
if (!element.isRuntimeVisible()) {
element.dump(riaDos);
}
}
}
}
riaDos.close();
byte[] rvaData = rvaBytes.toByteArray();
byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (totalVisCount > 0) {
rvaIndex = cp.addUtf8(""RuntimeVisibleParameterAnnotations"");
}
if (totalInvisCount > 0) {
riaIndex = cp.addUtf8(""RuntimeInvisibleParameterAnnotations"");
}
List<Attribute> newAttributes = new ArrayList<>();
if (totalVisCount > 0) {
newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (totalInvisCount > 0) {
newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (IOException e) {
System.err.println(""IOException whilst processing parameter annotations"");
e.printStackTrace();
}
return null;
}",0
549,"public ArrayType(final Type type, final int dimensions) {
super(Const.T_ARRAY, ""<dummy>"");
if ((dimensions < 1) || (dimensions > Const.MAX_BYTE)) {
throw new ClassGenException(""Invalid number of dimensions: "" + dimensions);
}
switch(type.getType()) {
case Const.T_ARRAY:
ArrayType array = (ArrayType) type;
this.dimensions = dimensions + array.dimensions;
basic_type = array.basic_type;
break;
case Const.T_VOID:
throw new ClassGenException(""Invalid type: void[]"");
default:
// Basic type or reference
this.dimensions = dimensions;
basic_type = type;
break;
}
StringBuilder buf = new StringBuilder();
for (int i = 0; i < this.dimensions; i++) {
buf.append('[');
}
buf.append(basic_type.getSignature());
super.setSignature(buf.toString());
}",0
550,"@Override
protected void addHandle() {
super.setNext(bh_list);
bh_list = this;
}",0
551,"static BranchHandle getBranchHandle(final BranchInstruction i) {
if (bh_list == null) {
return new BranchHandle(i);
}
BranchHandle bh = bh_list;
bh_list = (BranchHandle) bh.getNext();
bh.setInstruction(i);
return bh;
}",0
552,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
553,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
554,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
555,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
556,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
557,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
558,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
559,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
560,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0
561,"@Override
public Number getValue() {
return new Double(value);
}",0
562,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
563,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
564,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
565,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
566,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0
567,"@Override
public Number getValue() {
return new Float(value);
}",0
568,"public void setInitValue(final float f) {
checkType(Type.FLOAT);
if (f != 0.0) {
value = new Float(f);
}
}",0
569,"public void setInitValue(final double d) {
checkType(Type.DOUBLE);
if (d != 0.0) {
value = new Double(d);
}
}",0
570,"@Override
public boolean equals(final Instruction i1, final Instruction i2) {
if (i1.getOpcode() == i2.getOpcode()) {
if (i1 instanceof BranchInstruction) {
return false;
} else if (i1 instanceof ConstantPushInstruction) {
return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());
} else if (i1 instanceof IndexedInstruction) {
return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();
} else if (i1 instanceof NEWARRAY) {
return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
} else {
return true;
}
}
return false;
}",0
571,public static final Instruction[] INSTRUCTIONS = new Instruction[256];,0
572,"public Instruction createCast(final Type src_type, final Type dest_type) {
if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {
byte dest = dest_type.getType();
byte src = src_type.getType();
if (dest == Const.T_LONG && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
src = Const.T_INT;
}
String name = ""org.apache.commons.bcel6.generic."" + short_names[src - Const.T_CHAR] + ""2"" + short_names[dest - Const.T_CHAR];
Instruction i = null;
try {
i = (Instruction) java.lang.Class.forName(name).newInstance();
} catch (Exception e) {
throw new RuntimeException(""Could not find instruction: "" + name, e);
}
return i;
} else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {
if (dest_type instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));
}
return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
} else {
throw new RuntimeException(""Can not cast "" + src_type + "" to "" + dest_type);
}
}",0
573,"public INSTANCEOF createInstanceOf(final ReferenceType t) {
if (t instanceof ArrayType) {
return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
}
return new INSTANCEOF(cp.addClass((ObjectType) t));
}",0
574,"public CHECKCAST createCheckCast(final ReferenceType t) {
if (t instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) t));
}
return new CHECKCAST(cp.addClass((ObjectType) t));
}",0
575,"protected void addHandle() {
next = ih_list;
ih_list = this;
}",0
576,"public void setPositions(final boolean check) {
int max_additional_bytes = 0;
int additional_bytes = 0;
int index = 0;
int count = 0;
int[] pos = new int[length];
if (check) {
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
Instruction i = ih.getInstruction();
if (i instanceof BranchInstruction) {
Instruction inst = ((BranchInstruction) i).getTarget().getInstruction();
if (!contains(inst)) {
throw new ClassGenException(""Branch target of "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not in instruction list"");
}
if (i instanceof Select) {
InstructionHandle[] targets = ((Select) i).getTargets();
for (InstructionHandle target : targets) {
inst = target.getInstruction();
if (!contains(inst)) {
throw new ClassGenException(""Branch target of "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not in instruction list"");
}
}
}
if (!(ih instanceof BranchHandle)) {
throw new ClassGenException(""Branch instruction "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not contained in BranchHandle."");
}
}
}
}
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
Instruction i = ih.getInstruction();
ih.setPosition(index);
pos[count++] = index;
switch(i.getOpcode()) {
case Const.JSR:
case Const.GOTO:
max_additional_bytes += 2;
break;
case Const.TABLESWITCH:
case Const.LOOKUPSWITCH:
max_additional_bytes += 3;
break;
}
index += i.getLength();
}
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);
}
index = count = 0;
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
Instruction i = ih.getInstruction();
ih.setPosition(index);
pos[count++] = index;
index += i.getLength();
}
byte_positions = new int[count];
System.arraycopy(pos, 0, byte_positions, 0, count);
}",0
577,"public static InstructionHandle findHandle(final InstructionHandle[] ihs, final int[] pos, final int count, final int target) {
int l = 0;
int r = count - 1;
do {
int i = (l + r) / 2;
int j = pos[i];
if (j == target) {
return ihs[i];
} else if (target < j) {
r = i - 1;
} else {
l = i + 1;
}
} while (l <= r);
return null;
}",0
578,"public int[] getInstructionPositions() {
return byte_positions;
}",0
579,"public Object getValue(final ConstantPoolGen cpg) {
org.apache.commons.bcel6.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.commons.bcel6.Const.CONSTANT_String:
int i = ((org.apache.commons.bcel6.classfile.ConstantString) c).getStringIndex();
c = cpg.getConstantPool().getConstant(i);
return ((org.apache.commons.bcel6.classfile.ConstantUtf8) c).getBytes();
case org.apache.commons.bcel6.Const.CONSTANT_Float:
return new Float(((org.apache.commons.bcel6.classfile.ConstantFloat) c).getBytes());
case org.apache.commons.bcel6.Const.CONSTANT_Integer:
return Integer.valueOf(((org.apache.commons.bcel6.classfile.ConstantInteger) c).getBytes());
case org.apache.commons.bcel6.Const.CONSTANT_Class:
int nameIndex = ((org.apache.commons.bcel6.classfile.ConstantClass) c).getNameIndex();
c = cpg.getConstantPool().getConstant(nameIndex);
return new ObjectType(((org.apache.commons.bcel6.classfile.ConstantUtf8) c).getBytes());
default:
// Never reached
throw new RuntimeException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0
580,"public Number getValue(final ConstantPoolGen cpg) {
org.apache.commons.bcel6.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.commons.bcel6.Const.CONSTANT_Long:
return Long.valueOf(((org.apache.commons.bcel6.classfile.ConstantLong) c).getBytes());
case org.apache.commons.bcel6.Const.CONSTANT_Double:
return new Double(((org.apache.commons.bcel6.classfile.ConstantDouble) c).getBytes());
default:
// Never reached
throw new RuntimeException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0
581,"public void setArgumentNames(final String[] arg_names) {
this.arg_names = arg_names;
}",0
582,"public void setArgumentTypes(final Type[] arg_types) {
this.arg_types = arg_types;
}",0
583,"public void setArgumentTypes(final Type[] arg_types) {
this.arg_types = arg_types;
}",0
584,"private void sort(final int l, final int r) {
int i = l;
int j = r;
int h;
int m = match[(l + r) / 2];
InstructionHandle h2;
do {
while (match[i] < m) {
i++;
}
while (m < match[j]) {
j--;
}
if (i <= j) {
h = match[i];
match[i] = match[j];
match[j] = h;
h2 = targets[i];
targets[i] = targets[j];
targets[j] = h2;
i++;
j--;
}
} while (i <= j);
if (l < j) {
sort(l, j);
}
if (i < r) {
sort(i, r);
}
}",0
585,"public int[] getIndices() {
return indices;
}",0
586,"public int[] getMatchs() {
return match;
}",0
587,"public InstructionHandle[] getTargets() {
return targets;
}",0
588,"public InstructionHandle[] getTargets() {
return targets;
}",0
589,private final InstructionHandle[] targets;,0
590,"AttributeHTML(final String dir, final String class_name, final ConstantPool constant_pool, final ConstantHTML constant_html) throws IOException {
this.class_name = class_name;
this.constant_pool = constant_pool;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_attributes.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
}",0
591,"@Override
public void visitBranchInstruction(final BranchInstruction bi) {
BranchHandle bh = (BranchHandle) branch_map.get(bi);
int pos = bh.getPosition();
String name = bi.getName() + ""_"" + pos;
if (bi instanceof Select) {
Select s = (Select) bi;
branches.add(bi);
StringBuilder args = new StringBuilder(""new int[] { "");
int[] matchs = s.getMatchs();
for (int i = 0; i < matchs.length; i++) {
args.append(matchs[i]);
if (i < matchs.length - 1) {
args.append("", "");
}
}
args.append("" }"");
_out.print(""Select "" + name + "" = new "" + bi.getName().toUpperCase(Locale.ENGLISH) + ""("" + args + "", new InstructionHandle[] { "");
for (int i = 0; i < matchs.length; i++) {
_out.print(""null"");
if (i < matchs.length - 1) {
_out.print("", "");
}
}
_out.println("" }, null);"");
} else {
int t_pos = bh.getTarget().getPosition();
String target;
if (pos > t_pos) {
target = ""ih_"" + t_pos;
} else {
branches.add(bi);
target = ""null"";
}
_out.println(""    BranchInstruction "" + name + "" = _factory.createBranchInstruction("" + CONSTANT_PREFIX + bi.getName().toUpperCase(Locale.ENGLISH) + "", "" + target + "");"");
}
if (bh.hasTargeters()) {
_out.println(""    ih_"" + pos + "" = il.append("" + name + "");"");
} else {
_out.println(""    il.append("" + name + "");"");
}
}",0
592,"@Override
public void visitAllocationInstruction(final AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new RuntimeException(""Oops: "" + opcode);
}
}",0
593,"@Override
public void visitLocalVariableInstruction(final LocalVariableInstruction i) {
short opcode = i.getOpcode();
Type type = i.getType(_cp);
if (opcode == Const.IINC) {
_out.println(""il.append(new IINC("" + i.getIndex() + "", "" + ((IINC) i).getIncrement() + ""));"");
} else {
String kind = (opcode < Const.ISTORE) ? ""Load"" : ""Store"";
_out.println(""il.append(_factory.create"" + kind + ""("" + BCELifier.printType(type) + "", "" + i.getIndex() + ""));"");
}
}",0
594,"@Override
public void visitAllocationInstruction(final AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new RuntimeException(""Oops: "" + opcode);
}
}",0
595,"private void updateBranchTargets() {
for (BranchInstruction bi : branches) {
BranchHandle bh = (BranchHandle) branch_map.get(bi);
int pos = bh.getPosition();
String name = bi.getName() + ""_"" + pos;
int t_pos = bh.getTarget().getPosition();
_out.println(""    "" + name + "".setTarget(ih_"" + t_pos + "");"");
if (bi instanceof Select) {
InstructionHandle[] ihs = ((Select) bi).getTargets();
for (int j = 0; j < ihs.length; j++) {
t_pos = ihs[j].getPosition();
_out.println(""    "" + name + "".setTarget("" + j + "", ih_"" + t_pos + "");"");
}
}
}
}",0
596,"public BCELifier(final JavaClass clazz, final OutputStream out) {
_clazz = clazz;
_out = new PrintWriter(out);
_cp = new ConstantPoolGen(_clazz.getConstantPool());
}",0
597,"public static String printFlags(final int flags, final FLAGS location) {
if (flags == 0) {
return ""0"";
}
StringBuilder buf = new StringBuilder();
for (int i = 0, pow = 1; pow <= Const.MAX_ACC_FLAG; i++) {
if ((flags & pow) != 0) {
if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {
buf.append(CONSTANT_PREFIX + ""ACC_SUPER | "");
} else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {
buf.append(CONSTANT_PREFIX + ""ACC_BRIDGE | "");
} else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {
buf.append(CONSTANT_PREFIX + ""ACC_VARARGS | "");
} else {
if (i < Const.ACCESS_NAMES_LENGTH) {
buf.append(CONSTANT_PREFIX + ""ACC_"").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append("" | "");
} else {
buf.append(String.format(CONSTANT_PREFIX + ""ACC_BIT %x | "", pow));
}
}
}
pow <<= 1;
}
String str = buf.toString();
return str.substring(0, str.length() - 3);
}",0
598,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
599,"private void writeMainHTML(final AttributeHTML attribute_html) throws IOException {
PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + "".html""));
Attribute[] attributes = java_class.getAttributes();
file.println(""<HTML>\n"" + ""<HEAD><TITLE>Documentation for "" + class_name + ""</TITLE>"" + ""</HEAD>\n"" + ""<FRAMESET BORDER=1 cols=\""30%,*\"">\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""ConstantPool\"" SRC=\"""" + class_name + ""_cp.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Attributes\"" SRC=\"""" + class_name + ""_attributes.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET>\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""Code\"" SRC=\"""" + class_name + ""_code.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Methods\"" SRC=\"""" + class_name + ""_methods.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET></FRAMESET></HTML>"");
file.close();
for (int i = 0; i < attributes.length; i++) {
attribute_html.writeAttribute(attributes[i], ""class"" + i);
}
}",0
600,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
601,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0
602,"public static final String[] DEFAULT_IGNORED_PACKAGES = { ""java."", ""javax."", ""sun."" };",0
603,"public ClassLoader(final String[] ignored_packages) {
this.ignored_packages = ignored_packages;
}",0
604,"public ClassLoader(final String[] ignored_packages) {
this.ignored_packages = ignored_packages;
}",0
605,"public InputStream getInputStream(final String name, final String suffix) throws IOException {
InputStream is = null;
try {
is = getClass().getClassLoader().getResourceAsStream(name + suffix);
} catch (Exception e) {
}
if (is != null) {
return is;
}
return getClassFile(name, suffix).getInputStream();
}",0
606,"@Deprecated
protected List<JavaClass> vec = new ArrayList<>();",0
607,"private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constant_pool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
String field_name = constant_pool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(class_name)) {
buf.append(""<A HREF=\"""").append(class_name).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constant_html.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(index, Const.CONSTANT_NameAndType)));
ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constant_pool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
String[] args = Utility.methodSignatureArgumentTypes(signature, false);
String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
int dimensions = bytes.readByte();
buf.append(constant_html.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0
608,"CodeHTML(final String dir, final String class_name, final Method[] methods, final ConstantPool constant_pool, final ConstantHTML constant_html) throws IOException {
this.class_name = class_name;
this.constant_pool = constant_pool;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_code.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\"">"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</BODY></HTML>"");
file.close();
}",0
609,"private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constant_pool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
String field_name = constant_pool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(class_name)) {
buf.append(""<A HREF=\"""").append(class_name).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constant_html.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(index, Const.CONSTANT_NameAndType)));
ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constant_pool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
String[] args = Utility.methodSignatureArgumentTypes(signature, false);
String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
int dimensions = bytes.readByte();
buf.append(constant_html.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0
610,"ConstantHTML(final String dir, final String class_name, final String class_package, final Method[] methods, final ConstantPool constant_pool) throws IOException {
this.class_name = class_name;
this.class_package = class_package;
this.constant_pool = constant_pool;
this.methods = methods;
constants = constant_pool.getConstantPool();
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
constant_ref = new String[constants.length];
constant_ref[0] = ""&lt;unknown&gt;"";
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
for (int i = 1; i < constants.length; i++) {
if (i % 2 == 0) {
file.print(""<TR BGCOLOR=\""#C0C0C0\""><TD>"");
} else {
file.print(""<TR BGCOLOR=\""#A0A0A0\""><TD>"");
}
if (constants[i] != null) {
writeConstant(i);
}
file.print(""</TD></TR>\n"");
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0
611,"MethodHTML(final String dir, final String class_name, final Method[] methods, final Field[] fields, final ConstantHTML constant_html, final AttributeHTML attribute_html) throws IOException {
this.class_name = class_name;
this.attribute_html = attribute_html;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_methods.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
file.println(""<TR><TH ALIGN=LEFT>Access&nbsp;flags</TH><TH ALIGN=LEFT>Type</TH>"" + ""<TH ALIGN=LEFT>Field&nbsp;name</TH></TR>"");
for (Field field : fields) {
writeField(field);
}
file.println(""</TABLE>"");
file.println(""<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags</TH>"" + ""<TH ALIGN=LEFT>Return&nbsp;type</TH><TH ALIGN=LEFT>Method&nbsp;name</TH>"" + ""<TH ALIGN=LEFT>Arguments</TH></TR>"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0
612,"public static void main(final String[] args) {
try {
UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
} catch (Exception e) {
e.printStackTrace();
}
new GraphicalVerifier();
}",0
613,private final boolean packFrame = false;,0
614,"@Override
public void update(final String classname) {
System.gc();
for (int i = 0; i < indent; i++) {
System.out.print("" "");
}
System.out.println(classname);
indent += 1;
Verifier v = VerifierFactory.getVerifier(classname);
VerificationResult vr;
vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 1:\n"" + vr);
}
vr = v.doPass2();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 2:\n"" + vr);
}
if (vr == VerificationResult.VR_OK) {
try {
JavaClass jc = Repository.lookupClass(v.getClassName());
for (int i = 0; i < jc.getMethods().length; i++) {
vr = v.doPass3a(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3a, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
vr = v.doPass3b(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3b, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
}
} catch (ClassNotFoundException e) {
System.err.println(""Could not find class "" + v.getClassName() + "" in Repository"");
}
}
indent -= 1;
}",0
615,"private void jbInit() throws Exception {
contentPane = (JPanel) this.getContentPane();
contentPane.setLayout(cardLayout1);
this.setJMenuBar(jMenuBar1);
this.setSize(new Dimension(708, 451));
this.setTitle(""JustIce"");
jPanel1.setMinimumSize(new Dimension(100, 100));
jPanel1.setPreferredSize(new Dimension(100, 100));
jPanel1.setLayout(gridLayout1);
jSplitPane2.setOrientation(JSplitPane.VERTICAL_SPLIT);
jPanel2.setLayout(gridLayout2);
jPanel3.setMinimumSize(new Dimension(200, 100));
jPanel3.setPreferredSize(new Dimension(400, 400));
jPanel3.setLayout(gridLayout4);
messagesPanel.setMinimumSize(new Dimension(100, 100));
messagesPanel.setLayout(gridLayout3);
jPanel2.setMinimumSize(new Dimension(200, 100));
jMenu1.setText(""File"");
jScrollPane1.getViewport().setBackground(Color.red);
messagesScrollPane.getViewport().setBackground(Color.red);
messagesScrollPane.setPreferredSize(new Dimension(10, 10));
classNamesJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
@Override
public void valueChanged(final ListSelectionEvent e) {
classNamesJList_valueChanged(e);
}
});
classNamesJList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
jScrollPane3.setBorder(BorderFactory.createLineBorder(Color.black));
jScrollPane3.setPreferredSize(new Dimension(100, 100));
gridLayout4.setRows(4);
gridLayout4.setColumns(1);
gridLayout4.setHgap(1);
jScrollPane4.setBorder(BorderFactory.createLineBorder(Color.black));
jScrollPane4.setPreferredSize(new Dimension(100, 100));
pass1TextPane.setBorder(BorderFactory.createRaisedBevelBorder());
pass1TextPane.setToolTipText("""");
pass1TextPane.setEditable(false);
pass2TextPane.setBorder(BorderFactory.createRaisedBevelBorder());
pass2TextPane.setEditable(false);
messagesTextPane.setBorder(BorderFactory.createRaisedBevelBorder());
messagesTextPane.setEditable(false);
newFileMenuItem.setText(""New..."");
newFileMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(78, InputEvent.CTRL_MASK, true));
newFileMenuItem.addActionListener(new java.awt.event.ActionListener() {
@Override
public void actionPerformed(final ActionEvent e) {
newFileMenuItem_actionPerformed(e);
}
});
pass3aTextPane.setEditable(false);
pass3bTextPane.setEditable(false);
pass3aJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
@Override
public void valueChanged(final ListSelectionEvent e) {
pass3aJList_valueChanged(e);
}
});
pass3bJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
@Override
public void valueChanged(final ListSelectionEvent e) {
pass3bJList_valueChanged(e);
}
});
jMenu2.setText(""Help"");
whatisMenuItem.setText(""What is..."");
whatisMenuItem.addActionListener(new java.awt.event.ActionListener() {
@Override
public void actionPerformed(final ActionEvent e) {
whatisMenuItem_actionPerformed(e);
}
});
aboutMenuItem.setText(""About"");
aboutMenuItem.addActionListener(new java.awt.event.ActionListener() {
@Override
public void actionPerformed(final ActionEvent e) {
aboutMenuItem_actionPerformed(e);
}
});
jSplitPane2.add(messagesPanel, JSplitPane.BOTTOM);
messagesPanel.add(messagesScrollPane, null);
messagesScrollPane.getViewport().add(messagesTextPane, null);
jSplitPane2.add(jPanel3, JSplitPane.TOP);
jPanel3.add(jScrollPane3, null);
jScrollPane3.getViewport().add(pass1TextPane, null);
jPanel3.add(jScrollPane4, null);
jPanel3.add(jSplitPane3, null);
jSplitPane3.add(jScrollPane2, JSplitPane.LEFT);
jScrollPane2.getViewport().add(pass3aJList, null);
jSplitPane3.add(jScrollPane5, JSplitPane.RIGHT);
jScrollPane5.getViewport().add(pass3aTextPane, null);
jPanel3.add(jSplitPane4, null);
jSplitPane4.add(jScrollPane6, JSplitPane.LEFT);
jScrollPane6.getViewport().add(pass3bJList, null);
jSplitPane4.add(jScrollPane7, JSplitPane.RIGHT);
jScrollPane7.getViewport().add(pass3bTextPane, null);
jScrollPane4.getViewport().add(pass2TextPane, null);
jSplitPane1.add(jPanel2, JSplitPane.TOP);
jPanel2.add(jScrollPane1, null);
jSplitPane1.add(jPanel1, JSplitPane.BOTTOM);
jPanel1.add(jSplitPane2, null);
jScrollPane1.getViewport().add(classNamesJList, null);
jMenuBar1.add(jMenu1);
jMenuBar1.add(jMenu2);
contentPane.add(jSplitPane1, ""jSplitPane1"");
jMenu1.add(newFileMenuItem);
jMenu2.add(whatisMenuItem);
jMenu2.add(aboutMenuItem);
jSplitPane2.setDividerLocation(300);
jSplitPane3.setDividerLocation(150);
jSplitPane4.setDividerLocation(150);
}",0
616,private final IvjEventHandler ivjEventHandler = new IvjEventHandler();,0
617,"public LocalVariablesInfo getLocalVariablesInfo(final int method_nr) {
if (this.verify() != VerificationResult.VR_OK) {
return null;
}
if (method_nr < 0 || method_nr >= localVariablesInfos.length) {
throw new AssertionViolatedException(""Method number out of range."");
}
return localVariablesInfos[method_nr];
}",0
618,"@Override
public void visitField(final Field obj) {
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isFinal() && obj.isVolatile()) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isStatic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_STATIC modifier set but hasn't!"");
}
if (!obj.isFinal()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_FINAL modifier set but hasn't!"");
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_VOLATILE | Const.ACC_TRANSIENT)) > 0) {
addMessage(""Field '"" + tostring(obj) + ""' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED,"" + "" ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored)."");
}
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
String name = obj.getName();
if (!validFieldName(name)) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' has illegal name '"" + obj.getName() + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
try {
Type.getType(sig);
} catch (ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by '"" + tostring(obj) + ""'."", cfe);
}
String nameanddesc = name + sig;
if (field_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two fields (like '"" + tostring(obj) + ""') are allowed have same names and descriptors!"");
}
if (field_names.contains(name)) {
addMessage(""More than one field of name '"" + name + ""' detected (but with different type descriptors). This is very unusual."");
}
field_names_and_desc.add(nameanddesc);
field_names.add(name);
Attribute[] atts = obj.getAttributes();
for (Attribute att : atts) {
if ((!(att instanceof ConstantValue)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if (!(att instanceof ConstantValue)) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is not a ConstantValue and is therefore only of use for debuggers and such."");
}
}
}",0
619,"@Override
public void visitMethod(final Method obj) {
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
String name = obj.getName();
if (!validMethodName(name, true)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
Type t;
Type[] ts;
try {
t = Type.getReturnType(sig);
ts = Type.getArgumentTypes(sig);
} catch (ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by Method '"" + tostring(obj) + ""'."", cfe);
}
Type act = t;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has a return type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
for (Type element : ts) {
act = element;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has an argument type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
}
if (name.equals(Const.STATIC_INITIALIZER_NAME) && (ts.length != 0)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."" + "" Its name resembles the class or interface initialization method"" + "" which it isn't because of its arguments (==descriptor)."");
}
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isAbstract()) {
if (obj.isFinal()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_FINAL modifier set."");
}
if (obj.isNative()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_NATIVE modifier set."");
}
if (obj.isPrivate()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_PRIVATE modifier set."");
}
if (obj.isStatic()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STATIC modifier set."");
}
if (obj.isStrictfp()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STRICT modifier set."");
}
if (obj.isSynchronized()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_SYNCHRONIZED modifier set."");
}
}
if (name.equals(Const.CONSTRUCTOR_NAME)) {
// ..may have at most one of ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC set: is checked above.
if (obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isAbstract()) {
throw new ClassConstraintException(""Instance initialization method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set."");
}
}
} else {
if (!name.equals(Const.STATIC_INITIALIZER_NAME)) {
if (jc.getMajor() >= Const.MAJOR_1_8) {
if (!(obj.isPublic() ^ obj.isPrivate())) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have"" + "" exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set."");
}
if (obj.isProtected() || obj.isFinal() || obj.isSynchronized() || obj.isNative()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isAbstract()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_ABSTRACT modifier set but hasn't!"");
}
if (obj.isPrivate() || obj.isProtected() || obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isStrictfp()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED,"" + "" ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set."");
}
}
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_SYNCHRONIZED | Const.ACC_NATIVE | Const.ACC_ABSTRACT | Const.ACC_STRICT)) > 0) {
addMessage(""Method '"" + tostring(obj) + ""' has access flag(s) other than"" + "" ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,"" + "" ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored)."");
}
String nameanddesc = name + sig;
if (method_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two methods (like '"" + tostring(obj) + ""') are allowed have same names and desciptors!"");
}
method_names_and_desc.add(nameanddesc);
Attribute[] atts = obj.getAttributes();
int num_code_atts = 0;
for (Attribute att : atts) {
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is neither Code nor Exceptions and is therefore only of use for debuggers and such."");
}
if ((att instanceof Code) && (obj.isNative() || obj.isAbstract())) {
throw new ClassConstraintException(""Native or abstract methods like '"" + tostring(obj) + ""' must not have a Code attribute like '"" + tostring(att) + ""'."");
}
if (att instanceof Code) {
num_code_atts++;
}
}
if (!obj.isNative() && !obj.isAbstract() && num_code_atts != 1) {
throw new ClassConstraintException(""Non-native, non-abstract methods like '"" + tostring(obj) + ""' must have exactly one Code attribute (found: "" + num_code_atts + "")."");
}
}",0
620,"@Deprecated
protected static UninitializedObjectType _this;",0
621,"@Override
public void visitGETFIELD(final GETFIELD o) {
try {
Type objectref = stack().peek();
if (!((objectref instanceof ObjectType) || (objectref == Type.NULL))) {
constraintViolated(o, ""Stack top should be an object reference that's not an array reference, but is '"" + objectref + ""'."");
}
String field_name = o.getFieldName(cpg);
JavaClass jc = Repository.lookupClass(getObjectType(o).getClassName());
Field[] fields = jc.getFields();
Field f = null;
for (Field field : fields) {
if (field.getName().equals(field_name)) {
Type f_type = Type.getType(field.getSignature());
Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
break;
}
}
}
if (f == null) {
JavaClass[] superclasses = jc.getSuperClasses();
outer: for (JavaClass superclass : superclasses) {
fields = superclass.getFields();
for (Field field : fields) {
if (field.getName().equals(field_name)) {
Type f_type = Type.getType(field.getSignature());
Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
if ((f.getAccessFlags() & (Const.ACC_PUBLIC | Const.ACC_PROTECTED)) == 0) {
f = null;
}
break outer;
}
}
}
}
if (f == null) {
throw new AssertionViolatedException(""Field '"" + field_name + ""' not found in "" + jc.getClassName());
}
}
if (f.isProtected()) {
ObjectType classtype = getObjectType(o);
ObjectType curr = ObjectType.getInstance(mg.getClassName());
if (classtype.equals(curr) || curr.subclassOf(classtype)) {
Type t = stack().peek();
if (t == Type.NULL) {
return;
}
if (!(t instanceof ObjectType)) {
constraintViolated(o, ""The 'objectref' must refer to an object that's not an array. Found instead: '"" + t + ""'."");
}
ObjectType objreftype = (ObjectType) t;
if (!(objreftype.equals(curr) || objreftype.subclassOf(curr))) {
// TODO: One day move to Staerk-et-al's ""Set of object types"" instead of ""wider"" object types
}
}
}
// TODO: Could go into Pass 3a.
if (f.isStatic()) {
constraintViolated(o, ""Referenced field '"" + f + ""' is static which it shouldn't be."");
}
} catch (ClassNotFoundException e) {
// FIXME: maybe not the best way to handle this
throw new AssertionViolatedException(""Missing class: "" + e, e);
}
}",0
622,"@Override
public void visitINVOKEINTERFACE(final INVOKEINTERFACE o) {
int count = o.getCount();
if (count == 0) {
constraintViolated(o, ""The 'count' argument must not be 0."");
}
// TODO: Do we want to do anything with it?
Type t = o.getType(cpg);
if (t instanceof ObjectType) {
String name = ((ObjectType) t).getClassName();
Verifier v = VerifierFactory.getVerifier(name);
VerificationResult vr = v.doPass2();
if (vr.getStatus() != VerificationResult.VERIFIED_OK) {
constraintViolated(o, ""Class '"" + name + ""' is referenced, but cannot be loaded and resolved: '"" + vr + ""'."");
}
}
Type[] argtypes = o.getArgumentTypes(cpg);
int nargs = argtypes.length;
for (int i = nargs - 1; i >= 0; i--) {
Type fromStack = stack().peek((nargs - 1) - i);
Type fromDesc = argtypes[i];
if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {
fromDesc = Type.INT;
}
if (!fromStack.equals(fromDesc)) {
if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {
ReferenceType rFromStack = (ReferenceType) fromStack;
// TODO: This can only be checked when using Staerk-et-al's ""set of object types""
referenceTypeIsInitialized(o, rFromStack);
} else {
constraintViolated(o, ""Expecting a '"" + fromDesc + ""' but found a '"" + fromStack + ""' on the stack."");
}
}
}
Type objref = stack().peek(nargs);
if (objref == Type.NULL) {
return;
}
if (!(objref instanceof ReferenceType)) {
constraintViolated(o, ""Expecting a reference type as 'objectref' on the stack, not a '"" + objref + ""'."");
}
referenceTypeIsInitialized(o, (ReferenceType) objref);
if (!(objref instanceof ObjectType)) {
if (!(objref instanceof ArrayType)) {
constraintViolated(o, ""Expecting an ObjectType as 'objectref' on the stack, not a '"" + objref + ""'."");
} else {
objref = GENERIC_ARRAY;
}
}
// TODO: This can only be checked if we're using Staerk-et-al's ""set of object types""
int counted_count = 1;
for (int i = 0; i < nargs; i++) {
counted_count += argtypes[i].getSize();
}
if (count != counted_count) {
constraintViolated(o, ""The 'count' argument should probably read '"" + counted_count + ""' but is '"" + count + ""'."");
}
}",0
623,"@Override
public Object clone() {
LocalVariables lvs = new LocalVariables(locals.length);
for (int i = 0; i < locals.length; i++) {
lvs.locals[i] = this.locals[i];
}
return lvs;
}",0
624,"@Override
public Object clone() {
OperandStack newstack = new OperandStack(this.maxStack);
@SuppressWarnings(""unchecked"")
final ArrayList<Type> clone = (ArrayList<Type>) this.stack.clone();
newstack.stack = clone;
return newstack;
}",0
625,"@Override
public int compare(Object o1, Object o2) {
int compareCode = 0;
try {
Comparable s1 = (Comparable) this.stringEncoder.encode(o1);
Comparable s2 = (Comparable) this.stringEncoder.encode(o2);
compareCode = s1.compareTo(s2);
} catch (EncoderException ee) {
compareCode = 0;
}
return compareCode;
}",0
626,protected final byte PAD = PAD_DEFAULT;,0
627,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
628,"private static byte[] getBytes(String string, Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
629,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
630,"private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) {
int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
String saltString = m.group(4);
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
631,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
632,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
633,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
634,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
635,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
636,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
637,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
638,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
639,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
640,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
641,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
642,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
643,"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",0
644,"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",0
645,"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage());
}
}",0
646,"public static byte[] md5(String data) {
return md5(data.getBytes());
}",0
647,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
648,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
649,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
650,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
651,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
652,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
653,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
654,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == '%') {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid URL encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
655,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write('%');
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
656,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
657,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
658,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
659,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
660,protected final byte PAD = PAD_DEFAULT;,0
661,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
662,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
663,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
664,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
665,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
666,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
667,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
668,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
669,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
670,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
671,protected final byte PAD = PAD_DEFAULT;,0
672,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
673,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
674,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
675,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
676,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
677,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
678,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
679,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0
680,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
681,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
682,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
683,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
684,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
685,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
686,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
687,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
688,"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",0
689,"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",0
690,"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage());
}
}",0
691,"public static byte[] sha512(String data) {
return sha512(data.getBytes());
}",0
692,"public static byte[] sha384(String data) {
return sha384(data.getBytes());
}",0
693,"public static byte[] md5(String data) {
return md5(data.getBytes());
}",0
694,"public static byte[] sha(String data) {
return sha(data.getBytes());
}",0
695,"public static byte[] sha256(String data) {
return sha256(data.getBytes());
}",0
696,"private String cleanInput(String input) {
if (input == null) {
return null;
}
input = input.trim();
if (input.length() == 0) {
return null;
}
return input.toUpperCase();
}",0
697,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase();
}
char[] inwd = txt.toUpperCase().toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
698,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase();
}
char[] inwd = txt.toUpperCase().toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
699,"public RefinedSoundex(char[] mapping) {
this.soundexMapping = mapping;
}",0
700,"public static final char[] US_ENGLISH_MAPPING = ""01360240043788015936020505"".toCharArray();",0
701,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0
702,"static String clean(String str) {
if (str == null || str.length() == 0) {
return str;
}
int len = str.length();
char[] chars = new char[len];
int count = 0;
for (int i = 0; i < len; i++) {
if (Character.isLetter(str.charAt(i))) {
chars[count++] = str.charAt(i);
}
}
if (count == len) {
return str.toUpperCase();
}
return new String(chars, 0, count).toUpperCase();
}",0
703,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
704,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
705,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
706,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
707,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
708,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
709,protected static byte ESCAPE_CHAR = '%';,0
710,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write('%');
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
711,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == '%') {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid URL encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
712,protected static byte ESCAPE_CHAR = '%';,0
713,protected final byte PAD = PAD_DEFAULT;,0
714,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
715,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
716,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
717,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
718,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
719,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
720,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
721,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
722,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
723,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
724,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
725,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
726,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
727,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
728,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
729,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
730,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
731,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
732,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
733,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
734,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
735,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
736,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
737,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
738,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(languages);
for (String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0
739,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0
740,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
741,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
742,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
743,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
744,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
745,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
746,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
747,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
748,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
749,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
750,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
751,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
752,protected final byte PAD = PAD_DEFAULT;,0
753,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
754,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
755,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
756,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
757,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
758,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
759,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
760,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
761,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
762,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
763,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
764,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
765,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
766,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
767,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
768,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0
769,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
770,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
771,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
772,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
773,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0
774,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0
775,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
776,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
777,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
778,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
779,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
780,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
781,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
782,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
783,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
784,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
785,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
786,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
787,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
788,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
789,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
790,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
791,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0
792,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(languages);
for (String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0
793,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
794,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
795,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
796,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
797,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
798,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
799,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
800,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
801,protected final byte PAD = PAD_DEFAULT;,0
802,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
803,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
804,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
805,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
806,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
807,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
808,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
809,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
810,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
811,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
812,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
813,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
814,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
815,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
816,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
817,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
818,"@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = input[inPos++];
if (b == pad) {
context.eof = true;
break;
}
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus > 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 1:
validateTrailingCharacters();
case 2:
validateCharacter(MASK_2BITS, context);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
validateTrailingCharacters();
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
validateCharacter(MASK_4BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
validateCharacter(MASK_1BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
validateTrailingCharacters();
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
validateCharacter(MASK_3BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
default:
throw new IllegalStateException(""Impossible modulus "" + context.modulus);
}
}
}",0
819,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
820,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
821,"private static void packInt(final int value, final byte[] dst, final int off, final int len) {
for (int i = 0; i < len; i++) {
dst[off + i] = (byte) (value >>> i * Byte.SIZE);
}
}",0
822,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0
823,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0
824,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0
825,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0
826,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
827,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
828,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0
829,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0
830,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0
831,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
832,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
833,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
834,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
835,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0
836,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
837,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
838,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0
839,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_START + c0] ^ T[T8_6_START + c1]) ^ (T[T8_5_START + c2] ^ T[T8_4_START + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_START + c4] ^ T[T8_2_START + c5]) ^ (T[T8_1_START + c6] ^ T[T8_0_START + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
840,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_START + c0] ^ T[T8_6_START + c1]) ^ (T[T8_5_START + c2] ^ T[T8_4_START + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_START + c4] ^ T[T8_2_START + c5]) ^ (T[T8_1_START + c6] ^ T[T8_0_START + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
841,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
}
if (other == ANY_LANGUAGE) {
return other;
}
final SomeLanguages someLanguages = (SomeLanguages) other;
final Set<String> set = new HashSet<>(languages);
set.addAll(someLanguages.languages);
return from(set);
}",0
842,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
}
if (other == ANY_LANGUAGE) {
return this;
}
final SomeLanguages someLanguages = (SomeLanguages) other;
return from(languages.stream().filter(lang -> someLanguages.languages.contains(lang)).collect(Collectors.toSet()));
}",0
843,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
844,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return new Base64(0, BaseNCodec.getChunkSeparator(), false, decodingPolicy).decode(bytes);
}",0
845,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0
846,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
return buffer.array();
}",0
847,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
848,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
849,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
final int bytesLength = bytes.length;
if (strict) {
int pos = 1;
for (int i = 0; i < bytesLength - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytesLength - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytesLength - 2; i < bytesLength; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytesLength - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
850,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
851,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
852,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
853,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
854,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
855,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
856,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
857,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
858,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
859,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0
860,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0
861,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
862,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
863,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
864,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
865,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
866,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
867,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
868,protected static byte ESCAPE_CHAR = '%';,0
869,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
870,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
871,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
872,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
873,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
874,protected final byte PAD = PAD_DEFAULT;,0
875,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
876,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
877,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
878,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
879,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
880,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
881,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
882,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
883,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
884,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
885,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
886,"@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = input[inPos++];
if (b == pad) {
context.eof = true;
break;
}
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus > 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 1:
validateTrailingCharacters();
case 2:
validateCharacter(MASK_2BITS, context);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
validateTrailingCharacters();
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
validateCharacter(MASK_4BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
validateCharacter(MASK_1BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
validateTrailingCharacters();
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
validateCharacter(MASK_3BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
default:
throw new IllegalStateException(""Impossible modulus "" + context.modulus);
}
}
}",0
887,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
888,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0
889,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0
890,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0
891,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0
892,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
893,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0
894,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
895,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
896,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0
897,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
898,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
899,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
900,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0
901,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
902,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
903,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0
904,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0
905,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
906,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
907,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0
908,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0
909,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return new Base64(0, BaseNCodec.getChunkSeparator(), false, decodingPolicy).decode(bytes);
}",0
910,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
911,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else {
if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
}
return buffer.array();
}",0
912,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0
913,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
914,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
915,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
916,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
917,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
918,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
919,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
920,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
921,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
922,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
923,protected final byte PAD = PAD_DEFAULT;,0
924,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
925,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
926,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
927,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
928,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
929,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
930,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
931,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
932,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
933,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
934,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
935,protected final String charset;,0
936,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
937,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
938,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
939,"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",0
940,"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",0
941,"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage());
}
}",0
942,"public static byte[] md5(String data) {
return md5(data.getBytes());
}",0
943,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
944,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
945,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
946,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
947,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
948,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
949,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
950,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == '%') {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid URL encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
951,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write('%');
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
952,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
953,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
954,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
955,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0
956,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0
957,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0
958,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0
959,"public static int hash32(final String text) {
final byte[] bytes = text.getBytes();
return hash32(bytes, bytes.length);
}",0
960,"private static long[] hash128x64(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0
961,"private static long[] hash128x64(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0
962,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
963,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
964,"public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0
965,"public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0
966,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0
967,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
968,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
969,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0
970,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0
971,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
972,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
973,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else {
if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
}
return buffer.array();
}",0
974,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0
975,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
976,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
977,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
978,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
979,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
980,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
981,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
switch(modulus) {
case 2:
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3:
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
}
}
}",0
982,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
switch(modulus) {
case 2:
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3:
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
}
}
}",0
983,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
byte b = lineSeparator[lineSeparator.length - 1];
if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
984,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
byte b = lineSeparator[lineSeparator.length - 1];
if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
985,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
986,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
987,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0
988,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0
989,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
990,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
991,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
992,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
993,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
994,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
995,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
996,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
997,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
998,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
999,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1000,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1001,protected final byte PAD = PAD_DEFAULT;,0
1002,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1003,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
1004,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1005,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1006,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1007,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1008,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1009,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
1010,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1011,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1012,"@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = input[inPos++];
if (b == pad) {
context.eof = true;
break;
}
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus > 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 1:
validateTrailingCharacters();
case 2:
validateCharacter(MASK_2BITS, context);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
validateTrailingCharacters();
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
validateCharacter(MASK_4BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
validateCharacter(MASK_1BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
validateTrailingCharacters();
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
validateCharacter(MASK_3BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
default:
throw new IllegalStateException(""Impossible modulus "" + context.modulus);
}
}
}",0
1013,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
1014,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1015,"private static void packInt(final int value, final byte[] dst, final int off, final int len) {
for (int i = 0; i < len; i++) {
dst[off + i] = (byte) (value >>> i * Byte.SIZE);
}
}",0
1016,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0
1017,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0
1018,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0
1019,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0
1020,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
1021,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
1022,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0
1023,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
1024,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0
1025,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
1026,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0
1027,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
1028,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0
1029,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
1030,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
1031,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0
1032,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0
1033,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
1034,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
1035,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
}
if (other == ANY_LANGUAGE) {
return this;
}
final SomeLanguages someLanguages = (SomeLanguages) other;
return from(languages.stream().filter(lang -> someLanguages.languages.contains(lang)).collect(Collectors.toSet()));
}",0
1036,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
}
if (other == ANY_LANGUAGE) {
return other;
}
final SomeLanguages someLanguages = (SomeLanguages) other;
final Set<String> set = new HashSet<>(languages);
set.addAll(someLanguages.languages);
return from(set);
}",0
1037,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1038,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return new Base64(0, BaseNCodec.getChunkSeparator(), false, decodingPolicy).decode(bytes);
}",0
1039,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
return buffer.array();
}",0
1040,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0
1041,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1042,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1043,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
final int bytesLength = bytes.length;
if (strict) {
int pos = 1;
for (int i = 0; i < bytesLength - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytesLength - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytesLength - 2; i < bytesLength; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytesLength - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
1044,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1045,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1046,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1047,protected final byte PAD = PAD_DEFAULT;,0
1048,"private static byte[] getBytes(String string, Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1049,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1050,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
1051,"private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) {
int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
String saltString = m.group(4);
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
1052,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
1053,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1054,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1055,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1056,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1057,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1058,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
1059,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1060,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1061,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
1062,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1063,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1064,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0
1065,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
1066,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
1067,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0
1068,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0
1069,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1070,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1071,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1072,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1073,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
1074,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1075,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1076,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1077,protected final byte PAD = PAD_DEFAULT;,0
1078,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1079,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1080,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
1081,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
1082,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
1083,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
1084,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
1085,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
1086,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1087,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1088,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1089,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1090,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
1091,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1092,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1093,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1094,protected final byte PAD = PAD_DEFAULT;,0
1095,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1096,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1097,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
1098,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
1099,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
1100,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
1101,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
1102,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
1103,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1104,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1105,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1106,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1107,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
1108,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1109,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1110,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1111,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
1112,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1113,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1114,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0
1115,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
1116,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0
1117,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0
1118,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0
1119,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1120,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1121,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
int expectedEncodingBytes = expectedEncodingBytes(bytes);
boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0
1122,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else {
if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
}
return buffer.array();
}",0
1123,private final byte ESCAPE_CHAR = '%';,0
1124,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1125,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1126,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1127,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0
1128,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1129,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1130,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1131,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1132,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1133,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1134,protected final byte PAD = PAD_DEFAULT;,0
1135,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1136,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
1137,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1138,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1139,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1140,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1141,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1142,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
1143,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1144,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1145,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1146,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1147,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1148,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1149,protected final byte PAD = PAD_DEFAULT;,0
1150,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1151,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0
1152,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
1153,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1154,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1155,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1156,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1157,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1158,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
1159,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1160,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1161,protected final byte PAD = PAD_DEFAULT;,0
1162,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1163,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0
1164,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0
1165,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0
1166,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
1167,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0
1168,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0
1169,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0
1170,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0
1171,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0
1172,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0
1173,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0
1174,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0
1175,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1176,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0
1177,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0
1178,"public int compareTo(Phoneme o) {
for (int i = 0; i < phonemeText.length(); i++) {
if (i >= o.phonemeText.length()) {
return +1;
}
int c = phonemeText.charAt(i) - o.phonemeText.charAt(i);
if (c != 0) {
return c;
}
}
if (phonemeText.length() < o.phonemeText.length()) {
return -1;
}
return 0;
}",0
1179,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1180,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1181,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages someLanguages = (SomeLanguages) other;
final Set<String> set = new HashSet<>(languages);
set.addAll(someLanguages.languages);
return from(set);
}
}",0
1182,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 2:
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 3:
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 4:
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
context.buffer[context.pos++] = PAD;
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0
1183,"private static int[] desSetKey(byte[] key) {
int[] schedule = new int[32];
int c = fourBytesToInt(key, 0);
int d = fourBytesToInt(key, 4);
int[] results = new int[2];
permOp(d, c, 4, 0xf0f0f0f, results);
d = results[0];
c = results[1];
c = hPermOp(c, -2, 0xcccc0000);
d = hPermOp(d, -2, 0xcccc0000);
permOp(d, c, 1, 0x55555555, results);
d = results[0];
c = results[1];
permOp(c, d, 8, 0xff00ff, results);
c = results[0];
d = results[1];
permOp(d, c, 1, 0x55555555, results);
d = results[0];
c = results[1];
d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;
c &= 0xfffffff;
int j = 0;
for (int i = 0; i < 16; i++) {
if (SHIFT2[i]) {
c = c >>> 2 | c << 26;
d = d >>> 2 | d << 26;
} else {
c = c >>> 1 | c << 27;
d = d >>> 1 | d << 27;
}
c &= 0xfffffff;
d &= 0xfffffff;
int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] | SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] | SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];
int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] | SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];
schedule[j++] = (t << 16 | s & 0xffff) & 0xffffffff;
s = s >>> 16 | t & 0xffff0000;
s = s << 4 | s >>> 28;
schedule[j++] = s & 0xffffffff;
}
return schedule;
}",1
1184,"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus >= 2) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
}
}
}",1
1185,"public static String crypt(byte[] original, String salt) {
if (salt == null) {
Random randomGenerator = new Random();
int numSaltChars = SALT_CHARS.length;
salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
} else if (!salt.matches(""^["" + B64.B64T + ""]{2,}$"")) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
for (; salt.length() < 2; salt = salt + ""A"") {
}
StringBuilder buffer = new StringBuilder(""             "");
char charZero = salt.charAt(0);
char charOne = salt.charAt(1);
buffer.setCharAt(0, charZero);
buffer.setCharAt(1, charOne);
int eSwap0 = CON_SALT[charZero];
int eSwap1 = CON_SALT[charOne] << 4;
byte[] key = new byte[8];
for (int i = 0; i < key.length; i++) {
key[i] = 0;
}
for (int i = 0; i < key.length && i < original.length; i++) {
int iChar = original[i];
key[i] = (byte) (iChar << 1);
}
int[] schedule = desSetKey(key);
int[] out = body(schedule, eSwap0, eSwap1);
byte[] b = new byte[9];
intToFourBytes(out[0], b, 0);
intToFourBytes(out[1], b, 4);
b[8] = 0;
int i = 2;
int y = 0;
int u = 128;
for (; i < 13; i++) {
int j = 0;
int c = 0;
for (; j < 6; j++) {
c <<= 1;
if ((b[y] & u) != 0) {
c |= 0x1;
}
u >>>= 1;
if (u == 0) {
y++;
u = 128;
}
buffer.setCharAt(i, (char) COV2CHAR[c]);
}
}
return buffer.toString();
}",1
1186,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1
1187,protected static byte ESCAPE_CHAR = '%';,0
1188,"public String metaphone(final String txt) {
boolean hard = false;
final int txtLength = txt.length();
if (txt == null || txtLength == 0) {
return """";
}
if (txtLength == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
final StringBuilder local = new StringBuilder(40);
final StringBuilder code = new StringBuilder(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
final int wdsz = local.length();
int n = 0;
while (code.length() < this.getMaxCodeLen() && n < wdsz) {
final char symb = local.charAt(n);
if (symb != 'C' && isPreviousChar(local, n, symb)) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if (n == 0 && wdsz >= 3 && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && FRONTV.indexOf(local.charAt(n + 2)) >= 0) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if (n > 0 && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0 && !hard) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if (n > 0 && VARSON.indexOf(local.charAt(n - 1)) >= 0) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
default:
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",1
1189,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
// top 6 bits:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0
1190,"public final int end() {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0
1191,"@Deprecated
public static int hash32(final String data) {
final byte[] bytes = data.getBytes();
return hash32(bytes, 0, bytes.length, DEFAULT_SEED);
}",1
1192,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1193,private final Languages.LanguageSet languageSet;,1
1194,"private void run(String prefix, final MessageDigest messageDigest) throws IOException {
if (source == null) {
println(prefix, DigestUtils.digest(messageDigest, System.in));
return;
}
final File file = new File(source);
if (file.isFile()) {
println(prefix, DigestUtils.digest(messageDigest, file), source);
} else if (file.isDirectory()) {
run(prefix, messageDigest, file.listFiles());
} else {
final byte[] bytes = source.getBytes(Charset.defaultCharset());
println(prefix, DigestUtils.digest(messageDigest, bytes));
}
}",0
1195,"public Soundex(char[] mapping) {
this.soundexMapping = mapping;
}",1
1196,"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
final byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
final int result = DECODE_TABLE[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (context.eof && context.modulus != 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
context.ibitWorkArea = context.ibitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
case 3:
context.ibitWorkArea = context.ibitWorkArea >> 2;
buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
}
}
}",1
1197,private final byte ESCAPE_CHAR = '%';,1
1198,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
switch(modulus) {
case 2:
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3:
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
}
}
}",0
1199,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1200,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",1
1201,protected final byte PAD = PAD_DEFAULT;,0
1202,protected static byte ESCAPE_CHAR = '%';,1
1203,"public static byte[] sha384(String data) {
return sha384(data.getBytes());
}",1
1204,"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",1
1205,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
final int savedPos = context.pos;
switch(context.modulus) {
case 1:
// top 6 bits:
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
}
break;
case 2:
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",1
1206,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0
1207,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
byte b = lineSeparator[lineSeparator.length - 1];
if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1208,"private static int[] body(int[] schedule, int eSwap0, int eSwap1) {
int left = 0;
int right = 0;
int t = 0;
for (int j = 0; j < 25; j++) {
for (int i = 0; i < 32; i += 4) {
left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);
right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);
}
t = left;
left = right;
right = t;
}
t = right;
right = left >>> 1 | left << 31;
left = t >>> 1 | t << 31;
left &= 0xffffffff;
right &= 0xffffffff;
int[] results = new int[2];
permOp(right, left, 1, 0x55555555, results);
right = results[0];
left = results[1];
permOp(left, right, 8, 0xff00ff, results);
left = results[0];
right = results[1];
permOp(right, left, 2, 0x33333333, results);
right = results[0];
left = results[1];
permOp(left, right, 16, 65535, results);
left = results[0];
right = results[1];
permOp(right, left, 4, 0xf0f0f0f, results);
right = results[0];
left = results[1];
int[] out = new int[2];
out[0] = left;
out[1] = right;
return out;
}",1
1209,private final byte ESCAPE_CHAR = '%';,1
1210,"public String colognePhonetic(String text) {
if (text == null) {
return null;
}
final CologneInputBuffer input = new CologneInputBuffer(preprocess(text));
final CologneOutputBuffer output = new CologneOutputBuffer(input.length() * 2);
char nextChar;
final char CHAR_FIRST_POS = '/';
final char CHAR_IGNORE = '-';
char lastChar = CHAR_IGNORE;
char lastCode = CHAR_FIRST_POS;
char code;
char chr;
while (input.length() > 0) {
chr = input.removeNext();
if (input.length() > 0) {
nextChar = input.getNextChar();
} else {
nextChar = CHAR_IGNORE;
}
if (arrayContains(AEIJOUY, chr)) {
code = '0';
} else if (chr == 'H' || chr < 'A' || chr > 'Z') {
if (lastCode == CHAR_FIRST_POS) {
continue;
}
code = CHAR_IGNORE;
} else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {
code = '1';
} else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {
code = '2';
} else if (arrayContains(WFPV, chr)) {
code = '3';
} else if (arrayContains(GKQ, chr)) {
code = '4';
} else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {
code = '4';
input.addLeft('S');
} else if (chr == 'S' || chr == 'Z') {
code = '8';
} else if (chr == 'C') {
if (lastCode == CHAR_FIRST_POS) {
if (arrayContains(AHKLOQRUX, nextChar)) {
code = '4';
} else {
code = '8';
}
} else {
if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {
code = '8';
} else {
code = '4';
}
}
} else if (arrayContains(TDX, chr)) {
code = '8';
} else if (chr == 'R') {
code = '7';
} else if (chr == 'L') {
code = '5';
} else if (chr == 'M' || chr == 'N') {
code = '6';
} else {
code = chr;
throw new RuntimeException();
}
if (code != CHAR_IGNORE && (lastCode != code && (code != '0' || lastCode == CHAR_FIRST_POS) || code < '0' || code > '8')) {
output.addRight(code);
}
lastChar = chr;
lastCode = code;
}
return output.toString();
}",0
1211,"public static String crypt(byte[] original, String salt) {
if (salt == null) {
Random randomGenerator = new Random();
int numSaltChars = SALT_CHARS.length;
salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
} else if (!salt.matches(""^["" + B64.B64T + ""]{2,}$"")) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
for (; salt.length() < 2; salt = salt + ""A"") {
}
StringBuilder buffer = new StringBuilder(""             "");
char charZero = salt.charAt(0);
char charOne = salt.charAt(1);
buffer.setCharAt(0, charZero);
buffer.setCharAt(1, charOne);
int eSwap0 = CON_SALT[charZero];
int eSwap1 = CON_SALT[charOne] << 4;
byte[] key = new byte[8];
for (int i = 0; i < key.length; i++) {
key[i] = 0;
}
for (int i = 0; i < key.length && i < original.length; i++) {
int iChar = original[i];
key[i] = (byte) (iChar << 1);
}
int[] schedule = desSetKey(key);
int[] out = body(schedule, eSwap0, eSwap1);
byte[] b = new byte[9];
intToFourBytes(out[0], b, 0);
intToFourBytes(out[1], b, 4);
b[8] = 0;
int i = 2;
int y = 0;
int u = 128;
for (; i < 13; i++) {
int j = 0;
int c = 0;
for (; j < 6; j++) {
c <<= 1;
if ((b[y] & u) != 0) {
c |= 0x1;
}
u >>>= 1;
if (u == 0) {
y++;
u = 128;
}
buffer.setCharAt(i, (char) COV2CHAR[c]);
}
}
return buffer.toString();
}",0
1212,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0
1213,"public Base64(int lineLength, byte[] lineSeparator) {
this.lineLength = lineLength;
this.lineSeparator = lineSeparator;
if (lineLength > 0) {
this.encodeSize = 4 + lineSeparator.length;
} else {
this.encodeSize = 4;
}
this.decodeSize = encodeSize - 1;
if (containsBase64Byte(lineSeparator)) {
String sep;
try {
sep = new String(lineSeparator, ""UTF-8"");
} catch (UnsupportedEncodingException uee) {
sep = new String(lineSeparator);
}
throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
}
}",1
1214,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1215,"public static final char[] US_ENGLISH_MAPPING = ""01360240043788015936020505"".toCharArray();",1
1216,"public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
this.lineLength = lineLength;
this.lineSeparator = new byte[lineSeparator.length];
System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
if (lineLength > 0) {
this.encodeSize = 4 + lineSeparator.length;
} else {
this.encodeSize = 4;
}
this.decodeSize = this.encodeSize - 1;
if (containsBase64Byte(lineSeparator)) {
String sep;
try {
sep = new String(lineSeparator, ""UTF-8"");
} catch (UnsupportedEncodingException uee) {
sep = new String(lineSeparator);
}
throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
}
this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
}",1
1217,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1218,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1
1219,"private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) throws Exception {
int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Invalid salt value: null"");
}
Pattern p = Pattern.compile(""^\\$([56])\\$(rounds=(\\d+)\\$)?([\\.\\/a-zA-Z0-9]{1,16}).*"");
Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.valueOf(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
String saltString = m.group(4);
byte[] saltBytes = saltString.getBytes(""UTF-8"");
int saltLen = saltBytes.length;
MessageDigest ctx = MessageDigest.getInstance(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = MessageDigest.getInstance(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = MessageDigest.getInstance(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = MessageDigest.getInstance(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = MessageDigest.getInstance(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
StringBuilder buffer = new StringBuilder(saltPrefix + (roundsCustom ? ROUNDS_PREFIX + rounds + ""$"" : """") + saltString + ""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",1
1220,"public static byte[] sha512(String data) {
return sha512(data.getBytes());
}",1
1221,protected final byte PAD = '=';,1
1222,"public static long[] hash128(final String data) {
final byte[] origin = data.getBytes();
return hash128(origin, 0, origin.length, DEFAULT_SEED);
}",0
1223,"public static long hash64(final String text) {
final byte[] bytes = text.getBytes();
return hash64(bytes, bytes.length);
}",1
1224,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1225,"public static int hash32(final String text) {
final byte[] bytes = text.getBytes();
return hash32(bytes, bytes.length);
}",1
1226,"private void run(String prefix, final MessageDigest messageDigest) throws IOException {
if (inputs == null) {
println(prefix, DigestUtils.digest(messageDigest, System.in));
return;
}
for (String source : inputs) {
final File file = new File(source);
if (file.isFile()) {
println(prefix, DigestUtils.digest(messageDigest, file), source);
} else if (file.isDirectory()) {
run(prefix, messageDigest, file.listFiles());
} else {
final byte[] bytes = source.getBytes(Charset.defaultCharset());
println(prefix, DigestUtils.digest(messageDigest, bytes));
}
}
}",1
1227,protected static byte ESCAPE_CHAR = '%';,0
1228,"public static String crypt(byte[] original, String salt) {
if (salt == null) {
Random randomGenerator = new Random();
int numSaltChars = SALT_CHARS.length;
salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
} else if (!salt.matches(""^["" + B64.B64T + ""]{2,}$"")) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
for (; salt.length() < 2; salt = salt + ""A"") {
}
StringBuilder buffer = new StringBuilder(""             "");
char charZero = salt.charAt(0);
char charOne = salt.charAt(1);
buffer.setCharAt(0, charZero);
buffer.setCharAt(1, charOne);
int eSwap0 = CON_SALT[charZero];
int eSwap1 = CON_SALT[charOne] << 4;
byte[] key = new byte[8];
for (int i = 0; i < key.length; i++) {
key[i] = 0;
}
for (int i = 0; i < key.length && i < original.length; i++) {
int iChar = original[i];
key[i] = (byte) (iChar << 1);
}
int[] schedule = desSetKey(key);
int[] out = body(schedule, eSwap0, eSwap1);
byte[] b = new byte[9];
intToFourBytes(out[0], b, 0);
intToFourBytes(out[1], b, 4);
b[8] = 0;
int i = 2;
int y = 0;
int u = 128;
for (; i < 13; i++) {
int j = 0;
int c = 0;
for (; j < 6; j++) {
c <<= 1;
if ((b[y] & u) != 0) {
c |= 0x1;
}
u >>>= 1;
if (u == 0) {
y++;
u = 128;
}
buffer.setCharAt(i, (char) COV2CHAR[c]);
}
}
return buffer.toString();
}",0
1229,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
// top 6 bits:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0
1230,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",1
1231,"public Languages.LanguageSet guessLanguages(String input) {
// todo: locale?
String text = input.toLowerCase();
// System.out.println(""Testing text: '"" + text + ""'"");
Set<String> langs = new HashSet<String>(this.languages.getLanguages());
for (LangRule rule : this.rules) {
if (rule.matches(text)) {
if (rule.acceptOnMatch) {
langs.retainAll(rule.languages);
} else {
langs.removeAll(rule.languages);
}
// System.out.println(""Current languages: "" + langs);
} else {
}
}
Languages.LanguageSet ls = Languages.LanguageSet.from(langs);
return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;
}",1
1232,"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage(), e);
}
}",1
1233,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus) {
return;
}
ensureBufferSize(encodeSize);
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
if (lineLength > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BITS_PER_ENCODED_BYTE;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1234,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus) {
return;
}
ensureBufferSize(encodeSize);
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
if (lineLength > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BITS_PER_ENCODED_CHAR;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1235,"@Deprecated
public static long[] hash128(final String data) {
final byte[] bytes = data.getBytes();
return hash128(bytes, 0, bytes.length, DEFAULT_SEED);
}",1
1236,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}",0
1237,"public String metaphone(String txt) {
boolean hard = false;
if (txt == null || txt.length() == 0) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuilder local = new StringBuilder(40);
StringBuilder code = new StringBuilder(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while (code.length() < this.getMaxCodeLen() && n < wdsz) {
char symb = local.charAt(n);
if (symb != 'C' && isPreviousChar(local, n, symb)) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if (n == 0 && wdsz >= 3 && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && FRONTV.indexOf(local.charAt(n + 2)) >= 0) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if (n > 0 && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0 && !hard) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if (n > 0 && VARSON.indexOf(local.charAt(n - 1)) >= 0) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",1
1238,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1239,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
modulus = (++modulus) % 4;
x = x << 6;
switch(modulus) {
case 3:
x = x << 6;
case 0:
buf[pos++] = (byte) ((x >> 16) & 0xff);
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 8) & 0xff);
}
default:
eof = true;
return;
}
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (byte) ((++modulus) % 4);
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & 0xff);
buf[pos++] = (byte) ((x >> 8) & 0xff);
buf[pos++] = (byte) (x & 0xff);
}
}
}
}
}
}",0
1240,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",1
1241,"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize, context);
byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (context.eof && context.modulus != 0) {
ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
context.ibitWorkArea = context.ibitWorkArea >> 4;
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
case 3:
context.ibitWorkArea = context.ibitWorkArea >> 2;
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1242,"@SuppressWarnings(""boxing"")
@Override
public String toString() {
return String.format(""%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, "" + ""modulus=%s, pos=%s, readPos=%s]"", this.getClass().getSimpleName(), buffer, currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);
}",1
1243,"@Override
public String toString() {
return String.format(""%s[%s]"", super.toString(), args);
}",1
1244,"public static LanguageSet NO_LANGUAGES = new LanguageSet() {
@Override
public LanguageSet restrictTo(LanguageSet other) {
return this;
}
@Override
public boolean contains(String language) {
return false;
}
@Override
public boolean isSingleton() {
return false;
}
@Override
public String getAny() {
throw new NoSuchElementException(""Can't fetch any language from the empty language set."");
}
@Override
public boolean isEmpty() {
return true;
}
};",1
1245,"private static int[] desSetKey(byte[] key) {
int[] schedule = new int[32];
int c = fourBytesToInt(key, 0);
int d = fourBytesToInt(key, 4);
int[] results = new int[2];
permOp(d, c, 4, 0xf0f0f0f, results);
d = results[0];
c = results[1];
c = hPermOp(c, -2, 0xcccc0000);
d = hPermOp(d, -2, 0xcccc0000);
permOp(d, c, 1, 0x55555555, results);
d = results[0];
c = results[1];
permOp(c, d, 8, 0xff00ff, results);
c = results[0];
d = results[1];
permOp(d, c, 1, 0x55555555, results);
d = results[0];
c = results[1];
d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;
c &= 0xfffffff;
int j = 0;
for (int i = 0; i < 16; i++) {
if (SHIFT2[i]) {
c = c >>> 2 | c << 26;
d = d >>> 2 | d << 26;
} else {
c = c >>> 1 | c << 27;
d = d >>> 1 | d << 27;
}
c &= 0xfffffff;
d &= 0xfffffff;
int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] | SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] | SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];
int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] | SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];
schedule[j++] = (t << 16 | s & 0xffff) & 0xffffffff;
s = s >>> 16 | t & 0xffff0000;
s = s << 4 | s >>> 28;
schedule[j++] = s & 0xffffffff;
}
return schedule;
}",1
1246,"public static byte[] sha384(String data) {
return sha384(data.getBytes());
}",1
1247,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",1
1248,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase();
}
char[] inwd = txt.toUpperCase().toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",1
1249,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
eof = true;
return;
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buf[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
}",0
1250,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1
1251,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
modulus = (++modulus) % 4;
x = x << 6;
switch(modulus) {
case 3:
x = x << 6;
case 0:
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
}
default:
eof = true;
return;
}
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buf[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
}",1
1252,private final byte ESCAPE_CHAR = '%';,1
1253,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1254,"public static byte[] sha512(String data) {
return sha512(data.getBytes());
}",1
1255,"@SuppressWarnings(""boxing"")
@Override
public String toString() {
return String.format(""%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, modulus=%s, pos=%s, readPos=%s]"", this.getClass().getSimpleName(), buffer, currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);
}",0
1256,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",1
1257,"public static Mac getInitializedMac(final HmacAlgorithms algorithm, final byte[] key) {
return getInitializedMac(algorithm, key);
}",0
1258,protected static byte ESCAPE_CHAR = '%';,1
1259,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",1
1260,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1261,"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",1
1262,"private String cleanInput(String input) {
if (input == null) {
return null;
}
input = input.trim();
if (input.length() == 0) {
return null;
}
return input.toUpperCase();
}",1
1263,"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus >= 2) {
ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
context.lbitWorkArea = context.lbitWorkArea >> 4;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
context.lbitWorkArea = context.lbitWorkArea >> 1;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
context.lbitWorkArea = context.lbitWorkArea >> 6;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
context.lbitWorkArea = context.lbitWorkArea >> 3;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
}
}
}",0
1264,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
1265,"public static byte[] sha256(String data) {
return sha256(data.getBytes());
}",1
1266,"static String clean(String str) {
if (str == null || str.length() == 0) {
return str;
}
int len = str.length();
char[] chars = new char[len];
int count = 0;
for (int i = 0; i < len; i++) {
if (Character.isLetter(str.charAt(i))) {
chars[count++] = str.charAt(i);
}
}
if (count == len) {
return str.toUpperCase();
}
return new String(chars, 0, count).toUpperCase();
}",1
1267,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",1
1268,"public final int end() {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",1
1269,"private static int[] body(int[] schedule, int eSwap0, int eSwap1) {
int left = 0;
int right = 0;
int t = 0;
for (int j = 0; j < 25; j++) {
for (int i = 0; i < 32; i += 4) {
left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);
right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);
}
t = left;
left = right;
right = t;
}
t = right;
right = left >>> 1 | left << 31;
left = t >>> 1 | t << 31;
left &= 0xffffffff;
right &= 0xffffffff;
int[] results = new int[2];
permOp(right, left, 1, 0x55555555, results);
right = results[0];
left = results[1];
permOp(left, right, 8, 0xff00ff, results);
left = results[0];
right = results[1];
permOp(right, left, 2, 0x33333333, results);
right = results[0];
left = results[1];
permOp(left, right, 16, 65535, results);
left = results[0];
right = results[1];
permOp(right, left, 4, 0xf0f0f0f, results);
right = results[0];
left = results[1];
int[] out = new int[2];
out[0] = left;
out[1] = right;
return out;
}",1
1270,"public static byte[] decodeBase64(final String base64String) {
if (base64String == null) {
return null;
}
if ("""".equals(base64String)) {
return new byte[0];
}
return ApacheModifiedMiGBase64.decode(base64String.toCharArray());
}",1
1271,"@Deprecated
public static long[] hash128(final String data) {
final byte[] bytes = data.getBytes();
return hash128(bytes, 0, bytes.length, DEFAULT_SEED);
}",1
1272,"public static byte[] sha256(String data) {
return sha256(data.getBytes());
}",1
1273,"public RefinedSoundex(char[] mapping) {
this.soundexMapping = mapping;
}",1
1274,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
modulus = (++modulus) % 4;
x = x << 6;
switch(modulus) {
case 3:
x = x << 6;
case 0:
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
}
default:
eof = true;
return;
}
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buf[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
}",1
1275,"public static byte[] sha(String data) {
return sha(data.getBytes());
}",1
1276,"public long getEncodedLength(byte[] pArray) {
long len = ((pArray.length + unencodedBlockSize - 1) / unencodedBlockSize) * encodedBlockSize;
if (lineLength > 0) {
len += ((len + lineLength - 1) / lineLength) * chunkSeparatorLength;
}
return len;
}",1
1277,"public static byte[] md5(String data) {
return md5(data.getBytes());
}",1
1278,"public static long hash64(final String text) {
final byte[] bytes = text.getBytes();
return hash64(bytes, bytes.length);
}",1
1279,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
1280,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",1
1281,"public String caverphone(String txt) {
// NOTE: Version 1.0 of Caverphone is easily derivable from this code
if (txt == null || txt.length() == 0) {
return ""1111111111"";
}
txt = txt.toLowerCase();
txt = txt.replaceAll(""[^a-z]"", """");
txt = txt.replaceAll(""e$"", """");
txt = txt.replaceAll(""^cough"", ""cou2f"");
txt = txt.replaceAll(""^rough"", ""rou2f"");
txt = txt.replaceAll(""^tough"", ""tou2f"");
txt = txt.replaceAll(""^enough"", ""enou2f"");
txt = txt.replaceAll(""^trough"", ""trou2f"");
txt = txt.replaceAll(""^gn"", ""2n"");
txt = txt.replaceAll(""^mb"", ""m2"");
txt = txt.replaceAll(""cq"", ""2q"");
txt = txt.replaceAll(""ci"", ""si"");
txt = txt.replaceAll(""ce"", ""se"");
txt = txt.replaceAll(""cy"", ""sy"");
txt = txt.replaceAll(""tch"", ""2ch"");
txt = txt.replaceAll(""c"", ""k"");
txt = txt.replaceAll(""q"", ""k"");
txt = txt.replaceAll(""x"", ""k"");
txt = txt.replaceAll(""v"", ""f"");
txt = txt.replaceAll(""dg"", ""2g"");
txt = txt.replaceAll(""tio"", ""sio"");
txt = txt.replaceAll(""tia"", ""sia"");
txt = txt.replaceAll(""d"", ""t"");
txt = txt.replaceAll(""ph"", ""fh"");
txt = txt.replaceAll(""b"", ""p"");
txt = txt.replaceAll(""sh"", ""s2"");
txt = txt.replaceAll(""z"", ""s"");
txt = txt.replaceAll(""^[aeiou]"", ""A"");
txt = txt.replaceAll(""[aeiou]"", ""3"");
txt = txt.replaceAll(""j"", ""y"");
txt = txt.replaceAll(""^y3"", ""Y3"");
txt = txt.replaceAll(""^y"", ""A"");
txt = txt.replaceAll(""y"", ""3"");
txt = txt.replaceAll(""3gh3"", ""3kh3"");
txt = txt.replaceAll(""gh"", ""22"");
txt = txt.replaceAll(""g"", ""k"");
txt = txt.replaceAll(""s+"", ""S"");
txt = txt.replaceAll(""t+"", ""T"");
txt = txt.replaceAll(""p+"", ""P"");
txt = txt.replaceAll(""k+"", ""K"");
txt = txt.replaceAll(""f+"", ""F"");
txt = txt.replaceAll(""m+"", ""M"");
txt = txt.replaceAll(""n+"", ""N"");
txt = txt.replaceAll(""w3"", ""W3"");
txt = txt.replaceAll(""wh3"", ""Wh3"");
txt = txt.replaceAll(""w$"", ""3"");
txt = txt.replaceAll(""w"", ""2"");
txt = txt.replaceAll(""^h"", ""A"");
txt = txt.replaceAll(""h"", ""2"");
txt = txt.replaceAll(""r3"", ""R3"");
txt = txt.replaceAll(""r$"", ""3"");
txt = txt.replaceAll(""r"", ""2"");
txt = txt.replaceAll(""l3"", ""L3"");
txt = txt.replaceAll(""l$"", ""3"");
txt = txt.replaceAll(""l"", ""2"");
txt = txt.replaceAll(""2"", """");
txt = txt.replaceAll(""3$"", ""A"");
txt = txt.replaceAll(""3"", """");
txt = txt + ""111111"" + ""1111"";
return txt.substring(0, 10);
}",1
1282,"public static LanguageSet ANY_LANGUAGE = new LanguageSet() {
@Override
public LanguageSet restrictTo(LanguageSet other) {
return other;
}
@Override
public boolean contains(String language) {
return true;
}
@Override
public boolean isSingleton() {
return false;
}
@Override
public String getAny() {
throw new NoSuchElementException(""Can't fetch any language from the any language set."");
}
@Override
public boolean isEmpty() {
return false;
}
};",1
1283,"public static String crypt(byte[] original, String salt) {
if (salt == null) {
Random randomGenerator = new Random();
int numSaltChars = SALT_CHARS.length;
salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
} else if (!salt.matches(""^["" + B64.B64T + ""]{2,}$"")) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
for (; salt.length() < 2; salt = salt + ""A"") ;
StringBuilder buffer = new StringBuilder(""             "");
char charZero = salt.charAt(0);
char charOne = salt.charAt(1);
buffer.setCharAt(0, charZero);
buffer.setCharAt(1, charOne);
int eSwap0 = CON_SALT[charZero];
int eSwap1 = CON_SALT[charOne] << 4;
byte[] key = new byte[8];
for (int i = 0; i < key.length; i++) {
key[i] = 0;
}
for (int i = 0; i < key.length && i < original.length; i++) {
int iChar = original[i];
key[i] = (byte) (iChar << 1);
}
int[] schedule = desSetKey(key);
int[] out = body(schedule, eSwap0, eSwap1);
byte[] b = new byte[9];
intToFourBytes(out[0], b, 0);
intToFourBytes(out[1], b, 4);
b[8] = 0;
int i = 2;
int y = 0;
int u = 128;
for (; i < 13; i++) {
int j = 0;
int c = 0;
for (; j < 6; j++) {
c <<= 1;
if ((b[y] & u) != 0) {
c |= 0x1;
}
u >>>= 1;
if (u == 0) {
y++;
u = 128;
}
buffer.setCharAt(i, (char) COV2CHAR[c]);
}
}
return buffer.toString();
}",0
1284,"public static int hash32(final String text) {
final byte[] bytes = text.getBytes();
return hash32(bytes, bytes.length);
}",1
1285,"@Deprecated
public static int hash32(final String data) {
final byte[] bytes = data.getBytes();
return hash32(bytes, 0, bytes.length, DEFAULT_SEED);
}",1
1286,"public static int hash32(final String data) {
final byte[] origin = data.getBytes();
return hash32(origin, 0, origin.length, DEFAULT_SEED);
}",0
1287,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
final int savedPos = context.pos;
switch(context.modulus) {
case 1:
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 2:
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 3:
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 4:
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
buffer[context.pos++] = PAD;
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
if (0 == context.modulus) {
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",1
1288,"public static byte[] sha(String data) {
return sha(data.getBytes());
}",1
1289,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages someLanguages = (SomeLanguages) other;
final Set<String> set = new HashSet<>(Math.min(languages.size(), someLanguages.languages.size()));
for (final String lang : languages) {
if (someLanguages.languages.contains(lang)) {
set.add(lang);
}
}
return from(set);
}
}",0
1290,"@SuppressWarnings(""unchecked"")
protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map, final Class<C> collectionClazz, final int initialCollectionCapacity) {
if (map == null) {
throw new IllegalArgumentException(""Map must not be null"");
}
if (initialCollectionCapacity < 0) {
throw new IllegalArgumentException(""Illegal Capacity: "" + initialCollectionCapacity);
}
this.map = (Map<K, Collection<V>>) map;
this.collectionFactory = new InstantiateFactory<C>(collectionClazz, new Class[] { Integer.TYPE }, new Object[] { new Integer(initialCollectionCapacity) });
}",1
1291,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",1
1292,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
Objects.requireNonNull(keys, ""keys"");
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1293,"@SuppressWarnings(""unchecked"")
public static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {
map.size();
if (array == null || array.length == 0) {
return map;
}
final Object obj = array[0];
if (obj instanceof Map.Entry) {
for (final Object element : array) {
final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;
map.put(entry.getKey(), entry.getValue());
}
} else if (obj instanceof KeyValue) {
for (final Object element : array) {
final KeyValue<K, V> keyval = (KeyValue<K, V>) element;
map.put(keyval.getKey(), keyval.getValue());
}
} else if (obj instanceof Object[]) {
for (int i = 0; i < array.length; i++) {
final Object[] sub = (Object[]) array[i];
if (sub == null || sub.length < 2) {
throw new IllegalArgumentException(""Invalid array element: "" + i);
}
map.put((K) sub[0], (V) sub[1]);
}
} else {
for (int i = 0; i < array.length - 1; ) {
map.put((K) array[i++], (V) array[i++]);
}
}
return map;
}",1
1294,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1295,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
1296,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1297,"@Override
public boolean equals(final Object object) {
if (object == this) {
return true;
}
synchronized (lock) {
return getBag().equals(object);
}
}",0
1298,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1299,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1300,"private UnmodifiableBidiMap<V, K> inverse;",0
1301,"private final Transformer<C, K> keyTransformer;",0
1302,private final Predicate<? super E> predicate;,0
1303,"protected final Transformer<? super E, ? extends E> transformer;",0
1304,"private final Transformer<? super I, ? extends O> transformer;",0
1305,private final Predicate<? super T> iPredicate1;,0
1306,private final Closure<? super E>[] iClosures;,0
1307,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1308,private final Closure<? super T> iClosure;,0
1309,private final Factory<? extends O> iFactory;,0
1310,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1311,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1312,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1313,private final Predicate<? super E> iPredicate;,0
1314,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
1315,private final Predicate<? super T> iPredicate;,0
1316,private final Predicate<? super T> iPredicate;,0
1317,private final Predicate<? super T> iPredicate;,0
1318,private final Predicate<? super T> iPredicate;,0
1319,private final Predicate<? super T> iPredicate2;,0
1320,private final Predicate<? super T> iPredicate;,0
1321,private final Closure<? super E> iDefault;,0
1322,private final Predicate<? super I>[] iPredicates;,0
1323,"private final Transformer<? super T, ? extends T> iTransformer;",0
1324,"private final Transformer<? super E, ?> iTransformer;",0
1325,"private final Transformer<? super T, Boolean> iTransformer;",0
1326,"public E[] getArray() {
return this.array;
}",0
1327,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1328,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1329,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1330,private final Factory<? extends E> factory;,0
1331,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1332,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1333,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
1334,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1335,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1336,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1337,"@Override
public int hashCode() {
return hash;
}",0
1338,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
1339,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1340,"V currentValue, nextValue;",0
1341,"@Override
public int hashCode() {
return hash;
}",0
1342,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1343,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1344,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1345,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1346,"protected Node<K, V> next;",0
1347,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
1348,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
return SetUtils.isEqualSet(set, otherSet);
}",0
1349,"public void trimToSize() {
for (Collection<V> coll : getMap().values()) {
final ArrayList<V> list = (ArrayList<V>) coll;
list.trimToSize();
}
}",0
1350,"private final Transformer<? super K, ? extends K> keyTransformer;",0
1351,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
1352,protected final AbstractMapMultiSet<E> parent;,0
1353,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1354,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1355,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1356,"@Override
public void clear() {
Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();
Set<K> currentKeys = keySet();
while (it.hasNext()) {
if (currentKeys.contains(it.next().getKey())) {
it.remove();
}
}
}",0
1357,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1358,"@Override
public Set<E> uniqueSet() {
synchronized (lock) {
final Set<E> set = getBag().uniqueSet();
return new SynchronizedBagSet(set, lock);
}
}",0
1359,"private void writeObject(final ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeObject(comparator());
super.doWriteObject(out);
}",0
1360,"@Override
public void remove() {
if (!canRemove) {
throw new IllegalStateException(""Iterator remove() can only be called once after next()"");
}
final Object value = last.getValue();
super.remove();
parent.reverseMap.remove(value);
last = null;
canRemove = false;
}",0
1361,"@Override
public void remove() {
if (!canRemove) {
throw new IllegalStateException(""Iterator remove() can only be called once after next()"");
}
final V value = last.getValue();
iterator.remove();
parent.reverseMap.remove(value);
last = null;
canRemove = false;
}",0
1362,"@Override
public void remove() {
iterator.remove();
parent.remove(last.getKey());
last = null;
}",0
1363,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1364,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1365,"private UnmodifiableBidiMap<V, K> inverse;",0
1366,"boolean add(long bits) {
if (size == data.length) {
data = Arrays.copyOf(data, size * 2);
}
data[size++] = bits;
return true;
}",0
1367,"boolean add(long bits) {
if (size == data.length) {
data = Arrays.copyOf(data, size * 2);
}
data[size++] = bits;
return true;
}",0
1368,"private IndexFilter(Shape shape, IntPredicate consumer) {
this.size = shape.getNumberOfBits();
this.consumer = consumer;
if (BitMap.numberOfBitMaps(shape.getNumberOfBits()) * Long.BYTES < (long) shape.getNumberOfHashFunctions() * Integer.BYTES) {
this.tracker = new BitMapTracker(shape);
} else {
this.tracker = new ArrayTracker(shape);
}
}",0
1369,"private final Transformer<C, K> keyTransformer;",0
1370,private final Predicate<? super E> predicate;,0
1371,"protected final Transformer<? super E, ? extends E> transformer;",0
1372,private final List<Comparator<E>> comparatorChain;,0
1373,private final Comparator<? super E> nonNullComparator;,0
1374,private final Comparator<? super E> comparator;,0
1375,private final Comparator<O> decorated;,0
1376,private final Predicate<? super T> iPredicate2;,0
1377,private final Closure<? super E>[] iClosures;,0
1378,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1379,private final Closure<? super T> iClosure;,0
1380,private final Comparator<T> comparator;,0
1381,private final Equator<T> equator;,0
1382,private final Factory<? extends O> iFactory;,0
1383,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1384,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1385,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1386,private final Closure<? super E> iFalseClosure;,0
1387,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
1388,private final Predicate<? super T> iPredicate;,0
1389,private final Predicate<? super T> iPredicate;,0
1390,private final Predicate<? super T> iPredicate;,0
1391,private final Predicate<? super T> iPredicate;,0
1392,private final Predicate<? super T> iPredicate2;,0
1393,private final Predicate<? super T> iPredicate;,0
1394,private final Predicate<? super E>[] iPredicates;,0
1395,private final Predicate<? super I>[] iPredicates;,0
1396,private final Predicate<? super T> iPredicate;,0
1397,"private final Transformer<? super E, ?> iTransformer;",0
1398,"private final Transformer<? super T, Boolean> iTransformer;",0
1399,"public E[] getArray() {
return this.array;
}",0
1400,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1401,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1402,private final Factory<? extends E> factory;,0
1403,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1404,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1405,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1406,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1407,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1408,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
final ReferenceEntry<K, V> refEntry = (ReferenceEntry<K, V>) entry;
if (refEntry.purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
refEntry.onPurge();
return;
}
previous = entry;
entry = entry.next;
}
}",0
1409,"@Override
public int hashCode() {
return hash;
}",0
1410,"@Override
public int hashCode() {
return hash;
}",0
1411,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
current = next;
next = next.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return current;
}",0
1412,"V currentValue, nextValue;",0
1413,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1414,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(CollectionUtils.COMMA);
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(CollectionUtils.COMMA);
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1415,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1416,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1417,"protected Node<K, V> next;",0
1418,"@Override
public boolean equals(final Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (!(other instanceof Set)) {
return false;
}
final Set<?> otherSet = (Set<?>) other;
return SetUtils.isEqualSet(set, otherSet);
}",0
1419,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
1420,"public void trimToSize() {
for (final Collection<V> coll : getMap().values()) {
final ArrayList<V> list = (ArrayList<V>) coll;
list.trimToSize();
}
}",0
1421,"private final Transformer<? super K, ? extends K> keyTransformer;",0
1422,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<>(map);
}",0
1423,protected final AbstractMapMultiSet<E> parent;,0
1424,"@Override
public String getProperty(final String key, final String defaultValue) {
return defaultValue;
}",0
1425,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1426,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1427,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1428,"@Override
public void clear() {
final Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();
final Set<K> currentKeys = keySet();
while (it.hasNext()) {
if (currentKeys.contains(it.next().getKey())) {
it.remove();
}
}
}",0
1429,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
1430,"@SuppressWarnings(""unchecked"")
public static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {
map.size();
if (array == null || array.length == 0) {
return map;
}
final Object obj = array[0];
if (obj instanceof Map.Entry) {
for (final Object element : array) {
final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;
map.put(entry.getKey(), entry.getValue());
}
} else if (obj instanceof KeyValue) {
for (final Object element : array) {
final KeyValue<K, V> keyval = (KeyValue<K, V>) element;
map.put(keyval.getKey(), keyval.getValue());
}
} else if (obj instanceof Object[]) {
for (int i = 0; i < array.length; i++) {
final Object[] sub = (Object[]) array[i];
if (sub == null || sub.length < 2) {
throw new IllegalArgumentException(""Invalid array element: "" + i);
}
map.put((K) sub[0], (V) sub[1]);
}
} else {
for (int i = 0; i < array.length - 1; ) {
map.put((K) array[i++], (V) array[i++]);
}
}
return map;
}",0
1431,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1432,"private void writeObject(final ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeObject(comparator());
super.doWriteObject(out);
}",0
1433,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1434,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1435,"private UnmodifiableBidiMap<V, K> inverse;",0
1436,"private final Transformer<C, K> keyTransformer;",0
1437,"protected final Transformer<? super E, ? extends E> transformer;",0
1438,private final List<Comparator<E>> comparatorChain;,0
1439,private final Comparator<? super E> nonNullComparator;,0
1440,private final Comparator<E> comparator;,0
1441,private final Comparator<O> decorated;,0
1442,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1443,private final Comparator<T> comparator;,0
1444,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1445,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1446,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1447,private transient Method iCloneMethod;,0
1448,"private final Transformer<? super I, ? extends O> iDefault;",0
1449,"private final Transformer<? super T, ? extends T> iTransformer;",0
1450,"private final Transformer<? super E, ?> iTransformer;",0
1451,"private final Transformer<? super T, Boolean> iTransformer;",0
1452,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1453,"public E[] getArray() {
return this.array;
}",0
1454,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1455,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1456,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1457,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1458,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
1459,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1460,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1461,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1462,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1463,"V currentValue, nextValue;",0
1464,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
1465,"@Override
public int hashCode() {
return hash;
}",0
1466,"@Override
public int hashCode() {
return hash;
}",0
1467,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1468,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1469,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1470,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1471,"protected Node<K, V> next;",0
1472,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1473,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1474,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1475,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
1476,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1477,"@Override
public boolean equals(final Object object) {
if (object == this) {
return true;
}
synchronized (lock) {
return getBag().equals(object);
}
}",0
1478,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1479,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1480,"private UnmodifiableBidiMap<V, K> inverse;",0
1481,"private final Transformer<C, K> keyTransformer;",0
1482,private final Predicate<? super E> predicate;,0
1483,"protected final Transformer<? super E, ? extends E> transformer;",0
1484,"private final Transformer<? super I, ? extends O> transformer;",0
1485,private final Predicate<? super T> iPredicate2;,0
1486,private final Closure<? super E>[] iClosures;,0
1487,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1488,private final Closure<? super T> iClosure;,0
1489,private final Factory<? extends O> iFactory;,0
1490,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1491,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1492,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1493,private final Closure<? super E> iFalseClosure;,0
1494,private final Predicate<? super I> iPredicate;,0
1495,private final Predicate<? super T> iPredicate;,0
1496,private final Predicate<? super T> iPredicate;,0
1497,private final Predicate<? super T> iPredicate;,0
1498,private final Predicate<? super T> iPredicate;,0
1499,private final Predicate<? super T> iPredicate2;,0
1500,private final Predicate<? super T> iPredicate;,0
1501,private final Closure<? super E> iDefault;,0
1502,private final Predicate<? super I>[] iPredicates;,0
1503,"private final Transformer<? super T, ? extends T> iTransformer;",0
1504,"private final Transformer<? super E, ?> iTransformer;",0
1505,"private final Transformer<? super T, Boolean> iTransformer;",0
1506,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1507,"public E[] getArray() {
return this.array;
}",0
1508,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1509,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1510,private final Factory<? extends E> factory;,0
1511,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1512,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1513,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
1514,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1515,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1516,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1517,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
1518,"@Override
public int hashCode() {
return hash;
}",0
1519,"@Override
public int hashCode() {
return hash;
}",0
1520,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1521,"V currentValue, nextValue;",0
1522,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1523,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1524,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1525,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1526,"protected Node<K, V> next;",0
1527,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
return SetUtils.isEqualSet(set, otherSet);
}",0
1528,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
1529,"public void trimToSize() {
for (Collection<V> coll : getMap().values()) {
final ArrayList<V> list = (ArrayList<V>) coll;
list.trimToSize();
}
}",0
1530,"private final Transformer<? super K, ? extends K> keyTransformer;",0
1531,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
1532,protected final AbstractMapMultiSet<E> parent;,0
1533,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1534,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1535,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1536,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
1537,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1538,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1539,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1540,"private UnmodifiableBidiMap<V, K> inverse;",0
1541,"private final Transformer<C, K> keyTransformer;",0
1542,"protected final Transformer<? super E, ? extends E> transformer;",0
1543,"private final Transformer<? super I, ? extends O> transformer;",0
1544,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1545,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1546,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1547,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1548,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
1549,private transient Method iCloneMethod;,0
1550,"private final Transformer<? super I, ? extends O> iDefault;",0
1551,"private final Transformer<? super T, ? extends T> iTransformer;",0
1552,"private final Transformer<? super E, ?> iTransformer;",0
1553,"private final Transformer<? super T, Boolean> iTransformer;",0
1554,"public E[] getArray() {
return this.array;
}",0
1555,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1556,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1557,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1558,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1559,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1560,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
1561,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1562,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1563,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1564,"@Override
public int hashCode() {
return hash;
}",0
1565,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1566,"@Override
public int hashCode() {
return hash;
}",0
1567,"V currentValue, nextValue;",0
1568,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
1569,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1570,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1571,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1572,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1573,protected K key;,0
1574,"public V remove(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
V value = list.remove(index);
if (list.isEmpty()) {
AbstractListValuedMap.this.remove(key);
}
return value;
}",0
1575,"public int indexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
1576,"@Override
public boolean equals(Object other) {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof List)) {
return false;
}
List<?> otherList = (List<?>) other;
if (ListUtils.isEqualList(list, otherList) == false) {
return false;
}
return true;
}",0
1577,"public List<V> subList(int fromIndex, int toIndex) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.subList(fromIndex, toIndex);
}",0
1578,"@SuppressWarnings(""unchecked"")
public boolean addAll(int index, Collection<? extends V> c) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) createCollection();
boolean result = list.addAll(index, c);
if (result) {
getMap().put((K) key, list);
}
return result;
}
return list.addAll(index, c);
}",0
1579,"public int lastIndexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
1580,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
List<V> valueList = (List<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ ListUtils.hashCodeForList(valueList);
}
return h;
}",0
1581,"@SuppressWarnings(""unchecked"")
public void add(int index, V value) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) AbstractListValuedMap.this.createCollection();
list.add(index, value);
getMap().put((K) key, list);
}
list.add(index, value);
}",0
1582,"@SuppressWarnings(""unchecked"")
public void add(V value) {
if (getMap().get(key) == null) {
List<V> list = (List<V>) createCollection();
getMap().put((K) key, list);
this.values = list;
this.iterator = list.listIterator();
}
this.iterator.add(value);
}",0
1583,"@Override
public int hashCode() {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().hashCode();
}
return ListUtils.hashCodeForList(list);
}",0
1584,"public V get(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.get(index);
}",0
1585,"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0
1586,private transient Collection<V> valuesView;,0
1587,"@SuppressWarnings(""unchecked"")
protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map, final Class<C> collectionClazz, final int initialCollectionCapacity) {
if (map == null) {
throw new IllegalArgumentException(""Map must not be null"");
}
if (initialCollectionCapacity < 0) {
throw new IllegalArgumentException(""Illegal Capacity: "" + initialCollectionCapacity);
}
this.map = (Map<K, Collection<V>>) map;
this.collectionFactory = new InstantiateFactory<C>(collectionClazz, new Class[] { Integer.TYPE }, new Object[] { new Integer(initialCollectionCapacity) });
}",0
1588,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
Set<V> valueSet = (Set<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ SetUtils.hashCodeForSet(valueSet);
}
return h;
}",0
1589,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
if (SetUtils.isEqualSet(set, otherSet) == false) {
return false;
}
return true;
}",0
1590,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().hashCode();
}
return SetUtils.hashCodeForSet(set);
}",0
1591,"private final Transformer<? super K, ? extends K> keyTransformer;",0
1592,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
1593,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1594,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1595,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1596,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1597,"private void writeObject(final ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeObject(comparator());
super.doWriteObject(out);
}",0
1598,"private final Transformer<C, K> keyTransformer;",0
1599,private final List<Comparator<E>> comparatorChain;,0
1600,private final Comparator<? super E> comparator;,0
1601,private final Comparator<O> decorated;,0
1602,private final Predicate<? super T> iPredicate1;,0
1603,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1604,private final Equator<T> equator;,0
1605,private final Factory<? extends O> iFactory;,0
1606,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1607,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1608,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1609,private final Closure<? super E> iFalseClosure;,0
1610,private final Predicate<? super I> iPredicate;,0
1611,private final Predicate<? super T> iPredicate;,0
1612,private final Predicate<? super T> iPredicate;,0
1613,private final Predicate<? super T> iPredicate2;,0
1614,private final Predicate<? super T> iPredicate;,0
1615,private final Closure<? super E> iDefault;,0
1616,"private final Transformer<? super I, ? extends O>[] iTransformers;",0
1617,private final Predicate<? super T> iPredicate;,0
1618,"private final Transformer<? super E, ?> iTransformer;",0
1619,"public E[] getArray() {
return this.array;
}",0
1620,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1621,"private final Transformer<Integer, ? extends E> transformer;",0
1622,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1623,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1624,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1625,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1626,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1627,"@Override
public int hashCode() {
return hash;
}",0
1628,"@Override
public int hashCode() {
return hash;
}",0
1629,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1630,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1631,protected V value;,0
1632,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
1633,"@Override
public boolean equals(final Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (!(other instanceof Set)) {
return false;
}
final Set<?> otherSet = (Set<?>) other;
return SetUtils.isEqualSet(set, otherSet);
}",0
1634,"public void trimToSize() {
for (final Collection<V> coll : getMap().values()) {
final ArrayList<V> list = (ArrayList<V>) coll;
list.trimToSize();
}
}",0
1635,"private final Transformer<? super K, ? extends K> keyTransformer;",0
1636,"@Override
public String getProperty(final String key, final String defaultValue) {
return defaultValue;
}",0
1637,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1638,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1639,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1640,"@Override
public Set<E> uniqueSet() {
synchronized (lock) {
final Set<E> set = getBag().uniqueSet();
return new SynchronizedBagSet(set, lock);
}
}",0
1641,"private void writeObject(final ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeObject(comparator());
super.doWriteObject(out);
}",0
1642,"@Override
public void remove() {
if (canRemove == false) {
throw new IllegalStateException(""Iterator remove() can only be called once after next()"");
}
final V value = last.getValue();
iterator.remove();
parent.reverseMap.remove(value);
last = null;
canRemove = false;
}",0
1643,"@Override
public void remove() {
if (canRemove == false) {
throw new IllegalStateException(""Iterator remove() can only be called once after next()"");
}
final Object value = last.getValue();
super.remove();
parent.reverseMap.remove(value);
last = null;
canRemove = false;
}",0
1644,"@Override
public void remove() {
iterator.remove();
parent.remove(last.getKey());
last = null;
}",0
1645,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1646,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1647,"private UnmodifiableBidiMap<V, K> inverse;",0
1648,"private final Transformer<C, K> keyTransformer;",0
1649,private final Predicate<? super E> predicate;,0
1650,"protected final Transformer<? super E, ? extends E> transformer;",0
1651,private final List<Comparator<E>> comparatorChain;,0
1652,private final Comparator<? super E> nonNullComparator;,0
1653,private final Comparator<? super E> comparator;,0
1654,"private final Transformer<? super I, ? extends O> transformer;",0
1655,private final Predicate<? super T> iPredicate2;,0
1656,private final Closure<? super E>[] iClosures;,0
1657,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1658,private final Closure<? super T> iClosure;,0
1659,private final Comparator<T> comparator;,0
1660,private final Equator<T> equator;,0
1661,private final Factory<? extends O> iFactory;,0
1662,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1663,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1664,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1665,private final Predicate<? super E> iPredicate;,0
1666,"private final Transformer<? super I, ? extends O> iTrueTransformer;",0
1667,private final Predicate<? super T> iPredicate;,0
1668,private final Predicate<? super T> iPredicate;,0
1669,private final Predicate<? super T> iPredicate;,0
1670,private final Predicate<? super T> iPredicate;,0
1671,private final Predicate<? super T> iPredicate2;,0
1672,private final Predicate<? super T> iPredicate;,0
1673,private final Closure<? super E>[] iClosures;,0
1674,private final Predicate<? super I>[] iPredicates;,0
1675,"private final Transformer<? super T, ? extends T> iTransformer;",0
1676,"private final Transformer<? super E, ?> iTransformer;",0
1677,"private final Transformer<? super T, Boolean> iTransformer;",0
1678,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1679,"public E[] getArray() {
return this.array;
}",0
1680,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1681,private final Factory<? extends E> factory;,0
1682,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1683,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1684,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1685,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1686,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1687,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1688,"@Override
public int hashCode() {
return hash;
}",0
1689,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
final ReferenceEntry<K, V> refEntry = (ReferenceEntry<K, V>) entry;
if (refEntry.purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
refEntry.onPurge();
return;
}
previous = entry;
entry = entry.next;
}
}",0
1690,"@Override
public int hashCode() {
return hash;
}",0
1691,"V currentValue, nextValue;",0
1692,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(CollectionUtils.COMMA);
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(CollectionUtils.COMMA);
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1693,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1694,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1695,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1696,protected K key;,0
1697,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0
1698,"@Override
public boolean equals(final Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (!(other instanceof Set)) {
return false;
}
final Set<?> otherSet = (Set<?>) other;
return SetUtils.isEqualSet(set, otherSet);
}",0
1699,"public void trimToSize() {
for (final Collection<V> coll : getMap().values()) {
final ArrayList<V> list = (ArrayList<V>) coll;
list.trimToSize();
}
}",0
1700,"private final Transformer<? super K, ? extends K> keyTransformer;",0
1701,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<>(map);
}",0
1702,protected final AbstractMapMultiSet<E> parent;,0
1703,"@Override
public String getProperty(final String key, final String defaultValue) {
return defaultValue;
}",0
1704,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1705,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1706,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1707,"@Override
public void clear() {
final Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();
final Set<K> currentKeys = keySet();
while (it.hasNext()) {
if (currentKeys.contains(it.next().getKey())) {
it.remove();
}
}
}",0
1708,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
1709,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1710,"@Override
public boolean equals(final Object object) {
if (object == this) {
return true;
}
synchronized (lock) {
return getBag().equals(object);
}
}",0
1711,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1712,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1713,"private UnmodifiableBidiMap<V, K> inverse;",0
1714,"private final Transformer<C, K> keyTransformer;",0
1715,"protected final Transformer<? super E, ? extends E> transformer;",0
1716,"private final Transformer<? super I, ? extends O> transformer;",0
1717,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1718,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1719,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1720,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1721,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
1722,private transient Method iCloneMethod;,0
1723,"private final Transformer<? super I, ? extends O>[] iTransformers;",0
1724,"private final Transformer<? super T, ? extends T> iTransformer;",0
1725,"private final Transformer<? super E, ?> iTransformer;",0
1726,"private final Transformer<? super T, Boolean> iTransformer;",0
1727,"public E[] getArray() {
return this.array;
}",0
1728,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1729,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1730,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1731,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1732,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1733,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
1734,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1735,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1736,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1737,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1738,"V currentValue, nextValue;",0
1739,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
1740,"@Override
public int hashCode() {
return hash;
}",0
1741,"@Override
public int hashCode() {
return hash;
}",0
1742,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1743,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1744,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1745,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1746,protected K key;,0
1747,"public int indexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
1748,"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0
1749,"public List<V> subList(int fromIndex, int toIndex) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.subList(fromIndex, toIndex);
}",0
1750,"@SuppressWarnings(""unchecked"")
public void add(int index, V value) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) AbstractListValuedMap.this.createCollection();
list.add(index, value);
getMap().put((K) key, list);
}
list.add(index, value);
}",0
1751,"public int lastIndexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
1752,"@Override
public boolean equals(Object other) {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof List)) {
return false;
}
List<?> otherList = (List<?>) other;
if (ListUtils.isEqualList(list, otherList) == false) {
return false;
}
return true;
}",0
1753,"public V get(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.get(index);
}",0
1754,"@SuppressWarnings(""unchecked"")
public boolean addAll(int index, Collection<? extends V> c) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) createCollection();
boolean result = list.addAll(index, c);
if (result) {
getMap().put((K) key, list);
}
return result;
}
return list.addAll(index, c);
}",0
1755,"@SuppressWarnings(""unchecked"")
public void add(V value) {
if (getMap().get(key) == null) {
List<V> list = (List<V>) createCollection();
getMap().put((K) key, list);
this.values = list;
this.iterator = list.listIterator();
}
this.iterator.add(value);
}",0
1756,"@Override
public int hashCode() {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().hashCode();
}
return ListUtils.hashCodeForList(list);
}",0
1757,"public V remove(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
V value = list.remove(index);
if (list.isEmpty()) {
AbstractListValuedMap.this.remove(key);
}
return value;
}",0
1758,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
List<V> valueList = (List<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ ListUtils.hashCodeForList(valueList);
}
return h;
}",0
1759,private transient KeysBag keysBagView;,0
1760,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
Set<V> valueSet = (Set<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ SetUtils.hashCodeForSet(valueSet);
}
return h;
}",0
1761,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
if (SetUtils.isEqualSet(set, otherSet) == false) {
return false;
}
return true;
}",0
1762,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().hashCode();
}
return SetUtils.hashCodeForSet(set);
}",0
1763,"private final Transformer<? super K, ? extends K> keyTransformer;",0
1764,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
1765,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1766,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1767,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1768,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
1769,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1770,"@Override
public boolean equals(final Object object) {
if (object == this) {
return true;
}
synchronized (lock) {
return getBag().equals(object);
}
}",0
1771,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1772,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1773,"private UnmodifiableBidiMap<V, K> inverse;",0
1774,"private final Transformer<C, K> keyTransformer;",0
1775,"protected final Transformer<? super E, ? extends E> transformer;",0
1776,"private final Transformer<? super I, ? extends O> transformer;",0
1777,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1778,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1779,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1780,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1781,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
1782,private transient Method iCloneMethod;,0
1783,"private final Transformer<? super I, ? extends O> iDefault;",0
1784,"private final Transformer<? super T, ? extends T> iTransformer;",0
1785,"private final Transformer<? super E, ?> iTransformer;",0
1786,"private final Transformer<? super T, Boolean> iTransformer;",0
1787,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1788,"public E[] getArray() {
return this.array;
}",0
1789,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1790,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1791,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1792,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1793,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
1794,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1795,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1796,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1797,"@Override
public int hashCode() {
return hash;
}",0
1798,"V currentValue, nextValue;",0
1799,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
1800,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1801,"@Override
public int hashCode() {
return hash;
}",0
1802,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1803,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1804,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1805,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1806,protected K key;,0
1807,"public List<V> subList(int fromIndex, int toIndex) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.subList(fromIndex, toIndex);
}",0
1808,"public int indexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
1809,"@SuppressWarnings(""unchecked"")
public boolean addAll(int index, Collection<? extends V> c) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) createCollection();
boolean result = list.addAll(index, c);
if (result) {
getMap().put((K) key, list);
}
return result;
}
return list.addAll(index, c);
}",0
1810,"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0
1811,"@Override
public boolean equals(Object other) {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof List)) {
return false;
}
List<?> otherList = (List<?>) other;
if (ListUtils.isEqualList(list, otherList) == false) {
return false;
}
return true;
}",0
1812,"@SuppressWarnings(""unchecked"")
public void add(V value) {
if (getMap().get(key) == null) {
List<V> list = (List<V>) createCollection();
getMap().put((K) key, list);
this.values = list;
this.iterator = list.listIterator();
}
this.iterator.add(value);
}",0
1813,"public V remove(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
V value = list.remove(index);
if (list.isEmpty()) {
AbstractListValuedMap.this.remove(key);
}
return value;
}",0
1814,"@Override
public int hashCode() {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().hashCode();
}
return ListUtils.hashCodeForList(list);
}",0
1815,"@SuppressWarnings(""unchecked"")
public void add(int index, V value) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) AbstractListValuedMap.this.createCollection();
list.add(index, value);
getMap().put((K) key, list);
}
list.add(index, value);
}",0
1816,"public int lastIndexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
1817,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
List<V> valueList = (List<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ ListUtils.hashCodeForList(valueList);
}
return h;
}",0
1818,"public V get(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.get(index);
}",0
1819,private transient KeysBag keysBagView;,0
1820,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().hashCode();
}
return SetUtils.hashCodeForSet(set);
}",0
1821,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
if (SetUtils.isEqualSet(set, otherSet) == false) {
return false;
}
return true;
}",0
1822,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
Set<V> valueSet = (Set<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ SetUtils.hashCodeForSet(valueSet);
}
return h;
}",0
1823,"private final Transformer<? super K, ? extends K> keyTransformer;",0
1824,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
1825,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1826,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1827,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1828,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
1829,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1830,"@Override
public boolean equals(final Object object) {
if (object == this) {
return true;
}
synchronized (lock) {
return getBag().equals(object);
}
}",0
1831,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1832,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1833,"private UnmodifiableBidiMap<V, K> inverse;",0
1834,"private final Transformer<C, K> keyTransformer;",0
1835,"protected final Transformer<? super E, ? extends E> transformer;",0
1836,"private final Transformer<? super I, ? extends O> transformer;",0
1837,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1838,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1839,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1840,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1841,"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
1842,private transient Method iCloneMethod;,0
1843,"private final Transformer<? super I, ? extends O> iDefault;",0
1844,"private final Transformer<? super T, ? extends T> iTransformer;",0
1845,"private final Transformer<? super E, ?> iTransformer;",0
1846,"private final Transformer<? super T, Boolean> iTransformer;",0
1847,"public E[] getArray() {
return this.array;
}",0
1848,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1849,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1850,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1851,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1852,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1853,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
1854,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1855,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1856,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1857,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1858,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
1859,"V currentValue, nextValue;",0
1860,"@Override
public int hashCode() {
return hash;
}",0
1861,"@Override
public int hashCode() {
return hash;
}",0
1862,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1863,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1864,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1865,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1866,"protected Node<K, V> next;",0
1867,"public int indexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
1868,"@SuppressWarnings(""unchecked"")
public void add(V value) {
if (getMap().get(key) == null) {
List<V> list = (List<V>) createCollection();
getMap().put((K) key, list);
this.values = list;
this.iterator = list.listIterator();
}
this.iterator.add(value);
}",0
1869,"@SuppressWarnings(""unchecked"")
public boolean addAll(int index, Collection<? extends V> c) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) createCollection();
boolean result = list.addAll(index, c);
if (result) {
getMap().put((K) key, list);
}
return result;
}
return list.addAll(index, c);
}",0
1870,"@Override
public boolean equals(Object other) {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof List)) {
return false;
}
List<?> otherList = (List<?>) other;
if (ListUtils.isEqualList(list, otherList) == false) {
return false;
}
return true;
}",0
1871,"@SuppressWarnings(""unchecked"")
public void add(int index, V value) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) AbstractListValuedMap.this.createCollection();
list.add(index, value);
getMap().put((K) key, list);
}
list.add(index, value);
}",0
1872,"public int lastIndexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0
1873,"public List<V> subList(int fromIndex, int toIndex) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.subList(fromIndex, toIndex);
}",0
1874,"public V remove(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
V value = list.remove(index);
if (list.isEmpty()) {
AbstractListValuedMap.this.remove(key);
}
return value;
}",0
1875,"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0
1876,"@Override
public int hashCode() {
final List<V> list = (List<V>) getMapping();
if (list == null) {
return Collections.emptyList().hashCode();
}
return ListUtils.hashCodeForList(list);
}",0
1877,"public V get(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.get(index);
}",0
1878,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
List<V> valueList = (List<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ ListUtils.hashCodeForList(valueList);
}
return h;
}",0
1879,private transient KeysBag keysBagView;,0
1880,"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().hashCode();
}
return SetUtils.hashCodeForSet(set);
}",0
1881,"@Override
public int hashCode() {
int h = 0;
Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();
while (it.hasNext()) {
Entry<K, Collection<V>> entry = it.next();
K key = entry.getKey();
Set<V> valueSet = (Set<V>) entry.getValue();
h += (key == null ? 0 : key.hashCode()) ^ SetUtils.hashCodeForSet(valueSet);
}
return h;
}",0
1882,"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
if (SetUtils.isEqualSet(set, otherSet) == false) {
return false;
}
return true;
}",0
1883,"private final Transformer<? super V, ? extends V> valueTransformer;",0
1884,"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0
1885,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1886,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1887,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1888,"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0
1889,"@SuppressWarnings(""unchecked"")
public static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {
map.size();
if (array == null || array.length == 0) {
return map;
}
final Object obj = array[0];
if (obj instanceof Map.Entry) {
for (final Object element : array) {
final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;
map.put(entry.getKey(), entry.getValue());
}
} else if (obj instanceof KeyValue) {
for (final Object element : array) {
final KeyValue<K, V> keyval = (KeyValue<K, V>) element;
map.put(keyval.getKey(), keyval.getValue());
}
} else if (obj instanceof Object[]) {
for (int i = 0; i < array.length; i++) {
final Object[] sub = (Object[]) array[i];
if (sub == null || sub.length < 2) {
throw new IllegalArgumentException(""Invalid array element: "" + i);
}
map.put((K) sub[0], (V) sub[1]);
}
} else {
for (int i = 0; i < array.length - 1; ) {
map.put((K) array[i++], (V) array[i++]);
}
}
return map;
}",0
1890,"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0
1891,"private void writeObject(final ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeObject(comparator());
super.doWriteObject(out);
}",0
1892,"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0
1893,"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0
1894,"private UnmodifiableBidiMap<V, K> inverse;",0
1895,"private final Transformer<C, K> keyTransformer;",0
1896,"protected final Transformer<? super E, ? extends E> transformer;",0
1897,private final List<Comparator<E>> comparatorChain;,0
1898,private final Comparator<? super E> nonNullComparator;,0
1899,private final Comparator<E> comparator;,0
1900,"private final Transformer<? super I, ? extends O> transformer;",0
1901,"private final Transformer<? super T, ? extends T>[] iTransformers;",0
1902,private final Comparator<T> comparator;,0
1903,"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0
1904,"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0
1905,"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0
1906,"private final Transformer<? super I, ? extends O> iTrueTransformer;",0
1907,private transient Method iCloneMethod;,0
1908,"private final Transformer<? super I, ? extends O> iDefault;",0
1909,"private final Transformer<? super T, ? extends T> iTransformer;",0
1910,"private final Transformer<? super E, ?> iTransformer;",0
1911,"private final Transformer<? super T, Boolean> iTransformer;",0
1912,"public E[] getArray() {
return this.array;
}",0
1913,"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0
1914,"public MultiKey(final K[] keys, final boolean makeClone) {
super();
if (keys == null) {
throw new IllegalArgumentException(""The array of keys must not be null"");
}
if (makeClone) {
this.keys = keys.clone();
} else {
this.keys = keys;
}
calculateHashCode(keys);
}",0
1915,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1916,"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0
1917,"protected List<E> getList() {
return (List<E>) decorated();
}",0
1918,"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0
1919,"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0
1920,"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0
1921,"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0
1922,"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0
1923,"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
if (((ReferenceEntry<K, V>) entry).purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
return;
}
previous = entry;
entry = entry.next;
}
}",0
1924,"V currentValue, nextValue;",0
1925,"@Override
public int hashCode() {
return hash;
}",0
1926,"@Override
public int hashCode() {
return hash;
}",0
1927,"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0
1928,"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0
1929,"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0
1930,"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0
1931,protected V value;,0
1932,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1933,"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0
1934,"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0
1935,"@Override
public synchronized String getUrl() {
return this.url;
}",0
1936,"@Override
public String getUsername() {
return this.userName;
}",0
1937,private boolean closed;,0
1938,"static ConnectionFactory createConnectionFactory(final BasicDataSource basicDataSource, final Driver driver) throws SQLException {
final Properties connectionProperties = basicDataSource.getConnectionProperties();
final String url = basicDataSource.getUrl();
final String user = basicDataSource.getUsername();
if (user != null) {
connectionProperties.put(Constants.KEY_USER, user);
} else {
basicDataSource.log(""DBCP DataSource configured without a 'username'"");
}
final String pwd = basicDataSource.getPassword();
if (pwd != null) {
connectionProperties.put(""password"", pwd);
} else {
basicDataSource.log(""DBCP DataSource configured without a 'password'"");
}
final String connectionFactoryClassName = basicDataSource.getConnectionFactoryClassName();
if (connectionFactoryClassName != null) {
try {
final Class<?> connectionFactoryFromCCL = Class.forName(connectionFactoryClassName);
return (ConnectionFactory) connectionFactoryFromCCL.getConstructor(Driver.class, String.class, Properties.class).newInstance(driver, url, connectionProperties);
} catch (final Exception t) {
final String message = ""Cannot load ConnectionFactory implementation '"" + connectionFactoryClassName + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
return new DriverConnectionFactory(driver, url, connectionProperties);
}",0
1939,"@Override
public byte[] getBytes(final int parameterIndex) throws SQLException {
checkOpen();
try {
return getDelegateCallableStatement().getBytes(parameterIndex);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1940,"@Override
public byte[] getBytes(final String parameterName) throws SQLException {
checkOpen();
try {
return getDelegateCallableStatement().getBytes(parameterName);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1941,"@Override
public byte[] getBytes(final String columnName) throws SQLException {
try {
return resultSet.getBytes(columnName);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1942,"@Override
public byte[] getBytes(final int columnIndex) throws SQLException {
try {
return resultSet.getBytes(columnIndex);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1943,"@Override
public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
1944,"@Override
public long executeLargeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
1945,"@Override
public boolean execute(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0
1946,"@SuppressWarnings(""resource"")
@Override
public ResultSet executeQuery(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return DelegatingResultSet.wrapResultSet(this, statement.executeQuery(sql));
} catch (final SQLException e) {
handleException(e);
throw new AssertionError();
}
}",0
1947,"@Override
public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0
1948,"@Override
public long executeLargeUpdate(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
1949,"@Override
public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
1950,"@Override
public boolean execute(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0
1951,"@Override
public void addBatch(final String sql) throws SQLException {
checkOpen();
try {
statement.addBatch(sql);
} catch (final SQLException e) {
handleException(e);
}
}",0
1952,"@Override
public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
1953,"@Override
public long[] executeLargeBatch() throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeBatch();
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1954,"@Override
public long executeLargeUpdate(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
1955,"@Override
public int executeUpdate(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
1956,"@Override
public long executeLargeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
1957,"@Override
public boolean execute(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0
1958,"static Driver createDriver(final BasicDataSource basicDataSource) throws SQLException {
Driver driverToUse = basicDataSource.getDriver();
final String driverClassName = basicDataSource.getDriverClassName();
final ClassLoader driverClassLoader = basicDataSource.getDriverClassLoader();
final String url = basicDataSource.getUrl();
if (driverToUse == null) {
Class<?> driverFromCCL = null;
if (driverClassName != null) {
try {
try {
if (driverClassLoader == null) {
driverFromCCL = Class.forName(driverClassName);
} else {
driverFromCCL = Class.forName(driverClassName, true, driverClassLoader);
}
} catch (final ClassNotFoundException cnfe) {
driverFromCCL = Thread.currentThread().getContextClassLoader().loadClass(driverClassName);
}
} catch (final Exception t) {
final String message = ""Cannot load JDBC driver class '"" + driverClassName + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
try {
if (driverFromCCL == null) {
driverToUse = DriverManager.getDriver(url);
} else {
driverToUse = (Driver) driverFromCCL.getConstructor().newInstance();
if (!driverToUse.acceptsURL(url)) {
throw new SQLException(""No suitable driver"", ""08001"");
}
}
} catch (final Exception t) {
final String message = ""Cannot create JDBC driver of class '"" + (driverClassName != null ? driverClassName : """") + ""' for connect URL '"" + url + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
return driverToUse;
}",0
1959,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, columnIndexes);
}",0
1960,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql);
}",0
1961,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, columnNames);
}",0
1962,"public void validate(final String sql, int timeoutSeconds) throws SQLException {
if (fastFailValidation && fatalSqlExceptionThrown) {
throw new SQLException(Utils.getMessage(""poolableConnection.validate.fastFail""));
}
if (sql == null || sql.isEmpty()) {
if (timeoutSeconds < 0) {
timeoutSeconds = 0;
}
if (!isValid(timeoutSeconds)) {
throw new SQLException(""isValid() returned false"");
}
return;
}
if (!sql.equals(lastValidationSql)) {
lastValidationSql = sql;
validationPreparedStatement = getInnermostDelegateInternal().prepareStatement(sql);
}
if (timeoutSeconds > 0) {
validationPreparedStatement.setQueryTimeout(timeoutSeconds);
}
try (ResultSet rs = validationPreparedStatement.executeQuery()) {
if (!rs.next()) {
throw new SQLException(""validationQuery didn't return a row"");
}
} catch (final SQLException sqle) {
throw sqle;
}
}",0
1963,"@Override
public synchronized void close() throws SQLException {
if (isClosedInternal()) {
return;
}
boolean isUnderlyingConnectionClosed;
try {
isUnderlyingConnectionClosed = getDelegateInternal().isClosed();
} catch (final SQLException e) {
try {
pool.invalidateObject(this);
} catch (final IllegalStateException ise) {
passivate();
getInnermostDelegate().close();
} catch (final Exception ie) {
}
throw new SQLException(""Cannot close connection (isClosed check failed)"", e);
}
if (isUnderlyingConnectionClosed) {
// Abnormal close: underlying connection closed unexpectedly, so we
try {
pool.invalidateObject(this);
} catch (final IllegalStateException e) {
passivate();
getInnermostDelegate().close();
} catch (final Exception e) {
throw new SQLException(""Cannot close connection (invalidating pooled object failed)"", e);
}
} else {
// Normal close: underlying connection is still open, so we
try {
pool.returnObject(this);
} catch (final IllegalStateException e) {
passivate();
getInnermostDelegate().close();
} catch (final SQLException | RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Cannot close connection (return to pool failed)"", e);
}
}
}",0
1964,"protected void initializeConnection(final Connection conn) throws SQLException {
final Collection<String> sqls = connectionInitSqls;
if (conn.isClosed()) {
throw new SQLException(""initializeConnection: connection closed"");
}
if (null != sqls) {
try (Statement stmt = conn.createStatement()) {
for (final String sql : sqls) {
Objects.requireNonNull(sql, ""null connectionInitSqls element"");
stmt.execute(sql);
}
}
}
}",0
1965,"public void validateConnection(final PoolableConnection conn) throws SQLException {
if (conn.isClosed()) {
throw new SQLException(""validateConnection: connection closed"");
}
conn.validate(validationQuery, validationQueryTimeoutSeconds);
}",0
1966,"public static char[] toCharArray(final String value) {
return value != null ? value.toCharArray() : null;
}",0
1967,"@Deprecated
public static void closeQuietly(final Statement statement) {
if (statement != null) {
try {
statement.close();
} catch (final Exception e) {
}
}
}",0
1968,"public static void closeQuietly(final AutoCloseable autoCloseable) {
if (autoCloseable != null) {
try {
autoCloseable.close();
} catch (final Exception e) {
}
}
}",0
1969,public static final Set<String> DISCONNECTION_SQL_CODES;,0
1970,"@Deprecated
public static void closeQuietly(final ResultSet resultSet) {
if (resultSet != null) {
try {
resultSet.close();
} catch (final Exception e) {
}
}
}",0
1971,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1972,"@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnNames));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1973,"@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1974,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1975,"@Override
public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnIndexes));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1976,"PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
}
try {
return pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
1977,"@Override
protected void finalize() throws Throwable {
try {
connection.close();
} catch (final Exception ignored) {
}
if (logicalConnection != null && !logicalConnection.isClosed()) {
throw new SQLException(""PooledConnection was gc'ed, without its last Connection being closed."");
}
}",0
1978,"PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, autoGeneratedKeys);
}
try {
return pStmtPool.borrowObject(createKey(sql, autoGeneratedKeys));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
1979,"PreparedStatement prepareStatement(final String sql) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql);
}
try {
return pStmtPool.borrowObject(createKey(sql));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
1980,"PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
}
try {
return pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
1981,"PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, columnNames);
}
try {
return pStmtPool.borrowObject(createKey(sql, columnNames));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
1982,"@Override
public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
try {
validateLifetime(pooledObject);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pconn = pooledObject.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pconn);
if (null == validationQuery) {
int timeoutSeconds = validationQueryTimeoutSeconds;
if (timeoutSeconds < 0) {
timeoutSeconds = 0;
}
try {
conn = pconn.getConnection();
valid = conn.isValid(timeoutSeconds);
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pconn);
try {
conn = pconn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly(rset);
Utils.closeQuietly(stmt);
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
}
return valid;
}",0
1983,"public XADataSource getXaDataSource() {
return xaDataSource;
}",0
1984,"@Override
public synchronized void rollback(final Xid xid) throws XAException {
Objects.requireNonNull(xid, ""xid is null"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
try {
connection.rollback();
} catch (final SQLException e) {
throw (XAException) new XAException().initCause(e);
} finally {
try {
connection.setAutoCommit(originalAutoCommit);
} catch (final SQLException e) {
}
this.currentXid = null;
}
}",0
1985,"@Override
public synchronized void end(final Xid xid, final int flag) throws XAException {
Objects.requireNonNull(xid, ""xid is null"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
}",0
1986,"private void updateTransactionStatus() throws SQLException {
if (transactionContext != null && !transactionContext.isTransactionComplete()) {
if (transactionContext.isActive()) {
if (transactionContext != transactionRegistry.getActiveTransactionContext()) {
throw new SQLException(""Connection can not be used while enlisted in another transaction"");
}
return;
}
transactionComplete();
}
transactionContext = transactionRegistry.getActiveTransactionContext();
if (transactionContext != null && transactionContext.getSharedConnection() != null) {
@SuppressWarnings(""resource"")
final C connection = getDelegateInternal();
setDelegate(null);
if (connection != null && transactionContext.getSharedConnection() != connection) {
try {
pool.returnObject(connection);
} catch (final Exception ignored) {
try {
pool.invalidateObject(connection);
} catch (final Exception ignore) {
}
}
}
transactionContext.addTransactionContextListener(new CompletionListener());
@SuppressWarnings(""unchecked"")
final C shared = (C) transactionContext.getSharedConnection();
setDelegate(shared);
isSharedConnection = true;
} else {
C connection = getDelegateInternal();
if (connection == null) {
try {
connection = pool.borrowObject();
setDelegate(connection);
} catch (final Exception e) {
throw new SQLException(""Unable to acquire a new connection from the pool"", e);
}
}
if (transactionContext != null) {
transactionContext.addTransactionContextListener(new CompletionListener());
try {
transactionContext.setSharedConnection(connection);
} catch (final SQLException e) {
transactionContext = null;
try {
pool.invalidateObject(connection);
} catch (final Exception e1) {
}
throw e;
}
}
}
clearCachedState();
}",0
1987,"@Override
public String getUsername() {
return this.userName;
}",0
1988,"@Override
public synchronized String getUrl() {
return this.connectionString;
}",0
1989,"static ConnectionFactory createConnectionFactory(final BasicDataSource basicDataSource, final Driver driver) throws SQLException {
final Properties connectionProperties = basicDataSource.getConnectionProperties();
final String url = basicDataSource.getUrl();
final String user = basicDataSource.getUsername();
if (user != null) {
connectionProperties.put(Constants.KEY_USER, user);
} else {
basicDataSource.log(String.format(""DBCP DataSource configured without a '%s'"", Constants.KEY_USER));
}
final String pwd = basicDataSource.getPassword();
if (pwd != null) {
connectionProperties.put(Constants.KEY_PASSWORD, pwd);
} else {
basicDataSource.log(String.format(""DBCP DataSource configured without a '%s'"", Constants.KEY_PASSWORD));
}
final String connectionFactoryClassName = basicDataSource.getConnectionFactoryClassName();
if (connectionFactoryClassName != null) {
try {
final Class<?> connectionFactoryFromCCL = Class.forName(connectionFactoryClassName);
return (ConnectionFactory) connectionFactoryFromCCL.getConstructor(Driver.class, String.class, Properties.class).newInstance(driver, url, connectionProperties);
} catch (final Exception t) {
final String message = ""Cannot load ConnectionFactory implementation '"" + connectionFactoryClassName + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
return new DriverConnectionFactory(driver, url, connectionProperties);
}",0
1990,"@Override
public byte[] getBytes(final int parameterIndex) throws SQLException {
checkOpen();
try {
return getDelegateCallableStatement().getBytes(parameterIndex);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1991,"@Override
public byte[] getBytes(final String parameterName) throws SQLException {
checkOpen();
try {
return getDelegateCallableStatement().getBytes(parameterName);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1992,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1993,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1994,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnNames)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1995,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1996,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1997,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, autoGeneratedKeys)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1998,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnIndexes)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
1999,"@Override
public byte[] getBytes(final int columnIndex) throws SQLException {
try {
return resultSet.getBytes(columnIndex);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2000,"@Override
public byte[] getBytes(final String columnName) throws SQLException {
try {
return resultSet.getBytes(columnName);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2001,"@Override
public void addBatch(final String sql) throws SQLException {
checkOpen();
try {
statement.addBatch(sql);
} catch (final SQLException e) {
handleException(e);
}
}",0
2002,"static Driver createDriver(final BasicDataSource basicDataSource) throws SQLException {
Driver driverToUse = basicDataSource.getDriver();
final String driverClassName = basicDataSource.getDriverClassName();
final ClassLoader driverClassLoader = basicDataSource.getDriverClassLoader();
final String url = basicDataSource.getUrl();
if (driverToUse == null) {
Class<?> driverFromCCL = null;
if (driverClassName != null) {
try {
try {
if (driverClassLoader == null) {
driverFromCCL = Class.forName(driverClassName);
} else {
driverFromCCL = Class.forName(driverClassName, true, driverClassLoader);
}
} catch (final ClassNotFoundException cnfe) {
driverFromCCL = Thread.currentThread().getContextClassLoader().loadClass(driverClassName);
}
} catch (final Exception t) {
final String message = ""Cannot load JDBC driver class '"" + driverClassName + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
try {
if (driverFromCCL == null) {
driverToUse = DriverManager.getDriver(url);
} else {
driverToUse = (Driver) driverFromCCL.getConstructor().newInstance();
if (!driverToUse.acceptsURL(url)) {
throw new SQLException(""No suitable driver"", ""08001"");
}
}
} catch (final Exception t) {
final String message = ""Cannot create JDBC driver of class '"" + (driverClassName != null ? driverClassName : """") + ""' for connect URL '"" + url + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
return driverToUse;
}",0
2003,"public void validate(final String sql, Duration timeoutDuration) throws SQLException {
if (fastFailValidation && fatalSqlExceptionThrown) {
throw new SQLException(Utils.getMessage(""poolableConnection.validate.fastFail""));
}
if (sql == null || sql.isEmpty()) {
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
if (!isValid(timeoutDuration)) {
throw new SQLException(""isValid() returned false"");
}
return;
}
if (!sql.equals(lastValidationSql)) {
lastValidationSql = sql;
validationPreparedStatement = getInnermostDelegateInternal().prepareStatement(sql);
}
if (timeoutDuration.compareTo(Duration.ZERO) > 0) {
validationPreparedStatement.setQueryTimeout((int) timeoutDuration.getSeconds());
}
try (ResultSet rs = validationPreparedStatement.executeQuery()) {
if (!rs.next()) {
throw new SQLException(""validationQuery didn't return a row"");
}
} catch (final SQLException sqle) {
throw sqle;
}
}",0
2004,"@Override
public synchronized void close() throws SQLException {
if (isClosedInternal()) {
return;
}
boolean isUnderlyingConnectionClosed;
try {
isUnderlyingConnectionClosed = getDelegateInternal().isClosed();
} catch (final SQLException e) {
try {
pool.invalidateObject(this);
} catch (final IllegalStateException ise) {
passivate();
getInnermostDelegate().close();
} catch (final Exception ignored) {
}
throw new SQLException(""Cannot close connection (isClosed check failed)"", e);
}
if (isUnderlyingConnectionClosed) {
// Abnormal close: underlying connection closed unexpectedly, so we
try {
pool.invalidateObject(this);
} catch (final IllegalStateException e) {
passivate();
getInnermostDelegate().close();
} catch (final Exception e) {
throw new SQLException(""Cannot close connection (invalidating pooled object failed)"", e);
}
} else {
// Normal close: underlying connection is still open, so we
try {
pool.returnObject(this);
} catch (final IllegalStateException e) {
passivate();
getInnermostDelegate().close();
} catch (final SQLException | RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Cannot close connection (return to pool failed)"", e);
}
}
}",0
2005,"@Deprecated
public void validate(final String sql, final int timeoutSeconds) throws SQLException {
validate(sql, Duration.ofSeconds(timeoutSeconds));
}",0
2006,"public void validateConnection(final PoolableConnection conn) throws SQLException {
if (conn.isClosed()) {
throw new SQLException(""validateConnection: connection closed"");
}
conn.validate(validationQuery, validationQueryTimeoutDuration);
}",0
2007,"protected static final HashMap<String, ObjectPool<? extends Connection>> pools = new HashMap<>();",0
2008,"public void invalidateConnection(final Connection conn) throws SQLException {
if (!(conn instanceof PoolGuardConnectionWrapper)) {
throw new SQLException(""Invalid connection class"");
}
final PoolGuardConnectionWrapper pgconn = (PoolGuardConnectionWrapper) conn;
@SuppressWarnings(""unchecked"")
final ObjectPool<Connection> pool = (ObjectPool<Connection>) pgconn.pool;
try {
pool.invalidateObject(pgconn.getDelegateInternal());
} catch (final Exception ignored) {
}
}",0
2009,"@Deprecated
public static final Set<String> DISCONNECTION_SQL_CODES;",0
2010,"public static char[] toCharArray(final String value) {
return value != null ? value.toCharArray() : null;
}",0
2011,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2012,"@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2013,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2014,"@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnNames));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2015,"@Override
public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, autoGeneratedKeys));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2016,"@Override
public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnIndexes));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2017,private UserPassKey userPassKey;,0
2018,"@Override
public boolean validateObject(final PooledObject<PooledConnectionAndInfo> p) {
try {
validateLifetime(p);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pconn = p.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pconn);
if (null == validationQuery) {
Duration timeoutDuration = validationQueryTimeoutDuration;
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
try {
conn = pconn.getConnection();
valid = conn.isValid((int) timeoutDuration.getSeconds());
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pconn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pconn);
try {
conn = pconn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) rset);
Utils.closeQuietly((AutoCloseable) stmt);
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pconn);
}
}
return valid;
}",0
2019,"@Override
public boolean validateObject(final PooledObject<PooledConnectionAndInfo> p) {
try {
validateLifetime(p);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pconn = p.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pconn);
if (null == validationQuery) {
Duration timeoutDuration = validationQueryTimeoutDuration;
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
try {
conn = pconn.getConnection();
valid = conn.isValid((int) timeoutDuration.getSeconds());
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pconn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pconn);
try {
conn = pconn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) rset);
Utils.closeQuietly((AutoCloseable) stmt);
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pconn);
}
}
return valid;
}",0
2020,"@Override
public Connection getConnection(final String userName, final String userPassword) throws SQLException {
if (instanceKey == null) {
throw new SQLException(""Must set the ConnectionPoolDataSource "" + ""through setDataSourceName or setConnectionPoolDataSource"" + "" before calling getConnection."");
}
getConnectionCalled = true;
PooledConnectionAndInfo info = null;
try {
info = getPooledConnectionAndInfo(userName, userPassword);
} catch (final RuntimeException | SQLException e) {
closeDueToException(info);
throw e;
} catch (final Exception e) {
closeDueToException(info);
throw new SQLException(""Cannot borrow connection from pool"", e);
}
if (!(null == userPassword ? null == info.getPassword() : userPassword.equals(info.getPassword()))) {
try {
testCPDS(userName, userPassword);
} catch (final SQLException ex) {
closeDueToException(info);
throw new SQLException(""Given password did not match password used"" + "" to create the PooledConnection."", ex);
} catch (final javax.naming.NamingException ne) {
throw new SQLException(""NamingException encountered connecting to database"", ne);
}
final UserPassKey upkey = info.getUserPassKey();
final PooledConnectionManager manager = getConnectionManager(upkey);
manager.invalidate(info.getPooledConnection());
manager.setPassword(upkey.getPassword());
info = null;
for (int i = 0; i < 10; i++) {
try {
info = getPooledConnectionAndInfo(userName, userPassword);
} catch (final RuntimeException | SQLException e) {
closeDueToException(info);
throw e;
} catch (final Exception e) {
closeDueToException(info);
throw new SQLException(""Cannot borrow connection from pool"", e);
}
if (info != null && userPassword != null && userPassword.equals(info.getPassword())) {
break;
}
if (info != null) {
manager.invalidate(info.getPooledConnection());
}
info = null;
}
if (info == null) {
throw new SQLException(""Cannot borrow connection from pool - password change failure."");
}
}
final Connection connection = info.getPooledConnection().getConnection();
try {
setupDefaults(connection, userName);
connection.clearWarnings();
return connection;
} catch (final SQLException ex) {
Utils.close(connection, e -> getLogWriter().println(""ignoring exception during close: "" + e));
throw ex;
}
}",0
2021,"@Override
public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
try {
validateLifetime(pooledObject);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pooledConn = pooledObject.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pooledConn);
if (null == validationQuery) {
Duration timeoutDuration = validationQueryTimeoutDuration;
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
try {
conn = pooledConn.getConnection();
valid = conn.isValid((int) timeoutDuration.getSeconds());
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pooledConn);
try {
conn = pooledConn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) rset);
Utils.closeQuietly((AutoCloseable) stmt);
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
}
return valid;
}",0
2022,"@Override
public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
try {
validateLifetime(pooledObject);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pooledConn = pooledObject.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pooledConn);
if (null == validationQuery) {
Duration timeoutDuration = validationQueryTimeoutDuration;
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
try {
conn = pooledConn.getConnection();
valid = conn.isValid((int) timeoutDuration.getSeconds());
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pooledConn);
try {
conn = pooledConn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) rset);
Utils.closeQuietly((AutoCloseable) stmt);
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
}
return valid;
}",0
2023,"private void updateTransactionStatus() throws SQLException {
if (transactionContext != null && !transactionContext.isTransactionComplete()) {
if (transactionContext.isActive()) {
if (transactionContext != transactionRegistry.getActiveTransactionContext()) {
throw new SQLException(""Connection can not be used while enlisted in another transaction"");
}
return;
}
transactionComplete();
}
transactionContext = transactionRegistry.getActiveTransactionContext();
if (transactionContext != null && transactionContext.getSharedConnection() != null) {
@SuppressWarnings(""resource"")
final C connection = getDelegateInternal();
setDelegate(null);
if (connection != null && transactionContext.getSharedConnection() != connection) {
try {
pool.returnObject(connection);
} catch (final Exception e) {
try {
pool.invalidateObject(connection);
} catch (final Exception ignored) {
}
}
}
transactionContext.addTransactionContextListener(new CompletionListener());
@SuppressWarnings(""unchecked"")
final C shared = (C) transactionContext.getSharedConnection();
setDelegate(shared);
isSharedConnection = true;
} else {
C connection = getDelegateInternal();
if (connection == null) {
try {
connection = pool.borrowObject();
setDelegate(connection);
} catch (final Exception e) {
throw new SQLException(""Unable to acquire a new connection from the pool"", e);
}
}
if (transactionContext != null) {
transactionContext.addTransactionContextListener(new CompletionListener());
try {
transactionContext.setSharedConnection(connection);
} catch (final SQLException e) {
transactionContext = null;
try {
pool.invalidateObject(connection);
} catch (final Exception ignored) {
}
throw e;
}
}
}
clearCachedState();
}",0
2024,"@Deprecated
public static void closeQuietly(final Connection connection) {
if (connection != null) {
try {
connection.close();
} catch (final Exception e) {
}
}
}",0
2025,"public void clear() {
for (final PooledConnectionManager manager : managers.values()) {
try {
getCPDSConnectionFactoryPool(manager).clear();
} catch (final Exception ignored) {
}
}
InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
}",0
2026,"@Override
public synchronized void end(final Xid xid, final int flag) throws XAException {
Objects.requireNonNull(xid, ""xid"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
}",0
2027,"@SuppressWarnings(""resource"")
@Override
public ResultSet executeQuery(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return DelegatingResultSet.wrapResultSet(this, statement.executeQuery(sql));
} catch (final SQLException e) {
handleException(e);
throw new AssertionError();
}
}",0
2028,"@Deprecated
public static void closeQuietly(final Statement statement) {
if (statement != null) {
try {
statement.close();
} catch (final Exception e) {
}
}
}",0
2029,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
checkOpen();
try {
final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
initializeStatement(dps);
return dps;
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2030,"@Override
public Connection getConnection(final String userName, final String userPassword) throws SQLException {
if (instanceKey == null) {
throw new SQLException(""Must set the ConnectionPoolDataSource "" + ""through setDataSourceName or setConnectionPoolDataSource"" + "" before calling getConnection."");
}
getConnectionCalled = true;
PooledConnectionAndInfo info = null;
try {
info = getPooledConnectionAndInfo(userName, userPassword);
} catch (final NoSuchElementException e) {
closeDueToException(info);
throw new SQLException(""Cannot borrow connection from pool"", e);
} catch (final RuntimeException | SQLException e) {
closeDueToException(info);
throw e;
} catch (final Exception e) {
closeDueToException(info);
throw new SQLException(""Cannot borrow connection from pool"", e);
}
if (!(null == userPassword ? null == info.getPassword() : userPassword.equals(info.getPassword()))) {
try {
testCPDS(userName, userPassword);
} catch (final SQLException ex) {
closeDueToException(info);
throw new SQLException(""Given password did not match password used"" + "" to create the PooledConnection."", ex);
} catch (final javax.naming.NamingException ne) {
throw new SQLException(""NamingException encountered connecting to database"", ne);
}
final UserPassKey upkey = info.getUserPassKey();
final PooledConnectionManager manager = getConnectionManager(upkey);
manager.invalidate(info.getPooledConnection());
manager.setPassword(upkey.getPassword());
info = null;
for (int i = 0; i < 10; i++) {
try {
info = getPooledConnectionAndInfo(userName, userPassword);
} catch (final NoSuchElementException e) {
closeDueToException(info);
throw new SQLException(""Cannot borrow connection from pool"", e);
} catch (final RuntimeException | SQLException e) {
closeDueToException(info);
throw e;
} catch (final Exception e) {
closeDueToException(info);
throw new SQLException(""Cannot borrow connection from pool"", e);
}
if (info != null && userPassword != null && userPassword.equals(info.getPassword())) {
break;
}
if (info != null) {
manager.invalidate(info.getPooledConnection());
}
info = null;
}
if (info == null) {
throw new SQLException(""Cannot borrow connection from pool - password change failure."");
}
}
final Connection con = info.getPooledConnection().getConnection();
try {
setupDefaults(con, userName);
con.clearWarnings();
return con;
} catch (final SQLException ex) {
try {
con.close();
} catch (final Exception exc) {
getLogWriter().println(""ignoring exception during close: "" + exc);
}
throw ex;
}
}",0
2031,"@Override
public void closePool(final String userName) throws SQLException {
synchronized (this) {
if (userName == null || !userName.equals(this.userName)) {
return;
}
}
try {
pool.close();
} catch (final Exception ex) {
throw new SQLException(""Error closing connection pool"", ex);
}
}",1
2032,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency));
initializeStatement(dps);
return dps;
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2033,"private void validatePropertyNames(final Reference ref, final Name name, final List<String> warnMessages, final List<String> infoMessages) {
final List<String> allPropsAsList = Arrays.asList(ALL_PROPERTIES);
final String nameString = name != null ? ""Name = "" + name.toString() + "" "" : """";
if (NUPROP_WARNTEXT != null && !NUPROP_WARNTEXT.isEmpty()) {
for (final String propertyName : NUPROP_WARNTEXT.keySet()) {
final RefAddr ra = ref.get(propertyName);
if (ra != null && !allPropsAsList.contains(ra.getType())) {
final StringBuilder stringBuilder = new StringBuilder(nameString);
final String propertyValue = Objects.toString(ra.getContent(), null);
stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append("" You have set value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property, which is being ignored."");
warnMessages.add(stringBuilder.toString());
}
}
}
final Enumeration<RefAddr> allRefAddrs = ref.getAll();
while (allRefAddrs.hasMoreElements()) {
final RefAddr ra = allRefAddrs.nextElement();
final String propertyName = ra.getType();
if (!(allPropsAsList.contains(propertyName) || NUPROP_WARNTEXT.containsKey(propertyName) || SILENT_PROPERTIES.contains(propertyName))) {
final String propertyValue = Objects.toString(ra.getContent(), null);
final StringBuilder stringBuilder = new StringBuilder(nameString);
stringBuilder.append(""Ignoring unknown property: "").append(""value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property"");
infoMessages.add(stringBuilder.toString());
}
}
}",0
2034,"private void validatePropertyNames(final Reference ref, final Name name, final List<String> warnMessages, final List<String> infoMessages) {
final List<String> allPropsAsList = Arrays.asList(ALL_PROPERTIES);
final String nameString = name != null ? ""Name = "" + name.toString() + "" "" : """";
if (NUPROP_WARNTEXT != null && !NUPROP_WARNTEXT.isEmpty()) {
for (final String propertyName : NUPROP_WARNTEXT.keySet()) {
final RefAddr ra = ref.get(propertyName);
if (ra != null && !allPropsAsList.contains(ra.getType())) {
final StringBuilder stringBuilder = new StringBuilder(nameString);
final String propertyValue = Objects.toString(ra.getContent(), null);
stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append("" You have set value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property, which is being ignored."");
warnMessages.add(stringBuilder.toString());
}
}
}
final Enumeration<RefAddr> allRefAddrs = ref.getAll();
while (allRefAddrs.hasMoreElements()) {
final RefAddr ra = allRefAddrs.nextElement();
final String propertyName = ra.getType();
if (!(allPropsAsList.contains(propertyName) || NUPROP_WARNTEXT.containsKey(propertyName) || SILENT_PROPERTIES.contains(propertyName))) {
final String propertyValue = Objects.toString(ra.getContent(), null);
final StringBuilder stringBuilder = new StringBuilder(nameString);
stringBuilder.append(""Ignoring unknown property: "").append(""value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property"");
infoMessages.add(stringBuilder.toString());
}
}
}",1
2035,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2036,"public void invalidateConnection(final Connection conn) throws SQLException {
if (conn instanceof PoolGuardConnectionWrapper) {
final PoolGuardConnectionWrapper pgconn = (PoolGuardConnectionWrapper) conn;
@SuppressWarnings(""unchecked"")
final ObjectPool<Connection> pool = (ObjectPool<Connection>) pgconn.pool;
try {
pool.invalidateObject(pgconn.getDelegateInternal());
} catch (final Exception e) {
}
} else {
throw new SQLException(""Invalid connection class"");
}
}",0
2037,"PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
}
try {
return pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
2038,"@Override
protected void finalize() throws Throwable {
try {
connection.close();
} catch (final Exception ignored) {
}
if (logicalConnection != null && !logicalConnection.isClosed()) {
throw new SQLException(""PooledConnection was gc'ed, without its last Connection being closed."");
}
}",1
2039,"public char[] getUserPassword() {
return userPassword;
}",1
2040,"@Override
public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, autoGeneratedKeys));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2041,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue());
}",0
2042,"PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, autoGeneratedKeys);
}
try {
return pStmtPool.borrowObject(createKey(sql, autoGeneratedKeys));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
2043,"public static void closeQuietly(final AutoCloseable autoCloseable) {
if (autoCloseable != null) {
try {
autoCloseable.close();
} catch (final Exception ignored) {
}
}
}",1
2044,"PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, columnIndexes);
}
try {
return pStmtPool.borrowObject(createKey(sql, columnIndexes));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
2045,"public static BasicDataSource createDataSource(final Properties properties) throws Exception {
final BasicDataSource dataSource = new BasicDataSource();
String value = properties.getProperty(PROP_DEFAULT_AUTO_COMMIT);
if (value != null) {
dataSource.setDefaultAutoCommit(Boolean.valueOf(value));
}
value = properties.getProperty(PROP_DEFAULT_READ_ONLY);
if (value != null) {
dataSource.setDefaultReadOnly(Boolean.valueOf(value));
}
value = properties.getProperty(PROP_DEFAULT_TRANSACTION_ISOLATION);
if (value != null) {
int level = PoolableConnectionFactory.UNKNOWN_TRANSACTION_ISOLATION;
if (""NONE"".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_NONE;
} else if (""READ_COMMITTED"".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_READ_COMMITTED;
} else if (""READ_UNCOMMITTED"".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_READ_UNCOMMITTED;
} else if (""REPEATABLE_READ"".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_REPEATABLE_READ;
} else if (""SERIALIZABLE"".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_SERIALIZABLE;
} else {
try {
level = Integer.parseInt(value);
} catch (final NumberFormatException e) {
System.err.println(""Could not parse defaultTransactionIsolation: "" + value);
System.err.println(""WARNING: defaultTransactionIsolation not set"");
System.err.println(""using default value of database driver"");
level = PoolableConnectionFactory.UNKNOWN_TRANSACTION_ISOLATION;
}
}
dataSource.setDefaultTransactionIsolation(level);
}
value = properties.getProperty(PROP_DEFAULT_CATALOG);
if (value != null) {
dataSource.setDefaultCatalog(value);
}
value = properties.getProperty(PROP_DEFAULT_SCHEMA);
if (value != null) {
dataSource.setDefaultSchema(value);
}
value = properties.getProperty(PROP_CACHE_STATE);
if (value != null) {
dataSource.setCacheState(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_DRIVER_CLASS_NAME);
if (value != null) {
dataSource.setDriverClassName(value);
}
value = properties.getProperty(PROP_LIFO);
if (value != null) {
dataSource.setLifo(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_MAX_TOTAL);
if (value != null) {
dataSource.setMaxTotal(Integer.parseInt(value));
}
value = properties.getProperty(PROP_MAX_IDLE);
if (value != null) {
dataSource.setMaxIdle(Integer.parseInt(value));
}
value = properties.getProperty(PROP_MIN_IDLE);
if (value != null) {
dataSource.setMinIdle(Integer.parseInt(value));
}
value = properties.getProperty(PROP_INITIAL_SIZE);
if (value != null) {
dataSource.setInitialSize(Integer.parseInt(value));
}
value = properties.getProperty(PROP_MAX_WAIT_MILLIS);
if (value != null) {
dataSource.setMaxWait(Duration.ofMillis(Long.parseLong(value)));
}
value = properties.getProperty(PROP_TEST_ON_CREATE);
if (value != null) {
dataSource.setTestOnCreate(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_TEST_ON_BORROW);
if (value != null) {
dataSource.setTestOnBorrow(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_TEST_ON_RETURN);
if (value != null) {
dataSource.setTestOnReturn(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_TIME_BETWEEN_EVICTION_RUNS_MILLIS);
if (value != null) {
dataSource.setDurationBetweenEvictionRuns(Duration.ofMillis(Long.parseLong(value)));
}
value = properties.getProperty(PROP_NUM_TESTS_PER_EVICTION_RUN);
if (value != null) {
dataSource.setNumTestsPerEvictionRun(Integer.parseInt(value));
}
value = properties.getProperty(PROP_MIN_EVICTABLE_IDLE_TIME_MILLIS);
if (value != null) {
dataSource.setMinEvictableIdle(Duration.ofMillis(Long.parseLong(value)));
}
value = properties.getProperty(PROP_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
if (value != null) {
dataSource.setSoftMinEvictableIdle(Duration.ofMillis(Long.parseLong(value)));
}
value = properties.getProperty(PROP_EVICTION_POLICY_CLASS_NAME);
if (value != null) {
dataSource.setEvictionPolicyClassName(value);
}
value = properties.getProperty(PROP_TEST_WHILE_IDLE);
if (value != null) {
dataSource.setTestWhileIdle(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_PASSWORD);
if (value != null) {
dataSource.setPassword(value);
}
value = properties.getProperty(PROP_URL);
if (value != null) {
dataSource.setUrl(value);
}
value = properties.getProperty(PROP_USER_NAME);
if (value != null) {
dataSource.setUsername(value);
}
value = properties.getProperty(PROP_VALIDATION_QUERY);
if (value != null) {
dataSource.setValidationQuery(value);
}
value = properties.getProperty(PROP_VALIDATION_QUERY_TIMEOUT);
if (value != null) {
dataSource.setValidationQueryTimeout(Duration.ofSeconds(Integer.parseInt(value)));
}
value = properties.getProperty(PROP_ACCESS_TO_UNDERLYING_CONNECTION_ALLOWED);
if (value != null) {
dataSource.setAccessToUnderlyingConnectionAllowed(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_REMOVE_ABANDONED_ON_BORROW);
if (value != null) {
dataSource.setRemoveAbandonedOnBorrow(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_REMOVE_ABANDONED_ON_MAINTENANCE);
if (value != null) {
dataSource.setRemoveAbandonedOnMaintenance(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_REMOVE_ABANDONED_TIMEOUT);
if (value != null) {
dataSource.setRemoveAbandonedTimeout(Duration.ofSeconds(Integer.parseInt(value)));
}
value = properties.getProperty(PROP_LOG_ABANDONED);
if (value != null) {
dataSource.setLogAbandoned(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_ABANDONED_USAGE_TRACKING);
if (value != null) {
dataSource.setAbandonedUsageTracking(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_POOL_PREPARED_STATEMENTS);
if (value != null) {
dataSource.setPoolPreparedStatements(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_CLEAR_STATEMENT_POOL_ON_RETURN);
if (value != null) {
dataSource.setClearStatementPoolOnReturn(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_MAX_OPEN_PREPARED_STATEMENTS);
if (value != null) {
dataSource.setMaxOpenPreparedStatements(Integer.parseInt(value));
}
value = properties.getProperty(PROP_CONNECTION_INIT_SQLS);
if (value != null) {
dataSource.setConnectionInitSqls(parseList(value, ';'));
}
value = properties.getProperty(PROP_CONNECTION_PROPERTIES);
if (value != null) {
final Properties p = getProperties(value);
final Enumeration<?> e = p.propertyNames();
while (e.hasMoreElements()) {
final String propertyName = (String) e.nextElement();
dataSource.addConnectionProperty(propertyName, p.getProperty(propertyName));
}
}
value = properties.getProperty(PROP_MAX_CONN_LIFETIME_MILLIS);
if (value != null) {
dataSource.setMaxConn(Duration.ofMillis(Long.parseLong(value)));
}
value = properties.getProperty(PROP_LOG_EXPIRED_CONNECTIONS);
if (value != null) {
dataSource.setLogExpiredConnections(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_JMX_NAME);
if (value != null) {
dataSource.setJmxName(value);
}
value = properties.getProperty(PROP_ENABLE_AUTO_COMMIT_ON_RETURN);
if (value != null) {
dataSource.setAutoCommitOnReturn(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_ROLLBACK_ON_RETURN);
if (value != null) {
dataSource.setRollbackOnReturn(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_DEFAULT_QUERY_TIMEOUT);
if (value != null) {
dataSource.setDefaultQueryTimeout(Duration.ofSeconds(Integer.valueOf(value)));
}
value = properties.getProperty(PROP_FAST_FAIL_VALIDATION);
if (value != null) {
dataSource.setFastFailValidation(Boolean.parseBoolean(value));
}
value = properties.getProperty(PROP_DISCONNECTION_SQL_CODES);
if (value != null) {
dataSource.setDisconnectionSqlCodes(parseList(value, ','));
}
value = properties.getProperty(PROP_CONNECTION_FACTORY_CLASS_NAME);
if (value != null) {
dataSource.setConnectionFactoryClassName(value);
}
if (dataSource.getInitialSize() > 0) {
dataSource.getLogWriter();
}
return dataSource;
}",1
2046,"public String[] getColumnNames() {
return columnNames;
}",1
2047,"public void validateConnection(final PoolableConnection conn) throws SQLException {
if (conn.isClosed()) {
throw new SQLException(""validateConnection: connection closed"");
}
conn.validate(validationQuery, validationQueryTimeoutSeconds);
}",0
2048,"@Override
public boolean validateObject(final PooledObject<PooledConnectionAndInfo> p) {
try {
validateLifetime(p);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pconn = p.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pconn);
if (null == validationQuery) {
int timeoutSeconds = validationQueryTimeoutSeconds;
if (timeoutSeconds < 0) {
timeoutSeconds = 0;
}
try {
conn = pconn.getConnection();
valid = conn.isValid(timeoutSeconds);
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pconn);
try {
conn = pconn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly(rset);
Utils.closeQuietly(stmt);
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
}
return valid;
}",0
2049,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue(), resultSetHoldability.intValue());
}",0
2050,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, autoGeneratedKeys.intValue());
}",0
2051,"@Override
public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
try {
final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this, connection.prepareStatement(sql, autoGeneratedKeys));
initializeStatement(dps);
return dps;
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2052,"@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this, connection.prepareStatement(sql));
initializeStatement(dps);
return dps;
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2053,"@Override
public long executeLargeUpdate(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
2054,"protected void checkOpen() throws SQLException {
if (closed) {
if (null != connection) {
String label = """";
try {
label = connection.toString();
} catch (final Exception ignored) {
}
throw new SQLException(""Connection "" + label + "" is closed."");
}
throw new SQLException(""Connection is null."");
}
}",0
2055,"public void setPassword(final char[] userPassword) {
this.userPassword = userPassword;
}",1
2056,"PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, columnIndexes);
}
try {
return pStmtPool.borrowObject(createKey(sql, columnIndexes));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
2057,"@Override
public boolean execute(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0
2058,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnIndexes)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2059,"private void validatePropertyNames(final Reference ref, final Name name, final List<String> warnings, final List<String> infoMessages) {
final List<String> allPropsAsList = Arrays.asList(ALL_PROPERTIES);
final String nameString = name != null ? ""Name = "" + name.toString() + "" "" : """";
if (NUPROP_WARNTEXT != null && !NUPROP_WARNTEXT.isEmpty()) {
for (final String propertyName : NUPROP_WARNTEXT.keySet()) {
final RefAddr ra = ref.get(propertyName);
if (ra != null && !allPropsAsList.contains(ra.getType())) {
final StringBuilder stringBuilder = new StringBuilder(nameString);
final String propertyValue = ra.getContent().toString();
stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append("" You have set value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property, which is being ignored."");
warnings.add(stringBuilder.toString());
}
}
}
final Enumeration<RefAddr> allRefAddrs = ref.getAll();
while (allRefAddrs.hasMoreElements()) {
final RefAddr ra = allRefAddrs.nextElement();
final String propertyName = ra.getType();
if (!(allPropsAsList.contains(propertyName) || NUPROP_WARNTEXT.containsKey(propertyName) || SILENT_PROPERTIES.contains(propertyName))) {
final String propertyValue = ra.getContent().toString();
final StringBuilder stringBuilder = new StringBuilder(nameString);
stringBuilder.append(""Ignoring unknown property: "").append(""value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property"");
infoMessages.add(stringBuilder.toString());
}
}
}",0
2060,"public void invalidateConnection(final Connection conn) throws SQLException {
if (!(conn instanceof PoolGuardConnectionWrapper)) {
throw new SQLException(""Invalid connection class"");
}
final PoolGuardConnectionWrapper pgconn = (PoolGuardConnectionWrapper) conn;
@SuppressWarnings(""unchecked"")
final ObjectPool<Connection> pool = (ObjectPool<Connection>) pgconn.pool;
try {
pool.invalidateObject(pgconn.getDelegateInternal());
} catch (final Exception e) {
}
}",0
2061,"PreparedStatement prepareStatement(final String sql) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql);
}
try {
return pStmtPool.borrowObject(createKey(sql));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
2062,"@Override
public boolean execute(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0
2063,"@Override
public int executeUpdate(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
2064,"protected void initializeConnection(final Connection conn) throws SQLException {
final Collection<String> sqls = connectionInitSqls;
if (conn.isClosed()) {
throw new SQLException(""initializeConnection: connection closed"");
}
if (null != sqls) {
try (Statement stmt = conn.createStatement()) {
for (final String sql : sqls) {
Objects.requireNonNull(sql, ""null connectionInitSqls element"");
stmt.execute(sql);
}
}
}
}",1
2065,"@Override
public long executeLargeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
2066,"public synchronized void setPool(final ObjectPool<PoolableConnection> pool) {
if (null != this.pool && pool != this.pool) {
try {
this.pool.close();
} catch (final Exception e) {
}
}
this.pool = pool;
}",0
2067,"public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource, final String userName, final char[] userPassword, final TransactionSynchronizationRegistry transactionSynchronizationRegistry) {
Objects.requireNonNull(transactionManager, ""transactionManager is null"");
Objects.requireNonNull(xaDataSource, ""xaDataSource is null"");
this.transactionRegistry = new TransactionRegistry(transactionManager, transactionSynchronizationRegistry);
this.xaDataSource = xaDataSource;
this.userName = userName;
this.userPassword = userPassword;
}",1
2068,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnNames)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2069,"public char[] getUserPassword() {
return userPassword;
}",1
2070,"PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
}
try {
return pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
2071,"@Override
public void close() throws SQLException {
if (isClosed()) {
return;
}
final List<Exception> thrownList = new ArrayList<>();
try {
if (connection != null) {
connection.removeTrace(this);
connection = null;
}
final List<AbandonedTrace> resultSetList = getTrace();
if (resultSetList != null) {
final int size = resultSetList.size();
final ResultSet[] resultSets = resultSetList.toArray(Utils.EMPTY_RESULT_SET_ARRAY);
for (final ResultSet resultSet : resultSets) {
if (resultSet != null) {
try {
resultSet.close();
} catch (final Exception e) {
if (connection != null) {
connection.handleExceptionNoThrow(e);
}
thrownList.add(e);
}
}
}
clearTrace();
}
if (statement != null) {
try {
statement.close();
} catch (final Exception e) {
if (connection != null) {
connection.handleExceptionNoThrow(e);
}
thrownList.add(e);
}
}
} finally {
closed = true;
statement = null;
if (!thrownList.isEmpty()) {
throw new SQLExceptionList(thrownList);
}
}
}",1
2072,"@Deprecated
public static void closeQuietly(final ResultSet resultSet) {
if (resultSet != null) {
try {
resultSet.close();
} catch (final Exception e) {
}
}
}",0
2073,"@Override
public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
2074,"public int[] getColumnIndexes() {
return columnIndexes;
}",1
2075,"private void closeConnectionPool() {
final GenericObjectPool<?> oldPool = connectionPool;
connectionPool = null;
try {
if (oldPool != null) {
oldPool.close();
}
} catch (final Exception e) {
}
}",1
2076,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2077,"protected static final HashMap<String, ObjectPool<? extends Connection>> pools = new HashMap<>();",0
2078,"public char[] getPasswordCharArray() {
return userPassword;
}",1
2079,"protected void checkOpen() throws SQLException {
if (closed) {
if (null != connection) {
String label = """";
try {
label = connection.toString();
} catch (final Exception ex) {
}
throw new SQLException(""Connection "" + label + "" is closed."");
}
throw new SQLException(""Connection is null."");
}
}",0
2080,"@Override
public long executeLargeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
2081,"@Override
public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
2082,"PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, columnNames);
}
try {
return pStmtPool.borrowObject(createKey(sql, columnNames));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0
2083,"@Override
public boolean validateObject(final PooledObject<PooledConnectionAndInfo> p) {
try {
validateLifetime(p);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pconn = p.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pconn);
if (null == validationQuery) {
int timeoutSeconds = validationQueryTimeoutSeconds;
if (timeoutSeconds < 0) {
timeoutSeconds = 0;
}
try {
conn = pconn.getConnection();
valid = conn.isValid(timeoutSeconds);
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pconn);
try {
conn = pconn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly(rset);
Utils.closeQuietly(stmt);
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
}
return valid;
}",0
2084,"@Override
public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
2085,"@Override
public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0
2086,"@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnNames));
initializeStatement(dps);
return dps;
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2087,"@Override
public boolean execute(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0
2088,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, autoGeneratedKeys)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2089,private UserPassKey userPassKey;,0
2090,private char[] userPassword;,0
2091,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2092,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, autoGeneratedKeys);
}",0
2093,"@Override
public long executeLargeUpdate(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0
2094,private boolean closed;,0
2095,"@Override
public synchronized void rollback(final Xid xid) throws XAException {
Objects.requireNonNull(xid, ""xid"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
try {
connection.rollback();
} catch (final SQLException e) {
throw (XAException) new XAException().initCause(e);
} finally {
try {
connection.setAutoCommit(originalAutoCommit);
} catch (final SQLException ignored) {
}
this.currentXid = null;
}
}",0
2096,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
}",0
2097,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2098,"@Override
public void close() {
for (final PooledConnectionManager manager : managers.values()) {
try {
getCPDSConnectionFactoryPool(manager).close();
} catch (final Exception closePoolException) {
}
}
InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
}",0
2099,"@Override
public long[] executeLargeBatch() throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeBatch();
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0
2100,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2101,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2102,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2103,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2104,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2105,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2106,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2107,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2108,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2109,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2110,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2111,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2112,private final List<ErrorMessage> errors;,0
2113,"@Override
public String toString() {
Formatter formatter = new Formatter().format(""CallMethodRule[methodName=%s, paramCount=%s, paramTypes={"", this.methodName, this.paramTypes.length);
if (this.paramTypes != null) {
for (int i = 0; i < this.paramTypes.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(this.paramTypes[i].getName());
}
}
return formatter.format(""}]"").toString();
}",0
2114,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (this.paramCount > 0) {
parameters = (Object[]) this.getDigester().popParams();
if (this.getDigester().getLog().isTraceEnabled()) {
Formatter formatter = new Formatter(""[CallMethodRule]"");
for (int i = 0, size = parameters.length; i < size; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""(%s) %s"", i, parameters[i]);
}
this.getDigester().getLog().trace(formatter.toString());
}
if (this.paramCount == 1 && parameters[0] == null) {
return;
}
} else if (this.paramTypes != null && this.paramTypes.length != 0) {
if (this.bodyText == null) {
return;
}
parameters = new Object[] { this.bodyText };
} else {
}
Object[] paramValues = new Object[this.paramTypes.length];
for (int i = 0; i < this.paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(this.paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (this.targetOffset >= 0) {
target = this.getDigester().peek(this.targetOffset);
} else {
target = this.getDigester().peek(this.getDigester().getCount() + this.targetOffset);
}
if (target == null) {
throw this.getDigester().createSAXException(String.format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", this.getDigester().getMatch(), this.targetOffset, this.getDigester().getCount()));
}
if (this.getDigester().getLog().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", this.getDigester().getMatch(), target.getClass().getName(), this.methodName);
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""%s/%s"", (paramValues[i] == null ? ""null"" : paramValues[i].toString()), (this.paramTypes[i] == null ? ""null"" : this.paramTypes[i].getName()));
}
formatter.format("")"");
this.getDigester().getLog().debug(formatter.toString());
}
Object result = null;
if (this.useExactMatch) {
result = MethodUtils.invokeExactMethod(target, this.methodName, paramValues, this.paramTypes);
} else {
result = MethodUtils.invokeMethod(target, this.methodName, paramValues, this.paramTypes);
}
processMethodCallResult(result);
}",0
2115,private String currChildNamespaceURI = null;,0
2116,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
StringBuilder sb = new StringBuilder();
sb.append(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(getDigester().getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (getDigester().getLogger().isDebugEnabled()) {
StringBuilder sb = new StringBuilder(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
getDigester().getLogger().debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2117,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
StringBuilder sb = new StringBuilder();
sb.append(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(getDigester().getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (getDigester().getLogger().isDebugEnabled()) {
StringBuilder sb = new StringBuilder(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
getDigester().getLogger().debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2118,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2119,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2120,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2121,private String currChildNamespaceURI = null;,0
2122,"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0
2123,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2124,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className' ar 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2125,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2126,"// TODO: Consider making following four constants static in 2.0
public final String DFLT_PLUGIN_CLASS_ATTR_NS = null;",0
2127,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2128,"public static String DFLT_METHOD_ATTR = ""method"";",0
2129,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2130,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2131,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2132,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2133,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2134,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2135,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2136,"public static String DFLT_METHOD_ATTR = ""method"";",0
2137,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2138,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2139,"public static String DFLT_FALSEVAL = ""false"";",0
2140,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2141,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2142,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2143,"protected String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2144,protected String namespaceURI = null;,0
2145,private String currChildNamespaceURI = null;,0
2146,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2147,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2148,protected static String versionNumber = null;,0
2149,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2150,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2151,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2152,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2153,protected static float version;,0
2154,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2155,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2156,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2157,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2158,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2159,"public static String DFLT_METHOD_ATTR = ""method"";",0
2160,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2161,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2162,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2163,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2164,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2165,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2166,"public static String DFLT_METHOD_ATTR = ""method"";",0
2167,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2168,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2169,"public static String DFLT_FALSEVAL = ""false"";",0
2170,private FromXmlRuleSet ruleSet;,0
2171,"private void invoke() throws Exception {
Object child = getChild();
Object parent = getParent();
if (getDigester().getLogger().isDebugEnabled()) {
if (parent == null) {
getDigester().getLogger().debug(format(""[%s]{%s} Call [NULL PARENT].%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), methodName, child));
} else {
getDigester().getLogger().debug(format(""[%s]{%s} Call %s.%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), parent.getClass().getName(), methodName, child));
}
}
Class<?>[] paramTypes = new Class<?>[1];
if (paramType != null) {
paramTypes[0] = getDigester().getClassLoader().loadClass(paramTypeName);
} else {
paramTypes[0] = child.getClass();
}
if (useExactMatch) {
invokeExactMethod(parent, methodName, new Object[] { child }, paramTypes);
} else {
invokeMethod(parent, methodName, new Object[] { child }, paramTypes);
}
}",0
2172,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2173,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2174,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2175,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2176,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2177,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2178,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2179,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2180,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2181,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2182,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2183,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2184,"@Override
public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2185,"@Override
public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2186,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2187,protected String namespaceURI = null;,0
2188,private String currChildNamespaceURI = null;,0
2189,private final int cacheSize = 255;,0
2190,private final int cacheSize = 255;,0
2191,"private final Map<Class<?>, FromAnnotationsRuleSet> data = new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
}
};",0
2192,private final float loadFactor = 0.75f;,0
2193,private final float loadFactor = 0.75f;,0
2194,"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0
2195,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2196,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2197,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2198,protected static float version;,0
2199,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2200,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2201,"public static SAXParser newSAXParser(Properties properties) throws ParserConfigurationException, SAXException, SAXNotSupportedException {
SAXParserFactory factory = (SAXParserFactory) properties.get(""SAXParserFactory"");
if (versionNumber == null) {
versionNumber = getXercesVersion();
version = new Float(versionNumber).floatValue();
}
// Note: 2.2 is completely broken (with XML Schema).
if (version > 2.1) {
configureXerces(factory);
return factory.newSAXParser();
} else {
SAXParser parser = factory.newSAXParser();
configureOldXerces(parser, properties);
return parser;
}
}",0
2202,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2203,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class<?> versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2204,protected static String versionNumber = null;,0
2205,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2206,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2207,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2208,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2209,"public static String DFLT_METHOD_ATTR = ""method"";",0
2210,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2211,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2212,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2213,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2214,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2215,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2216,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2217,"public static String DFLT_METHOD_ATTR = ""method"";",0
2218,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2219,"public static String DFLT_FALSEVAL = ""false"";",0
2220,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2221,"@Override
public String toString() {
Formatter formatter = new Formatter().format(""CallMethodRule[methodName=%s, paramCount=%s, paramTypes={"", this.methodName, this.paramTypes.length);
if (this.paramTypes != null) {
for (int i = 0; i < this.paramTypes.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(this.paramTypes[i].getName());
}
}
return formatter.format(""}]"").toString();
}",0
2222,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (this.paramTypes.length > 0) {
parameters = (Object[]) this.getDigester().popParams();
if (this.getDigester().getLog().isTraceEnabled()) {
Formatter formatter = new Formatter(""[CallMethodRule]"");
for (int i = 0, size = parameters.length; i < size; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""(%s) %s"", i, parameters[i]);
}
this.getDigester().getLog().trace(formatter.toString());
}
if (this.paramTypes.length == 1 && parameters[0] == null) {
return;
}
} else if (this.paramTypes != null && this.paramTypes.length != 0) {
if (this.bodyText == null) {
return;
}
parameters = new Object[] { this.bodyText };
} else {
}
Object[] paramValues = new Object[this.paramTypes.length];
for (int i = 0; i < this.paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(this.paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (this.targetOffset >= 0) {
target = this.getDigester().peek(this.targetOffset);
} else {
target = this.getDigester().peek(this.getDigester().getCount() + this.targetOffset);
}
if (target == null) {
throw this.getDigester().createSAXException(String.format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", this.getDigester().getMatch(), this.targetOffset, this.getDigester().getCount()));
}
if (this.getDigester().getLog().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", this.getDigester().getMatch(), target.getClass().getName(), this.methodName);
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""%s/%s"", (paramValues[i] == null ? ""null"" : paramValues[i].toString()), (this.paramTypes[i] == null ? ""null"" : this.paramTypes[i].getName()));
}
formatter.format("")"");
this.getDigester().getLog().debug(formatter.toString());
}
Object result = null;
if (this.useExactMatch) {
result = MethodUtils.invokeExactMethod(target, this.methodName, paramValues, this.paramTypes);
} else {
result = MethodUtils.invokeMethod(target, this.methodName, paramValues, this.paramTypes);
}
processMethodCallResult(result);
}",0
2223,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (this.paramTypes.length > 0) {
parameters = (Object[]) this.getDigester().popParams();
if (this.getDigester().getLog().isTraceEnabled()) {
Formatter formatter = new Formatter(""[CallMethodRule]"");
for (int i = 0, size = parameters.length; i < size; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""(%s) %s"", i, parameters[i]);
}
this.getDigester().getLog().trace(formatter.toString());
}
if (this.paramTypes.length == 1 && parameters[0] == null) {
return;
}
} else if (this.paramTypes != null && this.paramTypes.length != 0) {
if (this.bodyText == null) {
return;
}
parameters = new Object[] { this.bodyText };
} else {
}
Object[] paramValues = new Object[this.paramTypes.length];
for (int i = 0; i < this.paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(this.paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (this.targetOffset >= 0) {
target = this.getDigester().peek(this.targetOffset);
} else {
target = this.getDigester().peek(this.getDigester().getCount() + this.targetOffset);
}
if (target == null) {
throw this.getDigester().createSAXException(String.format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", this.getDigester().getMatch(), this.targetOffset, this.getDigester().getCount()));
}
if (this.getDigester().getLog().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", this.getDigester().getMatch(), target.getClass().getName(), this.methodName);
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""%s/%s"", (paramValues[i] == null ? ""null"" : paramValues[i].toString()), (this.paramTypes[i] == null ? ""null"" : this.paramTypes[i].getName()));
}
formatter.format("")"");
this.getDigester().getLog().debug(formatter.toString());
}
Object result = null;
if (this.useExactMatch) {
result = MethodUtils.invokeExactMethod(target, this.methodName, paramValues, this.paramTypes);
} else {
result = MethodUtils.invokeMethod(target, this.methodName, paramValues, this.paramTypes);
}
processMethodCallResult(result);
}",0
2224,private final List<ErrorMessage> errors;,0
2225,private String currChildNamespaceURI = null;,0
2226,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2227,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2228,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2229,"public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
if (saxLog.isDebugEnabled()) {
saxLog.debug(""resolveEntity('"" + publicId + ""', '"" + systemId + ""')"");
}
if (publicId != null)
this.publicId = publicId;
String entityURL = null;
if (publicId != null) {
entityURL = (String) entityValidator.get(publicId);
}
if (schemaLocation != null && entityURL == null && systemId != null) {
entityURL = (String) entityValidator.get(systemId);
}
if (entityURL == null) {
if (systemId == null) {
if (log.isDebugEnabled()) {
log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
}
return (null);
} else {
if (log.isDebugEnabled()) {
log.debug("" Trying to resolve using system ID '"" + systemId + ""'"");
}
entityURL = systemId;
}
}
if (log.isDebugEnabled()) {
log.debug("" Resolving to alternate DTD '"" + entityURL + ""'"");
}
try {
return createInputSourceFromURL(entityURL);
} catch (Exception e) {
throw createSAXException(e);
}
}",0
2230,protected String namespaceURI = null;,0
2231,private String currChildNamespaceURI = null;,0
2232,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2233,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2234,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2235,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2236,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2237,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2238,protected static float version;,0
2239,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2240,"public static SAXParser newSAXParser(Properties properties) throws ParserConfigurationException, SAXException, SAXNotSupportedException {
SAXParserFactory factory = (SAXParserFactory) properties.get(""SAXParserFactory"");
if (versionNumber == null) {
versionNumber = getXercesVersion();
version = new Float(versionNumber).floatValue();
}
// Note: 2.2 is completely broken (with XML Schema).
if (version > 2.1) {
configureXerces(factory);
return factory.newSAXParser();
} else {
SAXParser parser = factory.newSAXParser();
configureOldXerces(parser, properties);
return parser;
}
}",0
2241,protected static String versionNumber = null;,0
2242,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2243,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2244,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2245,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2246,"public static String DFLT_METHOD_ATTR = ""method"";",0
2247,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2248,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2249,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2250,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2251,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2252,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2253,"public static String DFLT_METHOD_ATTR = ""method"";",0
2254,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2255,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2256,"public static String DFLT_FALSEVAL = ""false"";",0
2257,private FromXmlRuleSet ruleSet;,0
2258,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2259,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2260,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2261,"protected String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2262,protected String namespaceURI = null;,0
2263,private String currChildNamespaceURI = null;,0
2264,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2265,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2266,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2267,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2268,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2269,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2270,protected static String versionNumber = null;,0
2271,protected static float version;,0
2272,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2273,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2274,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2275,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2276,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2277,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2278,"public static String DFLT_METHOD_ATTR = ""method"";",0
2279,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2280,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2281,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2282,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2283,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2284,"public static String DFLT_METHOD_ATTR = ""method"";",0
2285,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2286,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2287,"public static String DFLT_FALSEVAL = ""false"";",0
2288,private FromXmlRuleSet ruleSet;,0
2289,private final List<ErrorMessage> errors;,0
2290,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2291,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2292,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2293,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2294,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2295,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2296,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2297,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2298,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2299,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2300,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2301,"@Override
public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2302,"@Override
public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2303,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2304,protected String namespaceURI = null;,0
2305,private String currChildNamespaceURI = null;,0
2306,private final int cacheSize = 255;,0
2307,private final int cacheSize = 255;,0
2308,private final float loadFactor = 0.75f;,0
2309,"private final Map<Class<?>, FromAnnotationsRuleSet> data = new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
}
};",0
2310,"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0
2311,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2312,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2313,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2314,"public static SAXParser newSAXParser(Properties properties) throws ParserConfigurationException, SAXException, SAXNotSupportedException {
SAXParserFactory factory = (SAXParserFactory) properties.get(""SAXParserFactory"");
if (versionNumber == null) {
versionNumber = getXercesVersion();
version = new Float(versionNumber).floatValue();
}
// Note: 2.2 is completely broken (with XML Schema).
if (version > 2.1) {
configureXerces(factory);
return factory.newSAXParser();
} else {
SAXParser parser = factory.newSAXParser();
configureOldXerces(parser, properties);
return parser;
}
}",0
2315,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class<?> versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2316,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2317,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2318,protected static float version;,0
2319,protected static String versionNumber = null;,0
2320,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2321,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2322,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2323,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2324,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2325,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2326,"public static String DFLT_METHOD_ATTR = ""method"";",0
2327,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2328,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2329,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2330,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2331,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2332,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2333,"public static String DFLT_METHOD_ATTR = ""method"";",0
2334,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2335,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2336,"public static String DFLT_FALSEVAL = ""false"";",0
2337,"@Override
public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2338,"@Override
public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2339,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2340,protected String namespaceURI = null;,0
2341,private String currChildNamespaceURI = null;,0
2342,"private final Map<Class<?>, FromAnnotationsRuleSet> data = new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
}
};",0
2343,private final int cacheSize = 255;,0
2344,private final int cacheSize = 255;,0
2345,private final float loadFactor = 0.75f;,0
2346,private final float loadFactor = 0.75f;,0
2347,"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0
2348,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2349,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2350,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2351,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2352,"public static SAXParser newSAXParser(Properties properties) throws ParserConfigurationException, SAXException, SAXNotSupportedException {
SAXParserFactory factory = (SAXParserFactory) properties.get(""SAXParserFactory"");
if (versionNumber == null) {
versionNumber = getXercesVersion();
version = new Float(versionNumber).floatValue();
}
// Note: 2.2 is completely broken (with XML Schema).
if (version > 2.1) {
configureXerces(factory);
return factory.newSAXParser();
} else {
SAXParser parser = factory.newSAXParser();
configureOldXerces(parser, properties);
return parser;
}
}",0
2353,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2354,protected static float version;,0
2355,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class<?> versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2356,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2357,protected static String versionNumber = null;,0
2358,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2359,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2360,"// TODO: Consider making following four constants static in 2.0
public final String DFLT_PLUGIN_CLASS_ATTR_NS = null;",0
2361,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2362,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2363,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2364,"public static String DFLT_METHOD_ATTR = ""method"";",0
2365,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2366,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2367,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2368,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2369,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2370,"public static String DFLT_METHOD_ATTR = ""method"";",0
2371,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2372,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2373,"public static String DFLT_FALSEVAL = ""false"";",0
2374,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2375,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2376,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2377,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2378,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2379,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2380,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2381,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2382,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2383,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2384,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2385,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2386,"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0
2387,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2388,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2389,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2390,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2391,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
int nAttrs = attributes.getLength();
Properties props = new Properties();
for (int i = 0; i < nAttrs; ++i) {
String key = attributes.getLocalName(i);
if ((key == null) || (key.length() == 0)) {
key = attributes.getQName(i);
}
String value = attributes.getValue(i);
props.setProperty(key, value);
}
try {
declarePlugin(getDigester(), props);
} catch (PluginInvalidInputException ex) {
throw new PluginInvalidInputException(String.format(""Error on element [%s]:"", getDigester().getMatch(), ex.getMessage()), ex);
}
}",0
2392,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2393,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2394,"public static String DFLT_METHOD_ATTR = ""method"";",0
2395,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2396,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2397,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2398,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2399,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2400,"public static String DFLT_METHOD_ATTR = ""method"";",0
2401,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2402,"public static String DFLT_FALSEVAL = ""false"";",0
2403,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2404,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (this.paramCount > 0) {
parameters = (Object[]) this.getDigester().popParams();
if (this.getDigester().getLog().isTraceEnabled()) {
Formatter formatter = new Formatter(""[CallMethodRule]"");
for (int i = 0, size = parameters.length; i < size; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""(%s) %s"", i, parameters[i]);
}
this.getDigester().getLog().trace(formatter.toString());
}
if (this.paramCount == 1 && parameters[0] == null) {
return;
}
} else if (this.paramTypes != null && this.paramTypes.length != 0) {
if (this.bodyText == null) {
return;
}
parameters = new Object[] { this.bodyText };
} else {
}
Object[] paramValues = new Object[this.paramTypes.length];
for (int i = 0; i < this.paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(this.paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (this.targetOffset >= 0) {
target = this.getDigester().peek(this.targetOffset);
} else {
target = this.getDigester().peek(this.getDigester().getCount() + this.targetOffset);
}
if (target == null) {
throw this.getDigester().createSAXException(String.format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", this.getDigester().getMatch(), this.targetOffset, this.getDigester().getCount()));
}
if (this.getDigester().getLog().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", this.getDigester().getMatch(), target.getClass().getName(), this.methodName);
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""%s/%s"", (paramValues[i] == null ? ""null"" : paramValues[i].toString()), (this.paramTypes[i] == null ? ""null"" : this.paramTypes[i].getName()));
}
formatter.format("")"");
this.getDigester().getLog().debug(formatter.toString());
}
Object result = null;
if (this.useExactMatch) {
result = MethodUtils.invokeExactMethod(target, this.methodName, paramValues, this.paramTypes);
} else {
result = MethodUtils.invokeMethod(target, this.methodName, paramValues, this.paramTypes);
}
processMethodCallResult(result);
}",0
2405,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (this.paramCount > 0) {
parameters = (Object[]) this.getDigester().popParams();
if (this.getDigester().getLog().isTraceEnabled()) {
Formatter formatter = new Formatter(""[CallMethodRule]"");
for (int i = 0, size = parameters.length; i < size; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""(%s) %s"", i, parameters[i]);
}
this.getDigester().getLog().trace(formatter.toString());
}
if (this.paramCount == 1 && parameters[0] == null) {
return;
}
} else if (this.paramTypes != null && this.paramTypes.length != 0) {
if (this.bodyText == null) {
return;
}
parameters = new Object[] { this.bodyText };
} else {
}
Object[] paramValues = new Object[this.paramTypes.length];
for (int i = 0; i < this.paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(this.paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (this.targetOffset >= 0) {
target = this.getDigester().peek(this.targetOffset);
} else {
target = this.getDigester().peek(this.getDigester().getCount() + this.targetOffset);
}
if (target == null) {
throw this.getDigester().createSAXException(String.format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", this.getDigester().getMatch(), this.targetOffset, this.getDigester().getCount()));
}
if (this.getDigester().getLog().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", this.getDigester().getMatch(), target.getClass().getName(), this.methodName);
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""%s/%s"", (paramValues[i] == null ? ""null"" : paramValues[i].toString()), (this.paramTypes[i] == null ? ""null"" : this.paramTypes[i].getName()));
}
formatter.format("")"");
this.getDigester().getLog().debug(formatter.toString());
}
Object result = null;
if (this.useExactMatch) {
result = MethodUtils.invokeExactMethod(target, this.methodName, paramValues, this.paramTypes);
} else {
result = MethodUtils.invokeMethod(target, this.methodName, paramValues, this.paramTypes);
}
processMethodCallResult(result);
}",0
2406,"@Override
public String toString() {
Formatter formatter = new Formatter().format(""CallMethodRule[methodName=%s, paramCount=%s, paramTypes={"", this.methodName, this.paramTypes.length);
if (this.paramTypes != null) {
for (int i = 0; i < this.paramTypes.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(this.paramTypes[i].getName());
}
}
return formatter.format(""}]"").toString();
}",0
2407,private String currChildNamespaceURI = null;,0
2408,private String currChildNamespaceURI = null;,0
2409,"protected LinkedRuleBuilder forPattern(String pattern) {
return this.memoryRulesBinder.forPattern(pattern);
}",0
2410,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2411,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2412,"public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
if (saxLog.isDebugEnabled()) {
saxLog.debug(""resolveEntity('"" + publicId + ""', '"" + systemId + ""')"");
}
if (publicId != null)
this.publicId = publicId;
URL entityURL = null;
if (publicId != null) {
entityURL = (URL) entityValidator.get(publicId);
}
if (schemaLocation != null && entityURL == null && systemId != null) {
entityURL = (URL) entityValidator.get(systemId);
}
if (entityURL == null) {
if (systemId == null) {
if (log.isDebugEnabled()) {
log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
}
return (null);
} else {
if (log.isDebugEnabled()) {
log.debug("" Trying to resolve using system ID '"" + systemId + ""'"");
}
try {
entityURL = new URL(systemId);
} catch (MalformedURLException e) {
throw new IllegalArgumentException(""Malformed URL '"" + systemId + ""' : "" + e.getMessage());
}
}
}
if (log.isDebugEnabled()) {
log.debug("" Resolving to alternate DTD '"" + entityURL + ""'"");
}
try {
return createInputSourceFromURL(entityURL);
} catch (Exception e) {
throw createSAXException(e);
}
}",0
2413,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2414,protected String namespaceURI = null;,0
2415,private String currChildNamespaceURI = null;,0
2416,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2417,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2418,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2419,"public static SAXParser newSAXParser(Properties properties) throws ParserConfigurationException, SAXException, SAXNotSupportedException {
SAXParserFactory factory = (SAXParserFactory) properties.get(""SAXParserFactory"");
if (versionNumber == null) {
versionNumber = getXercesVersion();
version = new Float(versionNumber).floatValue();
}
// Note: 2.2 is completely broken (with XML Schema).
if (version > 2.1) {
configureXerces(factory);
return factory.newSAXParser();
} else {
SAXParser parser = factory.newSAXParser();
configureOldXerces(parser, properties);
return parser;
}
}",0
2420,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2421,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2422,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2423,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2424,protected static float version;,0
2425,protected static String versionNumber = null;,0
2426,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2427,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2428,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2429,"public static String DFLT_METHOD_ATTR = ""method"";",0
2430,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2431,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2432,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2433,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2434,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2435,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2436,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2437,"public static String DFLT_METHOD_ATTR = ""method"";",0
2438,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2439,"public static String DFLT_FALSEVAL = ""false"";",0
2440,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2441,private FromXmlRuleSet ruleSet;,0
2442,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2443,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2444,"public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
if (saxLog.isDebugEnabled()) {
saxLog.debug(""resolveEntity('"" + publicId + ""', '"" + systemId + ""')"");
}
if (publicId != null)
this.publicId = publicId;
URL entityURL = null;
if (publicId != null) {
entityURL = (URL) entityValidator.get(publicId);
}
if (schemaLocation != null && entityURL == null && systemId != null) {
entityURL = (URL) entityValidator.get(systemId);
}
if (entityURL == null) {
if (systemId == null) {
if (log.isDebugEnabled()) {
log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
}
return (null);
} else {
if (log.isDebugEnabled()) {
log.debug("" Trying to resolve using system ID '"" + systemId + ""'"");
}
try {
entityURL = new URL(systemId);
} catch (MalformedURLException e) {
throw new IllegalArgumentException(""Malformed URL '"" + systemId + ""' : "" + e.getMessage());
}
}
}
if (log.isDebugEnabled()) {
log.debug("" Resolving to alternate DTD '"" + entityURL + ""'"");
}
try {
return createInputSourceFromURL(entityURL);
} catch (Exception e) {
throw createSAXException(e);
}
}",0
2445,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2446,protected String namespaceURI = null;,0
2447,private String currChildNamespaceURI = null;,0
2448,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2449,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2450,"public static SAXParser newSAXParser(Properties properties) throws ParserConfigurationException, SAXException, SAXNotSupportedException {
SAXParserFactory factory = (SAXParserFactory) properties.get(""SAXParserFactory"");
if (versionNumber == null) {
versionNumber = getXercesVersion();
version = new Float(versionNumber).floatValue();
}
// Note: 2.2 is completely broken (with XML Schema).
if (version > 2.1) {
configureXerces(factory);
return factory.newSAXParser();
} else {
SAXParser parser = factory.newSAXParser();
configureOldXerces(parser, properties);
return parser;
}
}",0
2451,protected static String versionNumber = null;,0
2452,protected static float version;,0
2453,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2454,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2455,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2456,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2457,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2458,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2459,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2460,"// TODO: Consider making following four constants static in 2.0
public final String DFLT_PLUGIN_CLASS_ATTR_NS = null;",0
2461,"public static String DFLT_METHOD_ATTR = ""method"";",0
2462,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2463,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2464,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2465,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2466,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2467,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2468,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2469,"public static String DFLT_METHOD_ATTR = ""method"";",0
2470,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2471,"public static String DFLT_FALSEVAL = ""false"";",0
2472,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2473,private FromXmlRuleSet ruleSet;,0
2474,"@Override
public void end(final String namespace, final String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
final Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
final Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2475,"public Object[] peekParams() {
try {
return (params.peek());
} catch (final EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2476,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (final EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2477,"public Object[] peekParams(final int n) {
final int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (final EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2478,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
@Override
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
@Override
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
@Override
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2479,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
@Override
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
@Override
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
@Override
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2480,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(final A annotation, final E element) {
final Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
final Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (final Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
final DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
final Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
final AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (final Exception e) {
rulesBinder.addError(e);
}
}
}",0
2481,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
@Override
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
@Override
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
@Override
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2482,"public static Annotation[] getAnnotationsArrayValue(final Annotation annotation) {
final Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2483,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2484,"@Override
public void begin(final String namespace, final String name, final Attributes attributes) throws Exception {
final String fileName = attributes.getValue(""url"");
if (fileName != null && !fileName.isEmpty()) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (final MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
final Set<String> includedFiles = memoryRulesBinder.getIncludedFiles();
final String xmlRulesResourceString = xmlRulesResource.toString();
if (includedFiles.add(xmlRulesResourceString)) {
try {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} finally {
includedFiles.remove(xmlRulesResourceString);
}
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
final String className = attributes.getValue(""class"");
if (className != null && !className.isEmpty()) {
try {
final Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
final RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (final Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2485,"protected LinkedRuleBuilder forPattern(final String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2486,"public void setUpdated(final Date updated) {
this.updated = updated;
}",0
2487,"public Date getUpdated() {
return updated;
}",0
2488,"public void setUpdated(final Date updated) {
this.updated = updated;
}",0
2489,"public Date getUpdated() {
return updated;
}",0
2490,"public void print() {
System.out.println(""Person #"" + id);
System.out.println(""  category="" + category);
System.out.println(""  name="" + name);
for (final String type : emails.keySet()) {
final String address = emails.get(type);
System.out.println(""  email (type "" + type + "") : "" + address);
}
for (final Address addr : addresses) {
addr.print(System.out, 2);
}
}",0
2491,"private static java.io.Reader getInputData(final String filename) throws IOException {
final java.io.File srcfile = new java.io.File(filename);
final java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(1000);
final byte[] buf = new byte[100];
final java.io.FileInputStream fis = new java.io.FileInputStream(srcfile);
for (; ; ) {
final int nread = fis.read(buf);
if (nread == -1) {
break;
}
baos.write(buf, 0, nread);
}
fis.close();
return new java.io.StringReader(baos.toString());
}",0
2492,"private static java.io.Reader getInputData(final String filename) throws IOException {
final java.io.File srcfile = new java.io.File(filename);
final java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(1000);
final byte[] buf = new byte[100];
final java.io.FileInputStream fis = new java.io.FileInputStream(srcfile);
for (; ; ) {
final int nread = fis.read(buf);
if (nread == -1) {
break;
}
baos.write(buf, 0, nread);
}
fis.close();
return new java.io.StringReader(baos.toString());
}",0
2493,"private static java.io.Reader getInputData(final String filename) throws IOException {
final java.io.File srcfile = new java.io.File(filename);
final java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(1000);
final byte[] buf = new byte[100];
final java.io.FileInputStream fis = new java.io.FileInputStream(srcfile);
for (; ; ) {
final int nread = fis.read(buf);
if (nread == -1) {
break;
}
baos.write(buf, 0, nread);
}
fis.close();
return new java.io.StringReader(baos.toString());
}",0
2494,"public static void main(final String[] args) {
if (args.length != 1) {
usage();
System.exit(-1);
}
final String filename = args[0];
final Digester d = new Digester();
final Connection connection = null;
addRules(d, connection);
System.out.println(""Parsing commencing..."");
try {
final File srcfile = new File(filename);
d.parse(srcfile);
} catch (final IOException ioe) {
System.out.println(""Error reading input file:"" + ioe.getMessage());
System.exit(-1);
} catch (final SAXException se) {
System.out.println(""Error parsing input file:"" + se.getMessage());
System.exit(-1);
}
System.out.println(""Parsing complete."");
}",0
2495,private final Connection conn;,0
2496,"public void setUpdated(final Date updated) {
this.updated = updated;
}",0
2497,"public Date getUpdated() {
return updated;
}",0
2498,"public Date getUpdated() {
return updated;
}",0
2499,"public void setUpdated(final Date updated) {
this.updated = updated;
}",0
2500,"@Override
public String transform(final String s) {
if (toLower) {
return s.toLowerCase();
}
return s.toUpperCase();
}",0
2501,"private void execute() throws IOException {
final FileReader inRaw = new FileReader(source);
final FileWriter out = new FileWriter(dest);
final BufferedReader in = new BufferedReader(inRaw);
while (true) {
final String inStr = in.readLine();
if (inStr == null) {
break;
}
final String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2502,"private void execute() throws IOException {
final FileReader inRaw = new FileReader(source);
final FileWriter out = new FileWriter(dest);
final BufferedReader in = new BufferedReader(inRaw);
while (true) {
final String inStr = in.readLine();
if (inStr == null) {
break;
}
final String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2503,"private void execute() throws IOException {
final FileReader inRaw = new FileReader(source);
final FileWriter out = new FileWriter(dest);
final BufferedReader in = new BufferedReader(inRaw);
while (true) {
final String inStr = in.readLine();
if (inStr == null) {
break;
}
final String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2504,"private void execute() throws IOException {
final FileReader inRaw = new FileReader(source);
final FileWriter out = new FileWriter(dest);
final BufferedReader in = new BufferedReader(inRaw);
while (true) {
final String inStr = in.readLine();
if (inStr == null) {
break;
}
final String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2505,"private void execute() throws IOException {
final FileReader inRaw = new FileReader(source);
final FileWriter out = new FileWriter(dest);
final BufferedReader in = new BufferedReader(inRaw);
while (true) {
final String inStr = in.readLine();
if (inStr == null) {
break;
}
final String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2506,"private void execute() throws IOException {
final FileReader inRaw = new FileReader(source);
final FileWriter out = new FileWriter(dest);
final BufferedReader in = new BufferedReader(inRaw);
while (true) {
final String inStr = in.readLine();
if (inStr == null) {
break;
}
final String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2507,"@Override
public String transform(final String s) {
final StringBuilder buf = new StringBuilder(s);
while (true) {
final int idx = buf.indexOf(from);
if (idx == -1) {
break;
}
buf.replace(idx, idx + from.length(), to);
}
return buf.toString();
}",0
2508,"public void render(final OutputStream stream, final String encoding) throws UnsupportedEncodingException {
PrintWriter pw = null;
if (encoding == null) {
pw = new PrintWriter(stream);
} else {
pw = new PrintWriter(new OutputStreamWriter(stream, encoding));
}
render(pw, encoding);
pw.flush();
}",0
2509,"public static void main(final String[] args) {
try {
System.out.println(""RSSDigester Test Program"");
System.out.println(""Opening input stream ..."");
final InputStream is = RSSDigester.class.getResourceAsStream(""/org/apache/commons/digester3/rss/rss-example.xml"");
System.out.println(""Creating new digester ..."");
final RSSDigester digester = new RSSDigester();
if ((args.length > 0) && (args[0].equals(""-debug""))) {
digester.setLogger(LogFactory.getLog(""RSSDigester""));
}
System.out.println(""Parsing input stream ..."");
final Channel channel = (Channel) digester.parse(is);
System.out.println(""Closing input stream ..."");
is.close();
System.out.println(""Dumping channel info ..."");
channel.render(System.out);
} catch (final Exception e) {
System.out.println(""-->Exception"");
e.printStackTrace(System.out);
}
}",0
2510,"public void print() {
System.out.println(""Person #"" + id);
System.out.println(""  category="" + category);
System.out.println(""  name="" + name);
for (final String type : emails.keySet()) {
final String address = emails.get(type);
System.out.println(""  email (type "" + type + "") : "" + address);
}
for (final Address addr : addresses) {
addr.print(System.out, 2);
}
}",0
2511,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2512,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2513,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2514,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2515,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2516,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2517,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2518,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2519,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2520,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2521,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2522,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2523,"public Date getUpdated() {
return updated;
}",0
2524,"public void setUpdated(Date updated) {
this.updated = updated;
}",0
2525,"public Date getUpdated() {
return updated;
}",0
2526,"public void setUpdated(Date updated) {
this.updated = updated;
}",0
2527,"public void print() {
System.out.println(""Person #"" + id);
System.out.println(""  category="" + category);
System.out.println(""  name="" + name);
for (Iterator<String> i = emails.keySet().iterator(); i.hasNext(); ) {
String type = i.next();
String address = emails.get(type);
System.out.println(""  email (type "" + type + "") : "" + address);
}
for (Iterator<Address> i = addresses.iterator(); i.hasNext(); ) {
Address addr = i.next();
addr.print(System.out, 2);
}
}",0
2528,"private static java.io.Reader getInputData(String filename) throws java.io.IOException {
java.io.File srcfile = new java.io.File(filename);
java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(1000);
byte[] buf = new byte[100];
java.io.FileInputStream fis = new java.io.FileInputStream(srcfile);
for (; ; ) {
int nread = fis.read(buf);
if (nread == -1) {
break;
}
baos.write(buf, 0, nread);
}
fis.close();
return new java.io.StringReader(baos.toString());
}",0
2529,"private static java.io.Reader getInputData(String filename) throws java.io.IOException {
java.io.File srcfile = new java.io.File(filename);
java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(1000);
byte[] buf = new byte[100];
java.io.FileInputStream fis = new java.io.FileInputStream(srcfile);
for (; ; ) {
int nread = fis.read(buf);
if (nread == -1) {
break;
}
baos.write(buf, 0, nread);
}
fis.close();
return new java.io.StringReader(baos.toString());
}",0
2530,"private static java.io.Reader getInputData(String filename) throws java.io.IOException {
java.io.File srcfile = new java.io.File(filename);
java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(1000);
byte[] buf = new byte[100];
java.io.FileInputStream fis = new java.io.FileInputStream(srcfile);
for (; ; ) {
int nread = fis.read(buf);
if (nread == -1) {
break;
}
baos.write(buf, 0, nread);
}
fis.close();
return new java.io.StringReader(baos.toString());
}",0
2531,"public static void main(String[] args) {
if (args.length != 1) {
usage();
System.exit(-1);
}
String filename = args[0];
Digester d = new Digester();
Connection connection = null;
addRules(d, connection);
System.out.println(""Parsing commencing..."");
try {
File srcfile = new File(filename);
d.parse(srcfile);
} catch (IOException ioe) {
System.out.println(""Error reading input file:"" + ioe.getMessage());
System.exit(-1);
} catch (SAXException se) {
System.out.println(""Error parsing input file:"" + se.getMessage());
System.exit(-1);
}
System.out.println(""Parsing complete."");
}",0
2532,private Connection conn;,0
2533,"public void setUpdated(Date updated) {
this.updated = updated;
}",0
2534,"public Date getUpdated() {
return updated;
}",0
2535,"public Date getUpdated() {
return updated;
}",0
2536,"public void setUpdated(Date updated) {
this.updated = updated;
}",0
2537,"public String transform(String s) {
if (toLower) {
return s.toLowerCase();
}
return s.toUpperCase();
}",0
2538,"private void execute() throws IOException {
FileReader inRaw = new FileReader(source);
FileWriter out = new FileWriter(dest);
BufferedReader in = new BufferedReader(inRaw);
while (true) {
String inStr = in.readLine();
if (inStr == null)
break;
String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2539,"private void execute() throws IOException {
FileReader inRaw = new FileReader(source);
FileWriter out = new FileWriter(dest);
BufferedReader in = new BufferedReader(inRaw);
while (true) {
String inStr = in.readLine();
if (inStr == null)
break;
String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2540,"private void execute() throws IOException {
FileReader inRaw = new FileReader(source);
FileWriter out = new FileWriter(dest);
BufferedReader in = new BufferedReader(inRaw);
while (true) {
String inStr = in.readLine();
if (inStr == null)
break;
String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2541,"private void execute() throws IOException {
FileReader inRaw = new FileReader(source);
FileWriter out = new FileWriter(dest);
BufferedReader in = new BufferedReader(inRaw);
while (true) {
String inStr = in.readLine();
if (inStr == null)
break;
String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2542,"private void execute() throws IOException {
FileReader inRaw = new FileReader(source);
FileWriter out = new FileWriter(dest);
BufferedReader in = new BufferedReader(inRaw);
while (true) {
String inStr = in.readLine();
if (inStr == null)
break;
String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2543,"private void execute() throws IOException {
FileReader inRaw = new FileReader(source);
FileWriter out = new FileWriter(dest);
BufferedReader in = new BufferedReader(inRaw);
while (true) {
String inStr = in.readLine();
if (inStr == null)
break;
String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0
2544,"public String transform(String s) {
StringBuilder buf = new StringBuilder(s);
while (true) {
int idx = buf.indexOf(from);
if (idx == -1) {
break;
}
buf.replace(idx, idx + from.length(), to);
}
return buf.toString();
}",0
2545,"public void render(OutputStream stream, String encoding) throws UnsupportedEncodingException {
PrintWriter pw = null;
if (encoding == null) {
pw = new PrintWriter(stream);
} else {
pw = new PrintWriter(new OutputStreamWriter(stream, encoding));
}
render(pw, encoding);
pw.flush();
}",0
2546,"public static void main(String[] args) {
try {
System.out.println(""RSSDigester Test Program"");
System.out.println(""Opening input stream ..."");
InputStream is = RSSDigester.class.getResourceAsStream(""/org/apache/commons/digester3/rss/rss-example.xml"");
System.out.println(""Creating new digester ..."");
RSSDigester digester = new RSSDigester();
if ((args.length > 0) && (args[0].equals(""-debug""))) {
digester.setLogger(LogFactory.getLog(""RSSDigester""));
}
System.out.println(""Parsing input stream ..."");
Channel channel = (Channel) digester.parse(is);
System.out.println(""Closing input stream ..."");
is.close();
System.out.println(""Dumping channel info ..."");
channel.render(System.out);
} catch (Exception e) {
System.out.println(""-->Exception"");
e.printStackTrace(System.out);
}
}",0
2547,"public void print() {
System.out.println(""Person #"" + id);
System.out.println(""  category="" + category);
System.out.println(""  name="" + name);
for (Iterator<String> i = emails.keySet().iterator(); i.hasNext(); ) {
String type = i.next();
String address = emails.get(type);
System.out.println(""  email (type "" + type + "") : "" + address);
}
for (Iterator<Address> i = addresses.iterator(); i.hasNext(); ) {
Address addr = i.next();
addr.print(System.out, 2);
}
}",0
2548,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2549,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2550,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2551,"public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
if (saxLog.isDebugEnabled()) {
saxLog.debug(""resolveEntity('"" + publicId + ""', '"" + systemId + ""')"");
}
if (publicId != null)
this.publicId = publicId;
URL entityURL = null;
if (publicId != null) {
entityURL = (URL) entityValidator.get(publicId);
}
if (schemaLocation != null && entityURL == null && systemId != null) {
entityURL = (URL) entityValidator.get(systemId);
}
if (entityURL == null) {
if (systemId == null) {
if (log.isDebugEnabled()) {
log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
}
return (null);
} else {
if (log.isDebugEnabled()) {
log.debug("" Trying to resolve using system ID '"" + systemId + ""'"");
}
try {
entityURL = new URL(systemId);
} catch (MalformedURLException e) {
throw new IllegalArgumentException(""Malformed URL '"" + systemId + ""' : "" + e.getMessage());
}
}
}
if (log.isDebugEnabled()) {
log.debug("" Resolving to alternate DTD '"" + entityURL + ""'"");
}
try {
return createInputSourceFromURL(entityURL);
} catch (Exception e) {
throw createSAXException(e);
}
}",0
2552,protected String namespaceURI = null;,0
2553,private String currChildNamespaceURI = null;,0
2554,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2555,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2556,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2557,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2558,protected static String versionNumber = null;,0
2559,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2560,protected static float version;,0
2561,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2562,"public static SAXParser newSAXParser(Properties properties) throws ParserConfigurationException, SAXException, SAXNotSupportedException {
SAXParserFactory factory = (SAXParserFactory) properties.get(""SAXParserFactory"");
if (versionNumber == null) {
versionNumber = getXercesVersion();
version = new Float(versionNumber).floatValue();
}
// Note: 2.2 is completely broken (with XML Schema).
if (version > 2.1) {
configureXerces(factory);
return factory.newSAXParser();
} else {
SAXParser parser = factory.newSAXParser();
configureOldXerces(parser, properties);
return parser;
}
}",0
2563,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2564,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2565,"// TODO: Consider making following four constants static in 2.0
public final String DFLT_PLUGIN_CLASS_ATTR_NS = null;",0
2566,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2567,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2568,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2569,"public static String DFLT_METHOD_ATTR = ""method"";",0
2570,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2571,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2572,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2573,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2574,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2575,"public static String DFLT_METHOD_ATTR = ""method"";",0
2576,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2577,"public static String DFLT_FALSEVAL = ""false"";",0
2578,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2579,private FromXmlRuleSet ruleSet;,0
2580,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
StringBuilder sb = new StringBuilder();
sb.append(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(getDigester().getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (getDigester().getLogger().isDebugEnabled()) {
StringBuilder sb = new StringBuilder(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
getDigester().getLogger().debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2581,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
StringBuilder sb = new StringBuilder();
sb.append(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(getDigester().getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (getDigester().getLogger().isDebugEnabled()) {
StringBuilder sb = new StringBuilder(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
getDigester().getLogger().debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2582,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2583,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2584,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2585,private String currChildNamespaceURI = null;,0
2586,private final float loadFactor = 0.75f;,0
2587,private final float loadFactor = 0.75f;,0
2588,private final int cacheSize = 255;,0
2589,"private final Map<Class<?>, FromAnnotationsRuleSet> data = new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
}
};",0
2590,"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0
2591,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2592,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2593,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2594,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2595,"public static String DFLT_METHOD_ATTR = ""method"";",0
2596,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2597,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2598,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2599,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2600,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2601,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2602,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2603,"public static String DFLT_METHOD_ATTR = ""method"";",0
2604,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2605,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2606,"public static String DFLT_FALSEVAL = ""false"";",0
2607,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2608,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2609,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2610,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2611,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2612,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2613,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2614,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2615,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2616,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2617,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2618,"private void invoke() throws Exception {
Object child = getChild();
Object parent = getParent();
if (getDigester().getLogger().isDebugEnabled()) {
if (parent == null) {
getDigester().getLogger().debug(format(""[%s]{%s} Call [NULL PARENT].%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), methodName, child));
} else {
getDigester().getLogger().debug(format(""[%s]{%s} Call %s.%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), parent.getClass().getName(), methodName, child));
}
}
Class<?>[] paramTypes = new Class<?>[1];
if (paramType != null) {
paramTypes[0] = getDigester().getClassLoader().loadClass(paramTypeName);
} else {
paramTypes[0] = child.getClass();
}
if (useExactMatch) {
invokeExactMethod(parent, methodName, new Object[] { child }, paramTypes);
} else {
invokeMethod(parent, methodName, new Object[] { child }, paramTypes);
}
}",0
2619,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2620,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2621,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2622,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2623,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2624,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2625,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2626,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2627,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2628,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2629,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2630,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2631,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2632,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2633,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2634,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2635,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2636,private String currChildNamespaceURI = null;,0
2637,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2638,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2639,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2640,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2641,"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0
2642,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2643,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2644,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2645,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2646,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2647,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2648,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2649,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2650,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2651,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2652,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2653,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2654,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2655,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2656,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2657,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2658,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2659,"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2660,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2661,protected String namespaceURI = null;,0
2662,private String currChildNamespaceURI = null;,0
2663,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2664,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2665,protected static float version;,0
2666,"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
2667,"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
2668,"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0
2669,protected static String versionNumber = null;,0
2670,"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
2671,"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
2672,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
2673,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0
2674,"// TODO: Consider making following four constants static in 2.0
public final String DFLT_PLUGIN_CLASS_ATTR_NS = null;",0
2675,"public static String DFLT_METHOD_ATTR = ""method"";",0
2676,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2677,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
2678,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2679,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
2680,"public static String DFLT_METHOD_NAME = ""addRules"";",0
2681,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
2682,"public static String DFLT_FILENAME_ATTR = ""file"";",0
2683,"public static String DFLT_METHOD_ATTR = ""method"";",0
2684,"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
2685,"public static String DFLT_FALSEVAL = ""false"";",0
2686,"public static String DFLT_PROPS_ATTR = ""setprops"";",0
2687,private FromXmlRuleSet ruleSet;,0
2688,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2689,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2690,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2691,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2692,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2693,"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0
2694,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2695,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2696,"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0
2697,"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0
2698,"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0
2699,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0
2700,"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0
2701,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2702,private String currChildNamespaceURI = null;,1
2703,"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0
2704,private final ClassLoader classLoader;,0
2705,"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",1
2706,"private <R extends Rule> RuleProvider<R> addProvider(RuleProvider<R> provider) {
if (keyPattern == null) {
return provider;
}
List<RuleProvider<? extends Rule>> providerLits = providers.get(keyPattern);
if (providerLits == null) {
providerLits = new ArrayList<RuleProvider<? extends Rule>>();
providers.put(keyPattern, providerLits);
}
providerLits.add(provider);
return provider;
}",1
2707,"private void invoke() throws Exception {
final Object child = getChild();
final Object parent = getParent();
if (getDigester().getLogger().isDebugEnabled()) {
if (parent == null) {
getDigester().getLogger().debug(format(""[%s]{%s} Call [NULL PARENT].%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), methodName, child));
} else {
getDigester().getLogger().debug(format(""[%s]{%s} Call %s.%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), parent.getClass().getName(), methodName, child));
}
}
final Class<?>[] paramTypes = new Class<?>[1];
if (paramType != null) {
paramTypes[0] = getDigester().getClassLoader().loadClass(paramTypeName);
} else {
paramTypes[0] = child.getClass();
}
if (useExactMatch) {
invokeExactMethod(parent, methodName, new Object[] { child }, paramTypes);
} else {
invokeMethod(parent, methodName, new Object[] { child }, paramTypes);
}
}",0
2708,private Substitutor substitutor;,1
2709,public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
2710,private String namespaceURI;,1
2711,"public static String DFLT_RESOURCE_ATTR = ""resource"";",1
2712,"protected void install(RulesModule rulesModule) {
this.rulesBinder.install(rulesModule);
}",0
2713,"public static String DFLT_PROPS_ATTR = ""setprops"";",1
2714,private String namespaceURI;,1
2715,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
Class<?> clazz = this.clazz;
if (clazz == null) {
String realClassName = className;
if (attributeName != null) {
String value = attributes.getValue(attributeName);
if (value != null) {
realClassName = value;
}
}
if (getDigester().getLogger().isDebugEnabled()) {
getDigester().getLogger().debug(format(""[ObjectCreateRule]{%s} New '%s'"", getDigester().getMatch(), realClassName));
}
clazz = getDigester().getClassLoader().loadClass(realClassName);
}
Object instance;
if (constructorArgumentTypes == null || constructorArgumentTypes.length == 0) {
if (getDigester().getLogger().isDebugEnabled()) {
getDigester().getLogger().debug(format(""[ObjectCreateRule]{%s} New '%s' using default empty constructor"", getDigester().getMatch(), clazz.getName()));
}
instance = clazz.newInstance();
} else {
if (proxyManager == null) {
synchronized (this) {
if (proxyManager == null) {
Constructor<?> constructor = getAccessibleConstructor(clazz, constructorArgumentTypes);
if (constructor == null) {
throw new SAXException(format(""[ObjectCreateRule]{%s} Class '%s' does not have a construcor with types"", getDigester().getMatch(), clazz.getName(), Arrays.toString(constructorArgumentTypes)));
}
proxyManager = new ProxyManager(clazz, constructor, defaultConstructorArguments, getDigester());
}
}
}
instance = proxyManager.createProxy();
}
getDigester().push(instance);
}",1
2716,"private void invoke() throws Exception {
final Object child = getChild();
final Object parent = getParent();
if (getDigester().getLogger().isDebugEnabled()) {
if (parent == null) {
getDigester().getLogger().debug(format(""[%s]{%s} Call [NULL PARENT].%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), methodName, child));
} else {
getDigester().getLogger().debug(format(""[%s]{%s} Call %s.%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), parent.getClass().getName(), methodName, child));
}
}
final Class<?>[] paramTypes = new Class<?>[1];
if (paramType != null) {
paramTypes[0] = getDigester().getClassLoader().loadClass(paramTypeName);
} else {
paramTypes[0] = child.getClass();
}
if (useExactMatch) {
invokeExactMethod(parent, methodName, new Object[] { child }, paramTypes);
} else {
invokeMethod(parent, methodName, new Object[] { child }, paramTypes);
}
}",0
2717,"Object createProxy() {
Object[] constructorArguments = new Object[templateConstructorArguments.length];
arraycopy(templateConstructorArguments, 0, constructorArguments, 0, constructorArguments.length);
digester.pushParams(constructorArguments);
DeferredConstructionCallback callback = new DeferredConstructionCallback(constructor, constructorArguments);
Object result;
if (factory == null) {
synchronized (this) {
// check again for null now that we're in the synchronized block:
if (factory == null) {
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(clazz);
enhancer.setCallback(callback);
enhancer.setClassLoader(digester.getClassLoader());
enhancer.setInterceptDuringConstruction(false);
if (hasDefaultConstructor) {
result = enhancer.create();
} else {
result = enhancer.create(constructor.getParameterTypes(), constructorArguments);
}
factory = (Factory) result;
return result;
}
}
}
if (hasDefaultConstructor) {
result = factory.newInstance(callback);
} else {
result = factory.newInstance(constructor.getParameterTypes(), constructorArguments, new Callback[] { callback });
}
return result;
}",1
2718,"public static String DFLT_METHOD_NAME = ""addRules"";",1
2719,"protected void addError(String messagePattern, Object... arguments) {
this.rulesBinder.addError(messagePattern, arguments);
}",0
2720,private FromXmlRuleSet ruleSet;,1
2721,"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",1
2722,"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2723,"protected void addError(Throwable t) {
this.rulesBinder.addError(t);
}",0
2724,"public DigesterLoader setClassLoader(ClassLoader classLoader) {
if (classLoader == null) {
throw new IllegalArgumentException(""Parameter 'classLoader' cannot be null"");
}
this.classLoader = new BinderClassLoader(classLoader);
return this;
}",1
2725,private final List<ErrorMessage> errors;,1
2726,"public static String DFLT_FILENAME_ATTR = ""file"";",1
2727,"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",1
2728,private boolean useContextClassLoader;,1
2729,"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",1
2730,"public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
if (saxLog.isDebugEnabled()) {
saxLog.debug(""resolveEntity('"" + publicId + ""', '"" + systemId + ""')"");
}
if (publicId != null)
this.publicId = publicId;
URL entityURL = null;
if (publicId != null) {
entityURL = (URL) entityValidator.get(publicId);
}
if (schemaLocation != null && entityURL == null && systemId != null) {
entityURL = (URL) entityValidator.get(systemId);
}
if (entityURL == null) {
if (systemId == null) {
if (log.isDebugEnabled()) {
log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
}
return (null);
} else {
if (log.isDebugEnabled()) {
log.debug("" Trying to resolve using system ID '"" + systemId + ""'"");
}
try {
entityURL = new URL(systemId);
} catch (MalformedURLException e) {
throw new IllegalArgumentException(""Malformed URL '"" + systemId + ""' : "" + e.getMessage());
}
}
}
if (log.isDebugEnabled()) {
log.debug("" Resolving to alternate DTD '"" + entityURL + ""'"");
}
try {
return createInputSourceFromURL(entityURL);
} catch (Exception e) {
throw createSAXException(e);
}
}",1
2731,"private void invoke() throws Exception {
final Object child = getChild();
final Object parent = getParent();
if (getDigester().getLogger().isDebugEnabled()) {
if (parent == null) {
getDigester().getLogger().debug(format(""[%s]{%s} Call [NULL PARENT].%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), methodName, child));
} else {
getDigester().getLogger().debug(format(""[%s]{%s} Call %s.%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), parent.getClass().getName(), methodName, child));
}
}
final Class<?>[] paramTypes = new Class<?>[1];
if (paramType != null) {
paramTypes[0] = getDigester().getClassLoader().loadClass(paramTypeName);
} else {
paramTypes[0] = child.getClass();
}
if (useExactMatch) {
invokeExactMethod(parent, methodName, new Object[] { child }, paramTypes);
} else {
invokeMethod(parent, methodName, new Object[] { child }, paramTypes);
}
}",0
2732,private ClassLoader classLoader;,1
2733,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (this.paramTypes.length > 0) {
parameters = (Object[]) this.getDigester().popParams();
if (this.getDigester().getLog().isTraceEnabled()) {
Formatter formatter = new Formatter(""[CallMethodRule]"");
for (int i = 0, size = parameters.length; i < size; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""(%s) %s"", i, parameters[i]);
}
this.getDigester().getLog().trace(formatter.toString());
}
if (this.paramTypes.length == 1 && parameters[0] == null) {
return;
}
} else if (this.paramTypes != null && this.paramTypes.length != 0) {
if (this.bodyText == null) {
return;
}
parameters = new Object[] { this.bodyText };
} else {
}
Object[] paramValues = new Object[this.paramTypes.length];
for (int i = 0; i < this.paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(this.paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (this.targetOffset >= 0) {
target = this.getDigester().peek(this.targetOffset);
} else {
target = this.getDigester().peek(this.getDigester().getCount() + this.targetOffset);
}
if (target == null) {
throw this.getDigester().createSAXException(String.format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", this.getDigester().getMatch(), this.targetOffset, this.getDigester().getCount()));
}
if (this.getDigester().getLog().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", this.getDigester().getMatch(), target.getClass().getName(), this.methodName);
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(""%s/%s"", (paramValues[i] == null ? ""null"" : paramValues[i].toString()), (this.paramTypes[i] == null ? ""null"" : this.paramTypes[i].getName()));
}
formatter.format("")"");
this.getDigester().getLog().debug(formatter.toString());
}
Object result = null;
if (this.useExactMatch) {
result = MethodUtils.invokeExactMethod(target, this.methodName, paramValues, this.paramTypes);
} else {
result = MethodUtils.invokeMethod(target, this.methodName, paramValues, this.paramTypes);
}
processMethodCallResult(result);
}",0
2734,"@Override
public String toString() {
return String.format(""ObjectCreateRule[className=%s, attributeName=%s]"", this.type.getClasses(), this.attributeName);
}",0
2735,"public static String DFLT_METHOD_NAME = ""addRules"";",1
2736,"public static String DFLT_METHOD_NAME = ""addRules"";",1
2737,"public static String DFLT_METHOD_ATTR = ""method"";",1
2738,"public static String DFLT_METHOD_ATTR = ""method"";",1
2739,private Object[] defaultConstructorArguments;,0
2740,"public static String DFLT_FALSEVAL = ""false"";",1
2741,"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",1
2742,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
Class<?> clazz = this.clazz;
if (clazz == null) {
String realClassName = className;
if (attributeName != null) {
String value = attributes.getValue(attributeName);
if (value != null) {
realClassName = value;
}
}
if (getDigester().getLogger().isDebugEnabled()) {
getDigester().getLogger().debug(format(""[ObjectCreateRule]{%s} New '%s'"", getDigester().getMatch(), realClassName));
}
clazz = getDigester().getClassLoader().loadClass(realClassName);
}
Object instance;
if (constructorArgumentsTypes == null || constructorArgumentsTypes.length == 0) {
if (getDigester().getLogger().isDebugEnabled()) {
getDigester().getLogger().debug(format(""[ObjectCreateRule]{%s} New '%s' using default empty constructor"", getDigester().getMatch(), clazz.getName()));
}
instance = clazz.newInstance();
} else {
Constructor<?> constructor = getAccessibleConstructor(clazz, constructorArgumentsTypes);
if (constructor == null) {
throw new SAXException(format(""[ObjectCreateRule]{%s} Class '%s' does not have a construcor with types"", getDigester().getMatch(), clazz.getName(), Arrays.toString(constructorArgumentsTypes)));
}
instance = createLazyProxy(constructor);
}
getDigester().push(instance);
}",0
2743,Object delegate;,1
2744,"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",1
2745,"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
Class<?> clazz = this.clazz;
if (clazz == null) {
String realClassName = className;
if (attributeName != null) {
String value = attributes.getValue(attributeName);
if (value != null) {
realClassName = value;
}
}
if (getDigester().getLogger().isDebugEnabled()) {
getDigester().getLogger().debug(format(""[ObjectCreateRule]{%s} New '%s'"", getDigester().getMatch(), realClassName));
}
clazz = getDigester().getClassLoader().loadClass(realClassName);
}
Object instance;
if (constructorArgumentTypes == null || constructorArgumentTypes.length == 0) {
if (getDigester().getLogger().isDebugEnabled()) {
getDigester().getLogger().debug(format(""[ObjectCreateRule]{%s} New '%s' using default empty constructor"", getDigester().getMatch(), clazz.getName()));
}
instance = clazz.newInstance();
} else {
if (proxyManager == null) {
synchronized (this) {
if (proxyManager == null) {
Constructor<?> constructor = getAccessibleConstructor(clazz, constructorArgumentTypes);
if (constructor == null) {
throw new SAXException(format(""[ObjectCreateRule]{%s} Class '%s' does not have a construcor with types %s"", getDigester().getMatch(), clazz.getName(), Arrays.toString(constructorArgumentTypes)));
}
proxyManager = new ProxyManager(clazz, constructor, defaultConstructorArguments, getDigester());
}
}
}
instance = proxyManager.createProxy();
}
getDigester().push(instance);
}",1
2746,"public Object[] peekParams(int n) {
int index = (params.size() - 1) - n;
if (index < 0) {
log.warn(""Empty stack (returning null)"");
return (null);
}
try {
return (params.get(index));
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2747,"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
StringBuilder sb = new StringBuilder();
sb.append(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(getDigester().getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (getDigester().getLogger().isDebugEnabled()) {
StringBuilder sb = new StringBuilder(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
getDigester().getLogger().debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0
2748,"private void invoke() throws Exception {
Object child = getChild();
Object parent = getParent();
if (getDigester().getLogger().isDebugEnabled()) {
if (parent == null) {
getDigester().getLogger().debug(format(""[%s]{%s} Call [NULL PARENT].%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), methodName, child));
} else {
getDigester().getLogger().debug(format(""[%s]{%s} Call %s.%s(%s)"", getClass().getSimpleName(), getDigester().getMatch(), parent.getClass().getName(), methodName, child));
}
}
Class<?>[] paramTypes = new Class<?>[1];
if (paramType != null) {
paramTypes[0] = getDigester().getClassLoader().loadClass(paramTypeName);
} else {
paramTypes[0] = child.getClass();
}
if (useExactMatch) {
invokeExactMethod(parent, methodName, new Object[] { child }, paramTypes);
} else {
invokeMethod(parent, methodName, new Object[] { child }, paramTypes);
}
}",0
2749,"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0
2750,"private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
throw new ParseException(""Invalid RFC 2047 encoded-word: "" + word);
}
int charsetPos = word.indexOf('?', 2);
if (charsetPos == -1) {
throw new ParseException(""Missing charset in RFC 2047 encoded-word: "" + word);
}
String charset = word.substring(2, charsetPos).toLowerCase();
int encodingPos = word.indexOf('?', charsetPos + 1);
if (encodingPos == -1) {
throw new ParseException(""Missing encoding in RFC 2047 encoded-word: "" + word);
}
String encoding = word.substring(charsetPos + 1, encodingPos);
int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
if (encodedTextPos == -1) {
throw new ParseException(""Missing encoded text in RFC 2047 encoded-word: "" + word);
}
String encodedText = word.substring(encodingPos + 1, encodedTextPos);
if (encodedText.length() == 0) {
return """";
}
try {
ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
byte[] encodedData = encodedText.getBytes(US_ASCII_CHARSET);
if (encoding.equals(BASE64_ENCODING_MARKER)) {
Base64Decoder.decode(encodedData, out);
} else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
QuotedPrintableDecoder.decode(encodedData, out);
} else {
throw new UnsupportedEncodingException(""Unknown RFC 2047 encoding: "" + encoding);
}
byte[] decodedData = out.toByteArray();
return new String(decodedData, javaCharset(charset));
} catch (IOException e) {
throw new UnsupportedEncodingException(""Invalid RFC 2047 encoding"");
}
}",1
2751,protected int lineCount = 0;,1
2752,"public Iterator getHeaders(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return Collections.EMPTY_LIST.iterator();
}
return headerValueList.iterator();
}",0
2753,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
2754,"protected FileItemHeaders getParsedHeaders(String headerPart) {
final int len = headerPart.length();
FileItemHeadersImpl headers = newFileItemHeaders();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",1
2755,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
2756,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0
2757,"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (final UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",1
2758,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. "", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",1
2759,protected byte padding = (byte) '=';,0
2760,"protected Map parseHeaders(String headerPart) {
Map headers = new HashMap();
int start = 0;
int end = 0;
for (; ; ) {
int offset = headerPart.indexOf('\r', end);
if (offset == -1 || offset + 1 >= headerPart.length()) {
throw new IllegalStateException(""Expected headers to be terminated by an empty line."");
}
if (headerPart.charAt(offset + 1) != '\n') {
end = offset + 1;
} else if (offset == start) {
break;
} else {
String header = headerPart.substring(start, offset);
start = end = offset + 2;
if (header.indexOf(':') == -1) {
continue;
}
String headerName = header.substring(0, header.indexOf(':')).trim().toLowerCase();
String headerValue = header.substring(header.indexOf(':') + 1).trim();
if (getHeader(headers, headerName) != null) {
headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
} else {
headers.put(headerName, headerValue);
}
}
}
return headers;
}",0
2761,"@Override
public void write(File file) throws Exception {
if (isInMemory()) {
FileOutputStream fout = null;
try {
fout = new FileOutputStream(file);
fout.write(get());
fout.close();
} finally {
IOUtils.closeQuietly(fout);
}
} else {
File outputFile = getStoreLocation();
if (outputFile != null) {
size = outputFile.length();
if (file.exists()) {
file.delete();
}
FileUtils.moveFile(outputFile, file);
} else {
throw new FileUploadException(""Cannot write uploaded file to disk!"");
}
}
}",1
2762,"@Override
public String getString() {
byte[] rawdata = new byte[0];
try {
rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
return new String(rawdata, charset);
} catch (final IOException e) {
return new String(rawdata);
}
}",0
2763,"@Override
public byte[] get() throws UncheckedIOException {
if (isInMemory()) {
if (cachedContent == null && dfos != null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
try (InputStream fis = Files.newInputStream(dfos.getFile().toPath())) {
IOUtils.readFully(fis, fileData);
} catch (IOException e) {
throw new UncheckedIOException(e);
}
return fileData;
}",1
2764,"@Override
public void delete() {
cachedContent = null;
final File outputFile = getStoreLocation();
if (outputFile != null && !isInMemory() && outputFile.exists()) {
outputFile.delete();
}
}",1
2765,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(pContentDisposition, ';');
fieldName = params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",1
2766,private File dfosFile;,1
2767,"public Map<String, String> parse(final char[] charArray, final int offset, final int length, final char separator) {
if (charArray == null) {
return new HashMap<>();
}
final HashMap<String, String> params = new HashMap<>();
this.chars = charArray;
this.pos = offset;
this.len = length;
String paramName;
String paramValue;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (charArray[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
if (paramValue != null) {
try {
paramValue = RFC2231Utility.hasEncodedValue(paramName) ? RFC2231Utility.decodeText(paramValue) : MimeUtility.decodeText(paramValue);
} catch (final UnsupportedEncodingException e) {
}
}
}
if (hasChar() && (charArray[pos] == separator)) {
pos++;
}
if ((paramName != null) && !paramName.isEmpty()) {
paramName = RFC2231Utility.stripDelimiter(paramName);
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase(Locale.ENGLISH);
}
params.put(paramName, paramValue);
}
}
return params;
}",1
2768,"@Deprecated
protected Map<String, String> parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map<String, String> result = new HashMap<String, String>();
for (Iterator<String> iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = iter.next();
Iterator<String> iter2 = headers.getHeaders(headerName);
String headerValue = iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",1
2769,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. "", MULTIPART_FORM_DATA, e.getMessage()), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",1
2770,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
2771,protected int cachedCharacter = -1;,1
2772,"@Override
public String getString() {
try {
final byte[] rawData = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
return new String(rawData, charset);
} catch (final IOException e) {
return new String(new byte[0]);
}
}",1
2773,protected int lineLength;,1
2774,protected int deferredWhitespace = 0;,1
2775,"public List parseRequest(RequestContext ctx) throws FileUploadException {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
final byte[] buffer = new byte[8192];
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
StreamUtil.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
items.add(fileItem);
}
return items;
}",0
2776,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList<String>();
headerNameToValueListMap.put(nameLower, headerValueList);
}
headerValueList.add(value);
}",1
2777,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return (String) headerValueList.get(0);
}",0
2778,private boolean opened;,1
2779,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
2780,"@Override
public String getString() {
byte[] rawdata = new byte[0];
try {
rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
return new String(rawdata, charset);
} catch (final IOException e) {
return new String(rawdata);
}
}",0
2781,"@Override
public byte[] get() throws UncheckedIOException {
if (isInMemory()) {
if (cachedContent == null && dfos != null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
try (InputStream fis = Files.newInputStream(dfos.getFile().toPath())) {
IOUtils.readFully(fis, fileData);
} catch (IOException e) {
throw new UncheckedIOException(e);
}
return fileData;
}",1
2782,"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (final UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",1
2783,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
if (repository != null) {
if (repository.isDirectory()) {
if (repository.getPath().contains(""\0"")) {
throw new IOException(format(""The repository [%s] contains a null character"", repository.getPath()));
}
} else {
throw new IOException(format(""The repository [%s] is not a directory"", repository.getAbsolutePath()));
}
}
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
input.close();
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
2784,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
currentItem.setHeaders(headers);
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
currentItem.setHeaders(headers);
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",1
2785,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",1
2786,"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (final UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",1
2787,"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
boundary = boundaryStr.getBytes(StandardCharsets.ISO_8859_1);
return boundary;
}",1
2788,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",1
2789,"@Deprecated
public MultipartStream() {
this(null, null, null);
}",0
2790,protected int bytesWritten = 0;,1
2791,"public Map<String, String> parse(final char[] charArray, final int offset, final int length, final char separator) {
if (charArray == null) {
return new HashMap<>();
}
final HashMap<String, String> params = new HashMap<>();
this.chars = charArray;
this.pos = offset;
this.len = length;
String paramName;
String paramValue;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (charArray[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
if (paramValue != null) {
try {
paramValue = RFC2231Utility.hasEncodedValue(paramName) ? RFC2231Utility.decodeText(paramValue) : MimeUtility.decodeText(paramValue);
} catch (final UnsupportedEncodingException e) {
}
}
}
if (hasChar() && (charArray[pos] == separator)) {
pos++;
}
if ((paramName != null) && !paramName.isEmpty()) {
paramName = RFC2231Utility.stripDelimiter(paramName);
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase(Locale.ENGLISH);
}
params.put(paramName, paramValue);
}
}
return params;
}",1
2792,private boolean opened;,1
2793,"static protected final byte[] ENCODING_TABLE = { (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F' };",1
2794,"protected Map parseHeaders(String headerPart) {
Map headers = new HashMap();
char[] buffer = new char[MAX_HEADER_SIZE];
boolean done = false;
int j = 0;
int i;
String header, headerName, headerValue;
try {
while (!done) {
i = 0;
while (i < 2 || buffer[i - 2] != '\r' || buffer[i - 1] != '\n') {
buffer[i++] = headerPart.charAt(j++);
}
header = new String(buffer, 0, i - 2);
if (header.equals("""")) {
done = true;
} else {
if (header.indexOf(':') == -1) {
continue;
}
headerName = header.substring(0, header.indexOf(':')).trim().toLowerCase();
headerValue = header.substring(header.indexOf(':') + 1).trim();
if (getHeader(headers, headerName) != null) {
headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
} else {
headers.put(headerName, headerValue);
}
}
}
} catch (IndexOutOfBoundsException e) {
}
return headers;
}",0
2795,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
Map headers = parseHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = getHeader(headers, CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, getHeader(headers, CONTENT_TYPE), fileName == null);
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, getHeader(headers, CONTENT_TYPE), false);
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
2796,"@Override
public byte[] get() throws UncheckedIOException {
if (isInMemory()) {
if (cachedContent == null && dfos != null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
try (InputStream fis = Files.newInputStream(dfos.getFile().toPath())) {
IOUtils.readFully(fis, fileData);
} catch (IOException e) {
throw new UncheckedIOException(e);
}
return fileData;
}",1
2797,protected boolean lastWhitespace = false;,1
2798,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
2799,"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (final UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2800,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
if (repository != null) {
if (repository.isDirectory()) {
if (repository.getPath().contains(""\0"")) {
throw new IOException(format(""The repository [%s] contains a null character"", repository.getPath()));
}
} else {
throw new IOException(format(""The repository [%s] is not a directory"", repository.getAbsolutePath()));
}
}
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",1
2801,"public List parseRequest(RequestContext ctx) throws FileUploadException {
List items = new ArrayList();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((org.apache.commons.fileupload.FileUploadBase.FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (Iterator iterator = items.iterator(); iterator.hasNext(); ) {
FileItem fileItem = (FileItem) iterator.next();
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
2802,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
2803,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
if (repository != null) {
if (repository.isDirectory()) {
if (repository.getPath().contains(""\0"")) {
throw new IOException(format(""The repository [%s] contains a null character"", repository.getPath()));
}
} else {
throw new IOException(format(""The repository [%s] is not a directory"", repository.getAbsolutePath()));
}
}
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
new Throwable(dfosFile.toString()).printStackTrace();
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
input.close();
System.out.println(""deleted?"" + dfosFile.delete() + "" "" + dfosFile);
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
2804,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
2805,"public Map<String, String> parse(final char[] charArray, final int offset, final int length, final char separator) {
if (charArray == null) {
return new HashMap<>();
}
final HashMap<String, String> params = new HashMap<>();
this.chars = charArray;
this.pos = offset;
this.len = length;
String paramName;
String paramValue;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (charArray[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
if (paramValue != null) {
try {
paramValue = RFC2231Utility.hasEncodedValue(paramName) ? RFC2231Utility.decodeText(paramValue) : MimeUtility.decodeText(paramValue);
} catch (final UnsupportedEncodingException e) {
}
}
}
if (hasChar() && (charArray[pos] == separator)) {
pos++;
}
if ((paramName != null) && !paramName.isEmpty()) {
paramName = RFC2231Utility.stripDelimiter(paramName);
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase(Locale.ENGLISH);
}
params.put(paramName, paramValue);
}
}
return params;
}",1
2806,"@Override
public String getString() {
byte[] rawdata = new byte[0];
try {
rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
return new String(rawdata, charset);
} catch (final IOException e) {
return new String(rawdata);
}
}",0
2807,protected boolean lastCR = false;,1
2808,"@Deprecated
protected final String getHeader(Map<String, String> headers, String name) {
return headers.get(name.toLowerCase());
}",1
2809,"protected Map parseHeaders(String headerPart) {
final int len = headerPart.length();
Map headers = new HashMap();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
2810,"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (final UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2811,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fileItemFactory = Objects.requireNonNull(getFileItemFactory(), ""No FileItemFactory has been set."");
final byte[] buffer = new byte[Streams.DEFAULT_BUFFER_SIZE];
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemStreamImpl) item).getName();
FileItem fileItem = fileItemFactory.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Exception ignored) {
}
}
}
}
}",1
2812,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
2813,"@Override
public String getString() {
byte[] rawdata = new byte[0];
try {
rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
return new String(rawdata, charset);
} catch (final IOException e) {
return new String(rawdata);
}
}",0
2814,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fileItemFactory = Objects.requireNonNull(getFileItemFactory(), ""No FileItemFactory has been set."");
final byte[] buffer = new byte[Streams.DEFAULT_BUFFER_SIZE];
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemStreamImpl) item).getName();
FileItem fileItem = fileItemFactory.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Exception ignored) {
}
}
}
}
}",1
2815,"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (final UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",1
2816,"@Override
public String getString() {
byte[] rawdata = new byte[0];
try {
rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
return new String(rawdata, charset);
} catch (final IOException e) {
return new String(rawdata);
}
}",0
2817,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2818,"public Iterator<String> getHeaders(String name) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = Collections.emptyList();
}
return headerValueList.iterator();
}",1
2819,"@Override
public String getString() {
byte[] rawdata = new byte[0];
try {
rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
return new String(rawdata, charset);
} catch (final IOException e) {
return new String(rawdata);
}
}",0
2820,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
final byte[] buffer = new byte[8192];
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
2821,"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
2822,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
2823,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2824,private boolean opened;,0
2825,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. "", MULTIPART_FORM_DATA, e.getMessage()), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
2826,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. "", MULTIPART_FORM_DATA, e.getMessage()), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
2827,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2828,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
currentItem.setHeaders(headers);
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
currentItem.setHeaders(headers);
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
2829,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2830,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(pContentDisposition, ';');
fieldName = params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
2831,"@Deprecated
protected final String getHeader(Map<String, String> headers, String name) {
return headers.get(name.toLowerCase());
}",0
2832,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. "", MULTIPART_FORM_DATA, e.getMessage()), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
2833,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
2834,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
2835,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
2836,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
2837,"@Deprecated
public MultipartStream() {
this(null, null, null);
}",0
2838,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
2839,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", HEADER_PART_SIZE_MAX));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
2840,"public Map<String, String> parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2841,"public Map<String, String> parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2842,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
2843,"@Override
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2844,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
2845,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2846,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2847,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2848,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList<String>();
headerNameToValueListMap.put(nameLower, headerValueList);
}
headerValueList.add(value);
}",0
2849,"public Iterator<String> getHeaders(String name) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = Collections.emptyList();
}
return headerValueList.iterator();
}",0
2850,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return headerValueList.get(0);
}",0
2851,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
2852,"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
2853,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. "", MULTIPART_FORM_DATA, e.getMessage()), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
2854,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2855,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2856,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
currentItem.setHeaders(headers);
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
currentItem.setHeaders(headers);
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
2857,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(pContentDisposition, ';');
fieldName = params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
2858,"@Deprecated
protected final String getHeader(Map<String, String> headers, String name) {
return headers.get(name.toLowerCase());
}",0
2859,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2860,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
2861,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. "", MULTIPART_FORM_DATA, e.getMessage()), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
2862,private boolean opened;,0
2863,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
2864,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", HEADER_PART_SIZE_MAX));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
2865,"@Deprecated
public MultipartStream() {
this(null, null, null);
}",0
2866,"public Map<String, String> parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2867,"public Map<String, String> parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2868,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2869,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2870,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
2871,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
2872,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2873,"@Override
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2874,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2875,"public Iterator<String> getHeaders(String name) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = Collections.emptyList();
}
return headerValueList.iterator();
}",0
2876,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList<String>();
headerNameToValueListMap.put(nameLower, headerValueList);
}
headerValueList.add(value);
}",0
2877,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return headerValueList.get(0);
}",0
2878,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
2879,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
2880,"protected String getFieldName(Map headers) {
String fieldName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
2881,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2882,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2883,"protected String getFileName(Map headers) {
String fileName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null) {
String cdl = cd.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
2884,"private void parseHeaderLine(Map headers, String header) {
final int colonOffset = header.indexOf(':');
if (colonOffset == -1) {
return;
}
String headerName = header.substring(0, colonOffset).trim().toLowerCase();
String headerValue = header.substring(header.indexOf(':') + 1).trim();
if (getHeader(headers, headerName) != null) {
headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
} else {
headers.put(headerName, headerValue);
}
}",0
2885,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
2886,private boolean opened;,0
2887,"protected Map parseHeaders(String headerPart) {
final int len = headerPart.length();
Map headers = new HashMap();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
2888,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
2889,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2890,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
Map headers = parseHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = getHeader(headers, CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, getHeader(headers, CONTENT_TYPE), fileName == null);
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, getHeader(headers, CONTENT_TYPE), false);
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
2891,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
2892,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
2893,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
2894,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte[] b = new byte[1];
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int sizeMax = HEADER_PART_SIZE_MAX;
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b[0] = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
size++;
if (b[0] == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
if (size <= sizeMax) {
baos.write(b[0]);
}
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
2895,"public MultipartStream() {
this(null, null, null);
}",0
2896,"public void close() throws IOException {
if (closed) {
return;
}
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
closed = true;
}",0
2897,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
2898,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2899,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2900,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2901,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2902,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2903,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2904,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
2905,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
2906,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2907,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2908,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
2909,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
2910,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2911,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2912,"protected String getFieldName(Map headers) {
String fieldName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
2913,"protected String getFileName(Map headers) {
String fileName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null) {
String cdl = cd.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
2914,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
2915,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2916,private boolean opened;,0
2917,"private void parseHeaderLine(Map headers, String header) {
final int colonOffset = header.indexOf(':');
if (colonOffset == -1) {
return;
}
String headerName = header.substring(0, colonOffset).trim().toLowerCase();
String headerValue = header.substring(header.indexOf(':') + 1).trim();
if (getHeader(headers, headerName) != null) {
headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
} else {
headers.put(headerName, headerValue);
}
}",0
2918,"public void close() throws IOException {
if (closed) {
return;
}
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
closed = true;
}",0
2919,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte[] b = new byte[1];
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int sizeMax = HEADER_PART_SIZE_MAX;
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b[0] = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
size++;
if (b[0] == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
if (size <= sizeMax) {
baos.write(b[0]);
}
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
2920,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2921,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2922,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2923,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2924,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2925,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
2926,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2927,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
2928,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
2929,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2930,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
2931,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
2932,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2933,"protected Map parseHeaders(String headerPart) {
final int len = headerPart.length();
Map headers = new HashMap();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
2934,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
2935,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2936,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
Map headers = parseHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = getHeader(headers, CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, getHeader(headers, CONTENT_TYPE), fileName == null);
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, getHeader(headers, CONTENT_TYPE), false);
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
2937,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2938,"private void parseHeaderLine(Map headers, String header) {
final int colonOffset = header.indexOf(':');
if (colonOffset == -1) {
return;
}
String headerName = header.substring(0, colonOffset).trim().toLowerCase();
String headerValue = header.substring(header.indexOf(':') + 1).trim();
if (getHeader(headers, headerName) != null) {
headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
} else {
headers.put(headerName, headerValue);
}
}",0
2939,private boolean opened;,0
2940,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
2941,"protected String getFileName(Map headers) {
String fileName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null) {
String cdl = cd.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
2942,"protected String getFieldName(Map headers) {
String fieldName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
2943,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
2944,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
2945,"public MultipartStream() {
this(null, null, null);
}",0
2946,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
2947,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte[] b = new byte[1];
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int sizeMax = HEADER_PART_SIZE_MAX;
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b[0] = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
size++;
if (b[0] == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
if (size <= sizeMax) {
baos.write(b[0]);
}
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
2948,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
2949,"public void close() throws IOException {
if (closed) {
return;
}
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
closed = true;
}",0
2950,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2951,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2952,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
2953,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
2954,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2955,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2956,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2957,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2958,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2959,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2960,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
2961,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
2962,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
2963,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
((FileItemHeadersSupport) fileItem).setHeaders(fih);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
2964,"protected FileItemHeaders getParsedHeaders(String headerPart) {
final int len = headerPart.length();
FileItemHeadersImpl headers = newFileItemHeaders();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
2965,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2966,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
2967,private boolean opened;,0
2968,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
2969,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2970,"protected Map parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map result = new HashMap();
for (Iterator iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = (String) iter.next();
Iterator iter2 = headers.getHeaders(headerName);
String headerValue = (String) iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",0
2971,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
2972,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
2973,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
2974,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
2975,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
2976,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(""Header section has more than "" + HEADER_PART_SIZE_MAX + "" bytes (maybe it is not properly terminated)"");
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
2977,"public MultipartStream() {
this(null, null, null);
}",0
2978,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
2979,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
2980,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2981,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
2982,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
2983,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2984,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
2985,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
2986,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2987,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
2988,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
2989,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0
2990,"public Iterator getHeaders(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return Collections.EMPTY_LIST.iterator();
}
return headerValueList.iterator();
}",0
2991,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return (String) headerValueList.get(0);
}",0
2992,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
2993,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
2994,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
2995,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
2996,"protected FileItemHeaders getParsedHeaders(String headerPart) {
final int len = headerPart.length();
FileItemHeadersImpl headers = newFileItemHeaders();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
2997,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
((FileItemHeadersSupport) fileItem).setHeaders(fih);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
2998,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
2999,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3000,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3001,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
3002,private boolean opened;,0
3003,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3004,"protected Map parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map result = new HashMap();
for (Iterator iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = (String) iter.next();
Iterator iter2 = headers.getHeaders(headerName);
String headerValue = (String) iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",0
3005,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3006,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3007,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3008,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3009,"public MultipartStream() {
this(null, null, null);
}",0
3010,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(""Header section has more than "" + HEADER_PART_SIZE_MAX + "" bytes (maybe it is not properly terminated)"");
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3011,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3012,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3013,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3014,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3015,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3016,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3017,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3018,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3019,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3020,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3021,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0
3022,"public Iterator getHeaders(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return Collections.EMPTY_LIST.iterator();
}
return headerValueList.iterator();
}",0
3023,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return (String) headerValueList.get(0);
}",0
3024,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
3025,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3026,"private void parseHeaderLine(Map headers, String header) {
final int colonOffset = header.indexOf(':');
if (colonOffset == -1) {
return;
}
String headerName = header.substring(0, colonOffset).trim().toLowerCase();
String headerValue = header.substring(header.indexOf(':') + 1).trim();
if (getHeader(headers, headerName) != null) {
headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
} else {
headers.put(headerName, headerValue);
}
}",0
3027,"protected String getFieldName(Map headers) {
String fieldName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
3028,"protected Map parseHeaders(String headerPart) {
final int len = headerPart.length();
Map headers = new HashMap();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
3029,private boolean opened;,0
3030,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3031,"protected String getFileName(Map headers) {
String fileName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null) {
String cdl = cd.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
3032,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
Map headers = parseHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = getHeader(headers, CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, getHeader(headers, CONTENT_TYPE), fileName == null);
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, getHeader(headers, CONTENT_TYPE), false);
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
3033,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3034,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3035,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
3036,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
3037,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte[] b = new byte[1];
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int sizeMax = HEADER_PART_SIZE_MAX;
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b[0] = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
size++;
if (b[0] == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
if (size <= sizeMax) {
baos.write(b[0]);
}
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3038,"public void close() throws IOException {
if (closed) {
return;
}
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
closed = true;
}",0
3039,"public MultipartStream() {
this(null, null, null);
}",0
3040,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3041,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3042,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3043,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3044,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3045,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3046,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3047,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3048,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3049,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3050,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3051,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3052,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3053,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3054,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
3055,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3056,"protected FileItemHeaders getParsedHeaders(String headerPart) {
final int len = headerPart.length();
FileItemHeadersImpl headers = newFileItemHeaders();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
3057,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
3058,private boolean opened;,0
3059,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
3060,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3061,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3062,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
((FileItemHeadersSupport) fileItem).setHeaders(fih);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
3063,"protected Map parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map result = new HashMap();
for (Iterator iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = (String) iter.next();
Iterator iter2 = headers.getHeaders(headerName);
String headerValue = (String) iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",0
3064,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
3065,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3066,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
3067,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3068,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3069,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3070,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3071,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(""Header section has more than "" + HEADER_PART_SIZE_MAX + "" bytes (maybe it is not properly terminated)"");
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3072,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3073,"public MultipartStream() {
this(null, null, null);
}",0
3074,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3075,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3076,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3077,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3078,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3079,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3080,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3081,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3082,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3083,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0
3084,"public Iterator getHeaders(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return Collections.EMPTY_LIST.iterator();
}
return headerValueList.iterator();
}",0
3085,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return (String) headerValueList.get(0);
}",0
3086,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
3087,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3088,"protected FileItemHeaders getParsedHeaders(String headerPart) {
final int len = headerPart.length();
FileItemHeadersImpl headers = newFileItemHeaders();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
3089,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3090,"protected Map parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map result = new HashMap();
for (Iterator iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = (String) iter.next();
Iterator iter2 = headers.getHeaders(headerName);
String headerValue = (String) iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",0
3091,"protected Map parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map result = new HashMap();
for (Iterator iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = (String) iter.next();
Iterator iter2 = headers.getHeaders(headerName);
String headerValue = (String) iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",0
3092,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
((FileItemHeadersSupport) fileItem).setHeaders(fih);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
3093,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
3094,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
3095,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3096,private boolean opened;,0
3097,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3098,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
3099,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3100,"public MultipartStream() {
this(null, null, null);
}",0
3101,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3102,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3103,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(""Header section has more than "" + HEADER_PART_SIZE_MAX + "" bytes (maybe it is not properly terminated)"");
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3104,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3105,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3106,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3107,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3108,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3109,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3110,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3111,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3112,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3113,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3114,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3115,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return (String) headerValueList.get(0);
}",0
3116,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0
3117,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0
3118,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
3119,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3120,"protected FileItemHeaders getParsedHeaders(String headerPart) {
final int len = headerPart.length();
FileItemHeadersImpl headers = newFileItemHeaders();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
3121,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3122,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
3123,"protected Map parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map result = new HashMap();
for (Iterator iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = (String) iter.next();
Iterator iter2 = headers.getHeaders(headerName);
String headerValue = (String) iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",0
3124,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
((FileItemHeadersSupport) fileItem).setHeaders(item.getHeaders());
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
3125,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
3126,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
3127,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3128,private boolean opened;,0
3129,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3130,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
3131,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3132,"public MultipartStream() {
this(null, null, null);
}",0
3133,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3134,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3135,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(""Header section has more than "" + HEADER_PART_SIZE_MAX + "" bytes (maybe it is not properly terminated)"");
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3136,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3137,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3138,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3139,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3140,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3141,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3142,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3143,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3144,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3145,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3146,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3147,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return (String) headerValueList.get(0);
}",0
3148,"public Iterator getHeaders(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return Collections.EMPTY_LIST.iterator();
}
return headerValueList.iterator();
}",0
3149,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0
3150,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
3151,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3152,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
3153,"protected FileItemHeaders getParsedHeaders(String headerPart) {
final int len = headerPart.length();
FileItemHeadersImpl headers = newFileItemHeaders();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
3154,private boolean opened;,0
3155,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3156,"protected Map parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map result = new HashMap();
for (Iterator iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = (String) iter.next();
Iterator iter2 = headers.getHeaders(headerName);
String headerValue = (String) iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",0
3157,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3158,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
3159,"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
3160,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3161,"private String getFieldName(String pContentDisposition) {
String fieldName = null;
if (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
3162,"public List parseRequest(RequestContext ctx) throws FileUploadException {
List items = new ArrayList();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((org.apache.commons.fileupload.FileUploadBase.FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
((FileItemHeadersSupport) fileItem).setHeaders(fih);
}
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (Iterator iterator = items.iterator(); iterator.hasNext(); ) {
FileItem fileItem = (FileItem) iterator.next();
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
3163,"public MultipartStream() {
this(null, null, null);
}",0
3164,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3165,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3166,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3167,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3168,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3169,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(""Header section has more than "" + HEADER_PART_SIZE_MAX + "" bytes (maybe it is not properly terminated)"");
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3170,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3171,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3172,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3173,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3174,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3175,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3176,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3177,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3178,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3179,"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0
3180,"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return (String) headerValueList.get(0);
}",0
3181,"public Iterator getHeaders(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return Collections.EMPTY_LIST.iterator();
}
return headerValueList.iterator();
}",0
3182,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
3183,"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3184,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fileItemFactory = Objects.requireNonNull(getFileItemFactory(), ""No FileItemFactory has been set."");
final byte[] buffer = new byte[Streams.DEFAULT_BUFFER_SIZE];
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemStreamImpl) item).getName();
FileItem fileItem = fileItemFactory.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadException e) {
throw e;
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Exception ignored) {
}
}
}
}
}",0
3185,"public byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3186,"public FileItemIterator getItemIterator(RequestContext ctx) throws FileUploadException, IOException {
try {
return new FileItemIteratorImpl(this, ctx);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3187,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fileItemFactory = Objects.requireNonNull(getFileItemFactory(), ""No FileItemFactory has been set."");
final byte[] buffer = new byte[Streams.DEFAULT_BUFFER_SIZE];
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemStreamImpl) item).getName();
FileItem fileItem = fileItemFactory.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadException e) {
throw e;
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Exception ignored) {
}
}
}
}
}",0
3188,"public byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3189,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3190,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3191,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3192,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3193,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3194,"public String readHeaders() throws FileUploadIOException, MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (FileUploadIOException e) {
throw e;
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", Integer.valueOf(HEADER_PART_SIZE_MAX)));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3195,"public Map<String, String> parse(final char[] charArray, int offset, int length, char separator) {
if (charArray == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = charArray;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (charArray[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
if (paramValue != null) {
try {
paramValue = RFC2231Utility.hasEncodedValue(paramName) ? RFC2231Utility.decodeText(paramValue) : MimeUtility.decodeText(paramValue);
} catch (UnsupportedEncodingException e) {
}
}
}
if (hasChar() && (charArray[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
paramName = RFC2231Utility.stripDelimiter(paramName);
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase(Locale.ENGLISH);
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3196,"@Override
public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3197,"@Override
public byte[] get() {
if (isInMemory()) {
if (cachedContent == null && dfos != null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
IOUtils.readFully(fis, fileData);
} catch (IOException e) {
fileData = null;
} finally {
IOUtils.closeQuietly(fis);
}
return fileData;
}",0
3198,"@Override
public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && !isInMemory() && outputFile.exists()) {
outputFile.delete();
}
}",0
3199,"@Override
protected void finalize() throws Throwable {
if (dfos == null || dfos.isInMemory()) {
return;
}
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
super.finalize();
}",0
3200,"@Override
public boolean hasNext() throws FileUploadException, IOException {
if (eof) {
return false;
}
if (itemValid) {
return true;
}
try {
return findNextItem();
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3201,private boolean opened;,0
3202,"public List<FileItem> parseRequest(HttpServletRequest request) throws FileUploadException {
return parseRequest(new JakSrvltRequestContext(request));
}",0
3203,"public static String asString(InputStream inputStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(inputStream, baos, true);
return baos.toString();
}",0
3204,"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3205,"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
Map headers = parseHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = getHeader(headers, CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, getHeader(headers, CONTENT_TYPE), fileName == null);
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, getHeader(headers, CONTENT_TYPE), false);
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0
3206,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3207,"private void parseHeaderLine(Map headers, String header) {
final int colonOffset = header.indexOf(':');
if (colonOffset == -1) {
return;
}
String headerName = header.substring(0, colonOffset).trim().toLowerCase();
String headerValue = header.substring(header.indexOf(':') + 1).trim();
if (getHeader(headers, headerName) != null) {
headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
} else {
headers.put(headerName, headerValue);
}
}",0
3208,"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3209,private boolean opened;,0
3210,"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
final byte[] buffer = new byte[8192];
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0
3211,"protected String getFieldName(Map headers) {
String fieldName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0
3212,"protected String getFileName(Map headers) {
String fileName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null) {
String cdl = cd.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0
3213,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, ';');
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3214,"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0
3215,"protected Map parseHeaders(String headerPart) {
final int len = headerPart.length();
Map headers = new HashMap();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0
3216,"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte[] b = new byte[1];
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int sizeMax = HEADER_PART_SIZE_MAX;
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b[0] = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
size++;
if (b[0] == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
if (size <= sizeMax) {
baos.write(b[0]);
}
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3217,"public void close() throws IOException {
if (closed) {
return;
}
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
closed = true;
}",0
3218,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3219,"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3220,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3221,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3222,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3223,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3224,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3225,"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3226,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3227,"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0
3228,"public String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
3229,"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3230,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
3231,"public boolean hasNext() throws FileUploadException, IOException {
if (eof) {
return false;
}
if (itemValid) {
return true;
}
try {
return findNextItem();
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3232,"public FileItemIterator getItemIterator(RequestContext ctx) throws FileUploadException, IOException {
try {
return new FileItemIteratorImpl(ctx);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3233,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3234,private boolean opened;,0
3235,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3236,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3237,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3238,"@Deprecated
public MultipartStream() {
this(null, null, null);
}",0
3239,"public String readHeaders() throws FileUploadIOException, MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (FileUploadIOException e) {
throw e;
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", HEADER_PART_SIZE_MAX));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3240,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3241,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3242,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3243,"public Map<String, String> parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
if (paramValue != null) {
try {
paramValue = MimeUtility.decodeText(paramValue);
} catch (UnsupportedEncodingException e) {
}
}
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase(Locale.ENGLISH);
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3244,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3245,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3246,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3247,"@Override
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3248,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3249,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3250,"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0
3251,"private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
throw new ParseException(""Invalid RFC 2047 encoded-word: "" + word);
}
int charsetPos = word.indexOf('?', 2);
if (charsetPos == -1) {
throw new ParseException(""Missing charset in RFC 2047 encoded-word: "" + word);
}
String charset = word.substring(2, charsetPos).toLowerCase();
int encodingPos = word.indexOf('?', charsetPos + 1);
if (encodingPos == -1) {
throw new ParseException(""Missing encoding in RFC 2047 encoded-word: "" + word);
}
String encoding = word.substring(charsetPos + 1, encodingPos);
int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
if (encodedTextPos == -1) {
throw new ParseException(""Missing encoded text in RFC 2047 encoded-word: "" + word);
}
String encodedText = word.substring(encodingPos + 1, encodedTextPos);
if (encodedText.length() == 0) {
return """";
}
try {
ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
byte[] encodedData = encodedText.getBytes(US_ASCII_CHARSET);
if (encoding.equals(BASE64_ENCODING_MARKER)) {
Base64Decoder.decode(encodedData, out);
} else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
QuotedPrintableDecoder.decode(encodedData, out);
} else {
throw new UnsupportedEncodingException(""Unknown RFC 2047 encoding: "" + encoding);
}
byte[] decodedData = out.toByteArray();
return new String(decodedData, javaCharset(charset));
} catch (IOException e) {
throw new UnsupportedEncodingException(""Invalid RFC 2047 encoding"");
}
}",0
3252,"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3253,"public boolean hasNext() throws FileUploadException, IOException {
if (eof) {
return false;
}
if (itemValid) {
return true;
}
try {
return findNextItem();
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3254,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3255,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3256,private boolean opened;,0
3257,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
3258,"public FileItemIterator getItemIterator(RequestContext ctx) throws FileUploadException, IOException {
try {
return new FileItemIteratorImpl(ctx);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3259,"public String readHeaders() throws FileUploadIOException, MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (FileUploadIOException e) {
throw e;
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", Integer.valueOf(HEADER_PART_SIZE_MAX)));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3260,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3261,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3262,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3263,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3264,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3265,"public Map<String, String> parse(final char[] charArray, int offset, int length, char separator) {
if (charArray == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = charArray;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (charArray[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
if (paramValue != null) {
try {
paramValue = MimeUtility.decodeText(paramValue);
} catch (UnsupportedEncodingException e) {
}
}
}
if (hasChar() && (charArray[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase(Locale.ENGLISH);
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3266,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3267,"@Override
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3268,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3269,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3270,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3271,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
if (repository != null) {
if (repository.isDirectory()) {
if (repository.getPath().contains(""\0"")) {
throw new IOException(format(""The repository [%s] contains a null character"", repository.getPath()));
}
} else {
throw new IOException(format(""The repository [%s] is not a directory"", repository.getAbsolutePath()));
}
}
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3272,"public static String asString(InputStream inputStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(inputStream, baos, true);
return baos.toString();
}",0
3273,"private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
throw new ParseException(""Invalid RFC 2047 encoded-word: "" + word);
}
int charsetPos = word.indexOf('?', 2);
if (charsetPos == -1) {
throw new ParseException(""Missing charset in RFC 2047 encoded-word: "" + word);
}
String charset = word.substring(2, charsetPos).toLowerCase();
int encodingPos = word.indexOf('?', charsetPos + 1);
if (encodingPos == -1) {
throw new ParseException(""Missing encoding in RFC 2047 encoded-word: "" + word);
}
String encoding = word.substring(charsetPos + 1, encodingPos);
int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
if (encodedTextPos == -1) {
throw new ParseException(""Missing encoded text in RFC 2047 encoded-word: "" + word);
}
String encodedText = word.substring(encodingPos + 1, encodedTextPos);
if (encodedText.length() == 0) {
return """";
}
try {
ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
byte[] encodedData = encodedText.getBytes(US_ASCII_CHARSET);
if (encoding.equals(BASE64_ENCODING_MARKER)) {
Base64Decoder.decode(encodedData, out);
} else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
QuotedPrintableDecoder.decode(encodedData, out);
} else {
throw new UnsupportedEncodingException(""Unknown RFC 2047 encoding: "" + encoding);
}
byte[] decodedData = out.toByteArray();
return new String(decodedData, javaCharset(charset));
} catch (IOException e) {
throw new UnsupportedEncodingException(""Invalid RFC 2047 encoding"");
}
}",0
3274,"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3275,"public FileItemIterator getItemIterator(RequestContext ctx) throws FileUploadException, IOException {
try {
return new FileItemIteratorImpl(ctx);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3276,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3277,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
3278,"public boolean hasNext() throws FileUploadException, IOException {
if (eof) {
return false;
}
if (itemValid) {
return true;
}
try {
return findNextItem();
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3279,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3280,private boolean opened;,0
3281,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3282,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3283,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3284,"public String readHeaders() throws FileUploadIOException, MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (FileUploadIOException e) {
throw e;
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", Integer.valueOf(HEADER_PART_SIZE_MAX)));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3285,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3286,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3287,"public Map<String, String> parse(final char[] charArray, int offset, int length, char separator) {
if (charArray == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = charArray;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (charArray[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
if (paramValue != null) {
try {
paramValue = MimeUtility.decodeText(paramValue);
} catch (UnsupportedEncodingException e) {
}
}
}
if (hasChar() && (charArray[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase(Locale.ENGLISH);
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3288,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
if (!Boolean.getBoolean(SERIALIZABLE_PROPERTY)) {
throw new IllegalStateException(""Property "" + SERIALIZABLE_PROPERTY + "" is not true, rejecting to deserialize a DiskFileItem."");
}
in.defaultReadObject();
if (repository != null) {
if (repository.isDirectory()) {
if (repository.getPath().contains(""\0"")) {
throw new IOException(format(""The repository [%s] contains a null character"", repository.getPath()));
}
} else {
throw new IOException(format(""The repository [%s] is not a directory"", repository.getAbsolutePath()));
}
}
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3289,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3290,"@Override
protected void finalize() {
if (dfos == null || dfos.isInMemory()) {
return;
}
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3291,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && !isInMemory() && outputFile.exists()) {
outputFile.delete();
}
}",0
3292,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3293,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3294,"public static String asString(InputStream inputStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(inputStream, baos, true);
return baos.toString();
}",0
3295,"private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
throw new ParseException(""Invalid RFC 2047 encoded-word: "" + word);
}
int charsetPos = word.indexOf('?', 2);
if (charsetPos == -1) {
throw new ParseException(""Missing charset in RFC 2047 encoded-word: "" + word);
}
String charset = word.substring(2, charsetPos).toLowerCase();
int encodingPos = word.indexOf('?', charsetPos + 1);
if (encodingPos == -1) {
throw new ParseException(""Missing encoding in RFC 2047 encoded-word: "" + word);
}
String encoding = word.substring(charsetPos + 1, encodingPos);
int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
if (encodedTextPos == -1) {
throw new ParseException(""Missing encoded text in RFC 2047 encoded-word: "" + word);
}
String encodedText = word.substring(encodingPos + 1, encodedTextPos);
if (encodedText.length() == 0) {
return """";
}
try {
ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
byte[] encodedData = encodedText.getBytes(US_ASCII_CHARSET);
if (encoding.equals(BASE64_ENCODING_MARKER)) {
Base64Decoder.decode(encodedData, out);
} else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
QuotedPrintableDecoder.decode(encodedData, out);
} else {
throw new UnsupportedEncodingException(""Unknown RFC 2047 encoding: "" + encoding);
}
byte[] decodedData = out.toByteArray();
return new String(decodedData, javaCharset(charset));
} catch (IOException e) {
throw new UnsupportedEncodingException(""Invalid RFC 2047 encoding"");
}
}",0
3296,"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0
3297,"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Throwable e) {
}
}
}
}
}",0
3298,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3299,"public boolean hasNext() throws FileUploadException, IOException {
if (eof) {
return false;
}
if (itemValid) {
return true;
}
try {
return findNextItem();
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3300,"public FileItemIterator getItemIterator(RequestContext ctx) throws FileUploadException, IOException {
try {
return new FileItemIteratorImpl(ctx);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0
3301,"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0
3302,private boolean opened;,0
3303,"public String readHeaders() throws FileUploadIOException, MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (FileUploadIOException e) {
throw e;
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", Integer.valueOf(HEADER_PART_SIZE_MAX)));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0
3304,"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
3305,"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
3306,"public void close(boolean pCloseUnderlying) throws IOException {
if (closed) {
return;
}
if (pCloseUnderlying) {
closed = true;
input.close();
} else {
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
}
closed = true;
}",0
3307,"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
3308,"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
3309,"public Map<String, String> parse(final char[] charArray, int offset, int length, char separator) {
if (charArray == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = charArray;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (charArray[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
if (paramValue != null) {
try {
paramValue = MimeUtility.decodeText(paramValue);
} catch (UnsupportedEncodingException e) {
}
}
}
if (hasChar() && (charArray[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase(Locale.ENGLISH);
}
params.put(paramName, paramValue);
}
}
return params;
}",0
3310,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3311,"@Override
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3312,"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0
3313,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
if (repository != null) {
if (repository.isDirectory()) {
if (repository.getPath().contains(""\0"")) {
throw new IOException(format(""The repository [%s] contains a null character"", repository.getPath()));
}
} else {
throw new IOException(format(""The repository [%s] is not a directory"", repository.getAbsolutePath()));
}
}
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0
3314,"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0
3315,"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0
3316,"public static String asString(InputStream inputStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(inputStream, baos, true);
return baos.toString();
}",0
3317,"private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
throw new ParseException(""Invalid RFC 2047 encoded-word: "" + word);
}
int charsetPos = word.indexOf('?', 2);
if (charsetPos == -1) {
throw new ParseException(""Missing charset in RFC 2047 encoded-word: "" + word);
}
String charset = word.substring(2, charsetPos).toLowerCase();
int encodingPos = word.indexOf('?', charsetPos + 1);
if (encodingPos == -1) {
throw new ParseException(""Missing encoding in RFC 2047 encoded-word: "" + word);
}
String encoding = word.substring(charsetPos + 1, encodingPos);
int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
if (encodedTextPos == -1) {
throw new ParseException(""Missing encoded text in RFC 2047 encoded-word: "" + word);
}
String encodedText = word.substring(encodingPos + 1, encodedTextPos);
if (encodedText.length() == 0) {
return """";
}
try {
ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
byte[] encodedData = encodedText.getBytes(US_ASCII_CHARSET);
if (encoding.equals(BASE64_ENCODING_MARKER)) {
Base64Decoder.decode(encodedData, out);
} else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
QuotedPrintableDecoder.decode(encodedData, out);
} else {
throw new UnsupportedEncodingException(""Unknown RFC 2047 encoding: "" + encoding);
}
byte[] decodedData = out.toByteArray();
return new String(decodedData, javaCharset(charset));
} catch (IOException e) {
throw new UnsupportedEncodingException(""Invalid RFC 2047 encoding"");
}
}",0
3318,protected List reactorProjects;,0
3319,protected boolean outputAbsoluteArtifactFilename;,0
3320,protected MavenProject project;,0
3321,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3322,public boolean silent;,0
3323,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3324,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3325,protected File outputFile;,0
3326,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.getLocal());
return resolveDependencyArtifacts(pomProject);
}",0
3327,protected MavenProjectBuilder mavenProjectBuilder;,0
3328,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3329,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3330,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0
3331,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0
3332,private MavenProject project;,0
3333,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0
3334,private Renderer siteRenderer;,0
3335,"public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}",0
3336,private File outputDirectory;,0
3337,private ProjectDependencyAnalyzer analyzer;,0
3338,"protected String getOutputDirectory() {
getLog().info(outputDirectory.toString());
return outputDirectory.toString();
}",0
3339,"public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}",0
3340,private MavenProject project;,0
3341,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3342,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(outputFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0
3343,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
if (StringUtils.isEmpty(fileSeparator)) {
isFileSepSet = false;
} else {
isFileSepSet = true;
}
if (StringUtils.isEmpty(pathSeparator)) {
isPathSepSet = false;
} else {
isPathSepSet = true;
}
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
String separator = File.separator;
if (File.separator.equals(""\\"")) {
separator = ""\\\\"";
}
cpString = cpString.replaceAll(separator, fileSeparator);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3344,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
3345,boolean attach;,0
3346,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3347,private File cpFile;,0
3348,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3349,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3350,private MavenProjectHelper projectHelper;,0
3351,"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0
3352,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3353,boolean outputFilterFile;,0
3354,"private void installArtifact(Artifact artifact, ArtifactRepository targetRepository) {
try {
if (""pom"".equals(artifact.getType())) {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
} else {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
if (isCopyPom()) {
Artifact pomArtifact = getResolvedPomArtifact(artifact);
if (pomArtifact.getFile() != null && pomArtifact.getFile().exists()) {
installer.install(pomArtifact.getFile(), pomArtifact, targetRepository);
installBaseSnapshot(pomArtifact, targetRepository);
}
}
}
} catch (ArtifactInstallationException e) {
getLog().info(e.getMessage());
}
}",0
3355,protected ArtifactRepositoryFactory repositoryFactory;,0
3356,protected ArtifactInstaller installer;,0
3357,"private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}",0
3358,"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
copyArtifact((Artifact) i.next(), this.stripVersion);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
installArtifact((Artifact) i.next(), targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set skippedArtifacts = dss.getSkippedDependencies();
for (Iterator i = skippedArtifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0
3359,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
3360,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3361,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3362,"private String serialiseDependencyTree(DependencyNode rootNode) {
StringWriter writer = new StringWriter();
TreeTokens treeTokens = toTreeTokens(tokens);
DependencyNodeVisitor visitor = getSerializingDependencyNodeVisitor(writer);
// TODO: remove the need for this when the serializer can calculate last nodes from visitor calls only
visitor = new BuildingDependencyNodeVisitor(visitor);
DependencyNodeFilter filter = createDependencyNodeFilter();
if (filter != null) {
CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();
DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor(collectingVisitor, filter);
rootNode.accept(firstPassVisitor);
DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());
visitor = new FilteringDependencyNodeVisitor(visitor, secondPassFilter);
}
rootNode.accept(visitor);
return writer.toString();
}",0
3363,private ArtifactRepositoryFactory artifactRepositoryManager;,0
3364,"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3365,"protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
if (this.localRepositoryDirectory != null) {
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(super.getLocal().getId(), ""file://"" + this.localRepositoryDirectory.getAbsolutePath(), super.getLocal().getLayout(), super.getLocal().getSnapshots(), super.getLocal().getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
return this.overrideLocalRepository;
}
this.overrideLocalRepository = super.getLocal();
return this.overrideLocalRepository;
}",0
3366,protected boolean outputScope;,0
3367,private boolean excludeTransitive;,0
3368,private List remotePluginRepositories;,0
3369,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Iterator i = plugins.iterator(); i.hasNext(); ) {
Artifact plugin = (Artifact) i.next();
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
Set transitiveDependencies = this.resolveArtifactDependencies(plugin);
for (Iterator transIter = transitiveDependencies.iterator(); transIter.hasNext(); ) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName((Artifact) transIter.next(), false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3370,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Iterator i = plugins.iterator(); i.hasNext(); ) {
Artifact plugin = (Artifact) i.next();
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
Set transitiveDependencies = this.resolveArtifactDependencies(plugin);
for (Iterator transIter = transitiveDependencies.iterator(); transIter.hasNext(); ) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName((Artifact) transIter.next(), false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3371,"public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}",0
3372,"public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}",0
3373,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3374,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3375,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3376,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3377,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3378,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
3379,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3380,"protected DependencyStatusSets getDependencySets(boolean stopOnFailure) throws MojoExecutionException {
FilterArtifacts filter = new FilterArtifacts();
filter.addFilter(new ProjectTransitivityFilter(project.getDependencyArtifacts(), this.excludeTransitive));
filter.addFilter(new ScopeFilter(DependencyUtil.cleanToBeTokenizedString(this.includeScope), DependencyUtil.cleanToBeTokenizedString(this.excludeScope)));
filter.addFilter(new TypeFilter(DependencyUtil.cleanToBeTokenizedString(this.includeTypes), DependencyUtil.cleanToBeTokenizedString(this.excludeTypes)));
filter.addFilter(new ClassifierFilter(DependencyUtil.cleanToBeTokenizedString(this.includeClassifiers), DependencyUtil.cleanToBeTokenizedString(this.excludeClassifiers)));
filter.addFilter(new GroupIdFilter(DependencyUtil.cleanToBeTokenizedString(this.includeGroupIds), DependencyUtil.cleanToBeTokenizedString(this.excludeGroupIds)));
filter.addFilter(new ArtifactIdFilter(DependencyUtil.cleanToBeTokenizedString(this.includeArtifactIds), DependencyUtil.cleanToBeTokenizedString(this.excludeArtifactIds)));
Set<Artifact> artifacts = project.getArtifacts();
try {
artifacts = filter.filter(artifacts);
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
DependencyStatusSets status = null;
if (StringUtils.isNotEmpty(classifier)) {
status = getClassifierTranslatedDependencies(artifacts, stopOnFailure);
} else {
status = filterMarkedDependencies(artifacts);
}
return status;
}",0
3381,public boolean silent;,0
3382,protected boolean outputAbsoluteArtifactFilename;,0
3383,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3384,protected List<MavenProject> reactorProjects;,0
3385,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3386,protected MavenProject project;,0
3387,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3388,protected File outputFile;,0
3389,protected MavenProjectBuilder mavenProjectBuilder;,0
3390,"protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.getLocal());
return resolveDependencyArtifacts(pomProject);
}",0
3391,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3392,private File cpFile;,0
3393,"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0
3394,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
3395,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3396,boolean attach;,0
3397,boolean outputFilterFile;,0
3398,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
3399,"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0
3400,"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0
3401,private MavenProjectHelper projectHelper;,0
3402,"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0
3403,protected ArtifactRepositoryFactory repositoryFactory;,0
3404,protected ArtifactInstaller installer;,0
3405,"private void installArtifact(Artifact artifact, ArtifactRepository targetRepository) {
try {
if (""pom"".equals(artifact.getType())) {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
} else {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
if (isCopyPom()) {
Artifact pomArtifact = getResolvedPomArtifact(artifact);
if (pomArtifact.getFile() != null && pomArtifact.getFile().exists()) {
installer.install(pomArtifact.getFile(), pomArtifact, targetRepository);
installBaseSnapshot(pomArtifact, targetRepository);
}
}
}
} catch (ArtifactInstallationException e) {
getLog().info(e.getMessage());
}
}",0
3406,"private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}",0
3407,"private Map<String, ArtifactRepositoryLayout> repositoryLayouts;",0
3408,"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0
3409,protected MavenProject project;,0
3410,"public void execute() throws MojoExecutionException {
Set<Artifact> artifacts = getProject().getArtifacts();
for (Artifact artifact : artifacts) {
project.getProperties().setProperty(artifact.getDependencyConflictId(), artifact.getFile().getAbsolutePath());
}
}",0
3411,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3412,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3413,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
3414,private ArtifactRepositoryFactory artifactRepositoryManager;,0
3415,"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3416,"public void execute() throws MojoExecutionException {
Set<Artifact> artifacts = project.getArtifacts();
if (!silent) {
for (Artifact artifact : artifacts) {
this.getLog().info(""Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false));
}
}
}",0
3417,protected boolean outputScope;,0
3418,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3419,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3420,private List remotePluginRepositories;,0
3421,private boolean excludeTransitive;,0
3422,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
3423,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
3424,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3425,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3426,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3427,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3428,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3429,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3430,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3431,public boolean silent;,0
3432,protected MavenProject project;,0
3433,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3434,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3435,protected boolean outputAbsoluteArtifactFilename;,0
3436,protected boolean outputAbsoluteArtifactFilename;,0
3437,protected List reactorProjects;,0
3438,protected List reactorProjects;,0
3439,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0
3440,protected MavenProjectBuilder mavenProjectBuilder;,0
3441,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3442,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
3443,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3444,"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}",0
3445,private boolean excludeTransitive;,0
3446,private String groupId;,0
3447,private boolean excludeTransitive;,0
3448,private List remotePluginRepositories;,0
3449,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3450,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3451,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3452,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3453,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3454,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
3455,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3456,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3457,"protected void unpack(Artifact artifact, File location, String includes, String excludes) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(artifact.getType());
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
unArchiver.setUseJvmChmod(useJvmChmod);
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3458,"public boolean include(Artifact artifact) {
if (artifactsGAMatch(artifact, projectArtifact)) {
return true;
}
for (Artifact depArtifact : directDependencyArtifacts) {
if (this.artifactsGAMatch(artifact, depArtifact)) {
return true;
}
}
return false;
}",0
3459,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3460,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3461,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3462,"@Parameter
protected boolean ignorePermissions;",0
3463,"@Parameter
protected boolean useJvmChmod = true;",0
3464,"@Parameter
protected boolean useJvmChmod = true;",0
3465,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
3466,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
3467,"@Parameter
protected boolean ignorePermissions;",0
3468,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0
3469,"protected void doExecute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
// don't allow them to have absolute paths when they attach.
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
// make the string valid for filtering
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
project.getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
} else if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3470,"protected void doExecute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
project.getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
} else if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3471,"@Parameter
protected boolean useJvmChmod = true;",0
3472,"@Parameter
protected boolean useJvmChmod = true;",0
3473,"@Parameter
protected boolean useJvmChmod = true;",0
3474,"@Parameter
protected boolean useJvmChmod = true;",0
3475,"protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3476,"protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3477,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
3478,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
3479,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
3480,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3481,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3482,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3483,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3484,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3485,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3486,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3487,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3488,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3489,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3490,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3491,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3492,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
3493,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3494,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3495,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3496,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3497,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3498,"@Parameter
protected boolean useJvmChmod = true;",0
3499,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3500,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3501,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3502,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3503,"@Parameter
protected boolean useJvmChmod = true;",0
3504,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3505,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3506,"@Parameter
protected boolean useJvmChmod = true;",0
3507,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3508,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3509,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3510,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
3511,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
3512,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
3513,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3514,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3515,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3516,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3517,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3518,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3519,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
3520,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
3521,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3522,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3523,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3524,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3525,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3526,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3527,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3528,"@Parameter
protected boolean useJvmChmod = true;",0
3529,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3530,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3531,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}",0
3532,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3533,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3534,"@Parameter
protected boolean useJvmChmod = true;",0
3535,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3536,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3537,"@Parameter
protected boolean useJvmChmod = true;",0
3538,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3539,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3540,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3541,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
3542,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3543,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3544,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3545,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3546,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3547,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3548,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3549,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3550,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3551,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3552,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3553,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
3554,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3555,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3556,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3557,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3558,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3559,"@Parameter
protected boolean useJvmChmod = true;",0
3560,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3561,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3562,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3563,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3564,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3565,"@Parameter
protected boolean useJvmChmod = true;",0
3566,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3567,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3568,"@Parameter
protected boolean useJvmChmod = true;",0
3569,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3570,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3571,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
3572,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3573,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
3574,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
3575,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3576,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3577,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3578,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3579,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3580,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3581,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3582,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3583,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3584,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3585,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
3586,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3587,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3588,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3589,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3590,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3591,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3592,"@Parameter
protected boolean useJvmChmod = true;",0
3593,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3594,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3595,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3596,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3597,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3598,"@Parameter
protected boolean useJvmChmod = true;",0
3599,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3600,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3601,"@Parameter
protected boolean useJvmChmod = true;",0
3602,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3603,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3604,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3605,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
3606,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
3607,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
3608,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3609,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3610,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3611,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3612,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3613,protected List reactorProjects;,0
3614,public boolean silent;,0
3615,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3616,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3617,protected boolean outputAbsoluteArtifactFilename;,0
3618,protected MavenProject project;,0
3619,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3620,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3621,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3622,"public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}",0
3623,protected MavenProjectBuilder mavenProjectBuilder;,0
3624,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0
3625,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3626,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3627,"public Map getMismatch(Map depMgtMap, Set allDependencyArtifacts) {
Map mismatchMap = new HashMap();
Iterator iter = allDependencyArtifacts.iterator();
while (iter.hasNext()) {
Artifact dependencyArtifact = (Artifact) iter.next();
Dependency depFromDepMgt = (Dependency) depMgtMap.get(getArtifactManagementKey(dependencyArtifact));
if (depFromDepMgt != null) {
ArtifactVersion artifactVersion = new DefaultArtifactVersion(dependencyArtifact.getVersion());
dependencyArtifact.isSnapshot();
if (!depFromDepMgt.getVersion().equals(dependencyArtifact.getBaseVersion())) {
mismatchMap.put(dependencyArtifact, depFromDepMgt);
}
}
}
return mismatchMap;
}",0
3628,"private boolean checkDependencies() throws MojoExecutionException {
boolean result = false;
try {
ProjectDependencyAnalysis analysis = analyzer.analyze(project);
if (this.displayUsed) {
getLog().info(""Used declared dependencies:"");
logArtifacts(analysis.getUsedDeclaredArtifacts(), false);
}
getLog().info(""Used undeclared dependencies:"");
Set usedUndeclared = analysis.getUsedUndeclaredArtifacts();
logArtifacts(usedUndeclared, true);
getLog().info(""Unused declared dependencies:"");
Set unusedDeclared = analysis.getUnusedDeclaredArtifacts();
if (ignoreNonCompile) {
Iterator iter = unusedDeclared.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
if (!artifact.getScope().equals(Artifact.SCOPE_COMPILE)) {
iter.remove();
}
}
}
logArtifacts(unusedDeclared, false);
if (outputXML) {
writeDependencyXML(usedUndeclared);
}
if (scriptableOutput) {
writeScriptableOutput(usedUndeclared);
}
if ((usedUndeclared != null && !usedUndeclared.isEmpty()) || unusedDeclared != null && !unusedDeclared.isEmpty()) {
getLog().warn(""Potential problems discovered."");
result = true;
}
} catch (ProjectDependencyAnalyzerException exception) {
throw new MojoExecutionException(""Cannot analyze dependencies"", exception);
}
return result;
}",0
3629,"private boolean checkDependencies() throws MojoExecutionException {
boolean result = false;
try {
ProjectDependencyAnalysis analysis = analyzer.analyze(project);
if (this.displayUsed) {
getLog().info(""Used declared dependencies:"");
logArtifacts(analysis.getUsedDeclaredArtifacts(), false);
}
getLog().info(""Used undeclared dependencies:"");
Set usedUndeclared = analysis.getUsedUndeclaredArtifacts();
logArtifacts(usedUndeclared, true);
getLog().info(""Unused declared dependencies:"");
Set unusedDeclared = analysis.getUnusedDeclaredArtifacts();
if (ignoreNonCompile) {
Iterator iter = unusedDeclared.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
if (!artifact.getScope().equals(Artifact.SCOPE_COMPILE)) {
iter.remove();
}
}
}
logArtifacts(unusedDeclared, false);
if (outputXML) {
writeDependencyXML(usedUndeclared);
}
if (scriptableOutput) {
writeScriptableOutput(usedUndeclared);
}
if ((usedUndeclared != null && !usedUndeclared.isEmpty()) || unusedDeclared != null && !unusedDeclared.isEmpty()) {
getLog().warn(""Potential problems discovered."");
result = true;
}
} catch (ProjectDependencyAnalyzerException exception) {
throw new MojoExecutionException(""Cannot analyze dependencies"", exception);
}
return result;
}",0
3630,private ProjectDependencyAnalyzer analyzer;,0
3631,"private boolean checkDependencies() throws MojoExecutionException {
boolean result = false;
try {
ProjectDependencyAnalysis analysis = analyzer.analyze(project);
if (this.displayUsed) {
getLog().info(""Used declared dependencies:"");
logArtifacts(analysis.getUsedDeclaredArtifacts(), false);
}
getLog().info(""Used undeclared dependencies:"");
Set usedUndeclared = analysis.getUsedUndeclaredArtifacts();
logArtifacts(usedUndeclared, true);
getLog().info(""Unused declared dependencies:"");
Set unusedDeclared = analysis.getUnusedDeclaredArtifacts();
if (ignoreNonCompile) {
Iterator iter = unusedDeclared.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
if (!artifact.getScope().equals(Artifact.SCOPE_COMPILE)) {
iter.remove();
}
}
}
logArtifacts(unusedDeclared, false);
if (outputXML) {
writeDependencyXML(usedUndeclared);
}
if (scriptableOutput) {
writeScriptableOutput(usedUndeclared);
}
if ((usedUndeclared != null && !usedUndeclared.isEmpty()) || unusedDeclared != null && !unusedDeclared.isEmpty()) {
getLog().warn(""Potential problems discovered."");
result = true;
}
} catch (ProjectDependencyAnalyzerException exception) {
throw new MojoExecutionException(""Cannot analyze dependencies"", exception);
}
return result;
}",0
3632,"public void execute() throws MojoExecutionException, MojoFailureException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
boolean result = checkDependencies();
if (result && this.failBuild) {
throw new MojoExecutionException(""Found Dependency errors."");
}
AnalyzeDepMgt adm = new AnalyzeDepMgt();
adm.setLog(getLog());
adm.setProject(this.project);
adm.setFailBuild(this.failBuild);
adm.setPluginContext(this.getPluginContext());
adm.setIgnoreDirect(this.ignoreDirect);
adm.execute();
}",0
3633,private MavenProject project;,0
3634,"private String readClasspathFile() throws IOException {
if (!cpFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(cpFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0
3635,"public void execute() throws MojoExecutionException {
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(File.pathSeparatorChar);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (cpFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString);
} else {
this.getLog().info(""Skipped writting classpath file '"" + cpFile + ""'.  No changes found."");
}
}
}",0
3636,"private void storeClasspathFile(String cpString) throws MojoExecutionException {
try {
Writer w = new BufferedWriter(new FileWriter(cpFile));
try {
w.write(cpString);
getLog().info(""Written classpath file '"" + cpFile + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + cpFile + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + cpFile + ""': "" + ex.toString(), ex);
}
}",0
3637,private String prefix;,0
3638,private File cpFile;,0
3639,"private String readClasspathFile() throws IOException {
if (!cpFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(cpFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0
3640,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + cpFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
3641,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3642,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3643,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3644,private boolean regenerateFile;,0
3645,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3646,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
3647,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3648,"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}",0
3649,"private Map createManagedVersionMap(ArtifactFactory artifactFactory, String projectId, DependencyManagement dependencyManagement) throws MojoExecutionException {
Map map;
if (dependencyManagement != null && dependencyManagement.getDependencies() != null) {
map = new HashMap();
for (Iterator i = dependencyManagement.getDependencies().iterator(); i.hasNext(); ) {
Dependency d = (Dependency) i.next();
try {
VersionRange versionRange = VersionRange.createFromVersionSpec(d.getVersion());
Artifact artifact = artifactFactory.createDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());
map.put(d.getManagementKey(), artifact);
} catch (InvalidVersionSpecificationException e) {
throw new MojoExecutionException(""Unable to parse version"", e);
}
}
} else {
map = Collections.EMPTY_MAP;
}
return map;
}",0
3650,protected boolean outputScope;,0
3651,private boolean excludeTransitive;,0
3652,private List remotePluginRepositories;,0
3653,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3654,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3655,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3656,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3657,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3658,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
3659,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3660,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
3661,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
3662,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3663,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3664,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3665,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3666,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3667,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3668,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3669,"@Parameter
protected boolean useJvmChmod = true;",0
3670,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3671,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3672,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3673,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}",0
3674,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}",0
3675,"@Parameter
protected boolean useJvmChmod = true;",0
3676,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3677,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3678,"@Parameter
protected boolean useJvmChmod = true;",0
3679,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3680,"@Override
protected void doExecute() throws MojoExecutionException {
results = this.getDependencySets(false, includeParents);
String output = getOutput(outputAbsoluteArtifactFilename, outputScope, sort);
try {
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
} catch (IOException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3681,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3682,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
3683,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3684,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3685,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3686,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3687,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3688,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3689,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3690,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3691,public boolean silent;,0
3692,protected List reactorProjects;,0
3693,protected List reactorProjects;,0
3694,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3695,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3696,protected MavenProject project;,0
3697,protected boolean outputAbsoluteArtifactFilename;,0
3698,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0
3699,protected MavenProjectBuilder mavenProjectBuilder;,0
3700,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3701,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3702,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
3703,"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}",0
3704,private String groupId;,0
3705,private boolean excludeTransitive;,0
3706,private List remotePluginRepositories;,0
3707,private boolean excludeTransitive;,0
3708,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3709,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3710,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3711,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3712,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3713,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
3714,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3715,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3716,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3717,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3718,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3719,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3720,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
3721,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3722,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3723,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3724,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3725,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3726,"@Parameter
protected boolean useJvmChmod = true;",0
3727,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3728,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3729,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3730,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3731,"@Parameter
protected boolean useJvmChmod = true;",0
3732,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3733,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3734,"@Parameter
protected boolean useJvmChmod = true;",0
3735,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3736,"@Override
protected void doExecute() throws MojoExecutionException {
results = this.getDependencySets(false, includeParents);
String output = getOutput(outputAbsoluteArtifactFilename, outputScope, sort);
try {
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
} catch (IOException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3737,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3738,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
3739,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
3740,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
3741,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3742,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3743,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3744,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3745,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3746,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3747,protected MavenProject project;,0
3748,public boolean silent;,0
3749,protected boolean outputAbsoluteArtifactFilename;,0
3750,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3751,protected List<MavenProject> reactorProjects;,0
3752,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3753,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3754,"public void setUseSubDirectoryPerScope(boolean theUseSubDirectoryPerScope) {
this.useSubDirectoryPerScope = theUseSubDirectoryPerScope;
}",0
3755,"protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.getLocal());
return resolveDependencyArtifacts(pomProject);
}",0
3756,protected boolean appendOutput;,0
3757,protected MavenProjectBuilder mavenProjectBuilder;,0
3758,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3759,private MavenProject project;,0
3760,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
Reader reader = null;
try {
reader = ReaderFactory.newXmlReader(project.getFile());
model = pomReader.read(reader);
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
} finally {
IOUtil.close(reader);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0
3761,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
3762,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3763,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0
3764,private MavenProjectHelper projectHelper;,0
3765,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
3766,private File cpFile;,0
3767,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
3768,boolean outputFilterFile;,0
3769,boolean outputFilterFile;,0
3770,boolean attach;,0
3771,"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0
3772,"private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}",0
3773,"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0
3774,"private void installArtifact(Artifact artifact, ArtifactRepository targetRepository) {
try {
if (""pom"".equals(artifact.getType())) {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
} else {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
if (isCopyPom()) {
Artifact pomArtifact = getResolvedPomArtifact(artifact);
if (pomArtifact.getFile() != null && pomArtifact.getFile().exists()) {
installer.install(pomArtifact.getFile(), pomArtifact, targetRepository);
installBaseSnapshot(pomArtifact, targetRepository);
}
}
}
} catch (ArtifactInstallationException e) {
getLog().info(e.getMessage());
}
}",0
3775,"private Map<String, ArtifactRepositoryLayout> repositoryLayouts;",0
3776,protected ArtifactInstaller installer;,0
3777,protected ArtifactRepositoryFactory repositoryFactory;,0
3778,"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0
3779,protected MavenProject project;,0
3780,"public void execute() throws MojoExecutionException {
@SuppressWarnings(""unchecked"")
Set<Artifact> artifacts = getProject().getArtifacts();
for (Artifact artifact : artifacts) {
project.getProperties().setProperty(artifact.getDependencyConflictId(), artifact.getFile().getAbsolutePath());
}
}",0
3781,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
3782,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3783,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3784,"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3785,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
3786,protected List<MavenProject> reactorProjects;,0
3787,protected List<MavenProject> reactorProjects;,0
3788,"protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
ArtifactRepository local = super.getLocal();
if (this.localRepositoryDirectory != null) {
String url = ""file://"" + this.localRepositoryDirectory.getAbsolutePath();
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(local.getId(), url, local.getLayout(), local.getSnapshots(), local.getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
} else {
this.overrideLocalRepository = local;
}
return this.overrideLocalRepository;
}",0
3789,"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3790,private ArtifactRepositoryFactory artifactRepositoryManager;,0
3791,protected boolean outputScope;,0
3792,private boolean excludeTransitive;,0
3793,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3794,private List<ArtifactRepository> remotePluginRepositories;,0
3795,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3796,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
3797,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
3798,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3799,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3800,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3801,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3802,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3803,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3804,"public Set<Artifact> translate(Set<Artifact> artifacts, Log log) {
Set<Artifact> results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet<Artifact>();
for (Artifact artifact : artifacts) {
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
3805,"public AbstractDependencyMojo() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
}",0
3806,protected List reactorProjects;,0
3807,protected boolean useSubDirectoryPerArtifact;,0
3808,protected MavenProjectBuilder mavenProjectBuilder;,0
3809,protected File outputDirectory;,0
3810,protected boolean overWriteReleases;,0
3811,protected boolean overWriteSnapshots;,0
3812,"protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}",0
3813,"protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}",0
3814,private ArrayList artifactItems;,0
3815,private File markersDirectory;,0
3816,private File markersDirectory;,0
3817,private boolean excludeTransitive;,0
3818,private String groupId;,0
3819,private List remotePluginRepositories;,0
3820,private boolean excludeTransitive;,0
3821,"private static void logResults(Set resolvedArtifacts, Set missingArtifacts, HashSet existingArtifacts, boolean silent, Log log) {
if (!silent) {
log.info("""");
log.info(""The following files have been resolved: "");
if (resolvedArtifacts.isEmpty()) {
log.info(""   none"");
} else {
for (Iterator i = resolvedArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
if (existingArtifacts != null && !existingArtifacts.isEmpty()) {
log.info("""");
log.info(""The following files where skipped: "");
for (Iterator i = existingArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
log.info("""");
log.info(""The following files have NOT been resolved: "");
if (missingArtifacts.isEmpty()) {
log.info(""   none"");
} else {
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
log.info("""");
}
}",0
3822,"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0
3823,"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0
3824,"private void log(Set artifacts, Log log) {
log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
log.debug("""" + artifact);
}
}",0
3825,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3826,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3827,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3828,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3829,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3830,private ArtifactFactory factory;,0
3831,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}",0
3832,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}",0
3833,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3834,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3835,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3836,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3837,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3838,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3839,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
3840,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3841,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3842,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3843,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3844,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3845,"@Parameter
protected boolean useJvmChmod = true;",0
3846,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3847,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3848,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3849,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3850,"@Parameter
protected boolean useJvmChmod = true;",0
3851,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3852,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3853,"@Parameter
protected boolean useJvmChmod = true;",0
3854,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3855,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3856,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
3857,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
3858,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3859,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3860,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3861,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3862,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3863,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3864,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
3865,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3866,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3867,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3868,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3869,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
3870,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3871,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3872,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3873,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3874,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3875,"@Parameter
protected boolean useJvmChmod = true;",0
3876,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3877,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3878,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3879,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3880,"@Parameter
protected boolean useJvmChmod = true;",0
3881,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3882,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3883,"@Parameter
protected boolean useJvmChmod = true;",0
3884,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3885,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3886,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3887,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
3888,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
3889,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
3890,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3891,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3892,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3893,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3894,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3895,protected List reactorProjects;,0
3896,protected MavenProject project;,0
3897,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3898,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
getLog().info(""Unpacking "" + file.getPath() + ""to\n "" + location.getPath() + ""\nwith Includes "" + includes + "" and excludes:"" + excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3899,public boolean silent;,0
3900,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3901,protected boolean outputAbsoluteArtifactFilename;,0
3902,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0
3903,protected MavenProjectBuilder mavenProjectBuilder;,0
3904,protected File outputFile;,0
3905,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3906,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3907,private ProjectDependencyAnalyzer analyzer;,0
3908,"public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}",0
3909,"protected String getOutputDirectory() {
getLog().info(outputDirectory.toString());
return outputDirectory.toString();
}",0
3910,private Renderer siteRenderer;,0
3911,"public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}",0
3912,private File outputDirectory;,0
3913,private MavenProject project;,0
3914,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3915,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3916,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
if (StringUtils.isEmpty(fileSeparator)) {
isFileSepSet = false;
} else {
isFileSepSet = true;
}
if (StringUtils.isEmpty(pathSeparator)) {
isPathSepSet = false;
} else {
isPathSepSet = true;
}
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
String separator = File.separator;
if (File.separator.equals(""\\"")) {
separator = ""\\\\"";
}
cpString = cpString.replaceAll(separator, fileSeparator);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3917,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
3918,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3919,private MavenProjectHelper projectHelper;,0
3920,private File cpFile;,0
3921,boolean attach;,0
3922,boolean outputFilterFile;,0
3923,"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0
3924,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
3925,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(outputFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0
3926,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
3927,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3928,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
3929,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3930,"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3931,protected boolean outputScope;,0
3932,private boolean excludeTransitive;,0
3933,private List remotePluginRepositories;,0
3934,"public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}",0
3935,"public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}",0
3936,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3937,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3938,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3939,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3940,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3941,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
3942,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3943,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3944,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
3945,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0
3946,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3947,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
3948,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
3949,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3950,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3951,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3952,"@Parameter
protected boolean useJvmChmod = true;",0
3953,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3954,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3955,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3956,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}",0
3957,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}",0
3958,"@Parameter
protected boolean useJvmChmod = true;",0
3959,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
3960,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
3961,"@Parameter
protected boolean useJvmChmod = true;",0
3962,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
3963,"private StringBuilder buildArtifactListOutput(Set<Artifact> artifacts, boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
List<String> artifactStringList = new ArrayList<>();
for (Artifact artifact : artifacts) {
MessageBuilder messageBuilder = MessageUtils.buffer();
messageBuilder.a(""   "");
if (theOutputScope) {
messageBuilder.a(artifact.toString());
} else {
messageBuilder.a(artifact.getId());
}
if (outputAbsoluteArtifactFilename) {
try {
String artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
messageBuilder.a(':').a(artifactFilename);
} catch (NullPointerException e) {
}
}
if (theOutputScope && artifact.isOptional()) {
messageBuilder.a("" (optional)"");
}
if (artifact.getFile() != null) {
ModuleDescriptor moduleDescriptor = getModuleDescriptor(artifact.getFile());
if (moduleDescriptor != null) {
messageBuilder.project("" -- module "" + moduleDescriptor.name);
if (moduleDescriptor.automatic) {
if (""MANIFEST"".equals(moduleDescriptor.moduleNameSource)) {
messageBuilder.strong("" [auto]"");
} else {
messageBuilder.warning("" (auto)"");
}
}
}
}
artifactStringList.add(messageBuilder + System.lineSeparator());
}
if (theSort) {
Collections.sort(artifactStringList);
}
for (String artifactString : artifactStringList) {
sb.append(artifactString);
}
return sb;
}",0
3964,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
3965,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
3966,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
3967,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3968,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3969,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3970,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3971,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
3972,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3973,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3974,"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setUseJvmChmod(useJvmChmod);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
3975,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
3976,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0
3977,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0
3978,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
3979,"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
3980,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
3981,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
3982,"private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3983,"private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3984,"private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
3985,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
3986,"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
3987,"@Parameter(defaultValue = ""${reactorProjects}"", readonly = true, required = true)
protected List<MavenProject> reactorProjects;",0
3988,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3989,"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
3990,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
3991,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3992,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3993,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
3994,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3995,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3996,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
3997,"public Set<Artifact> translate(Set<Artifact> artifacts, Log log) {
Set<Artifact> results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet<Artifact>();
for (Artifact artifact : artifacts) {
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
3998,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
3999,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
4000,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
4001,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
4002,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
4003,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
4004,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
4005,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
4006,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
4007,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
4008,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4009,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4010,"@Parameter
protected boolean useJvmChmod = true;",0
4011,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4012,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4013,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
4014,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
4015,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
4016,"@Parameter
protected boolean useJvmChmod = true;",0
4017,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4018,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4019,"@Parameter
protected boolean useJvmChmod = true;",0
4020,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
4021,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
4022,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
4023,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
4024,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
4025,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
4026,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
4027,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4028,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4029,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4030,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4031,protected List reactorProjects;,0
4032,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
4033,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
4034,protected boolean outputAbsoluteArtifactFilename;,0
4035,public boolean silent;,0
4036,public boolean silent;,0
4037,protected MavenProject project;,0
4038,protected MavenProject project;,0
4039,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
4040,"public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}",0
4041,"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0
4042,protected MavenProjectBuilder mavenProjectBuilder;,0
4043,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
4044,"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
4045,"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0
4046,"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}",0
4047,private String groupId;,0
4048,private boolean excludeTransitive;,0
4049,private List remotePluginRepositories;,0
4050,private boolean excludeTransitive;,0
4051,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4052,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4053,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4054,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4055,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4056,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
4057,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
4058,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
4059,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
4060,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
4061,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
4062,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
4063,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
4064,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
4065,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
4066,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
4067,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4068,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4069,"@Parameter
protected boolean useJvmChmod = true;",0
4070,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4071,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4072,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try (Writer w = new BufferedWriter(new FileWriter(out))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
4073,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try (Writer w = new BufferedWriter(new FileWriter(out))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
4074,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
4075,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter "" + ""cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
try (BufferedReader r = new BufferedReader(new FileReader(outputFile))) {
for (String line = r.readLine(); line != null; line = r.readLine()) {
sb.append(line);
}
return sb.toString();
}
}",0
4076,"@Parameter
protected boolean useJvmChmod = true;",0
4077,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4078,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4079,"@Parameter
protected boolean useJvmChmod = true;",0
4080,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
4081,"private StringBuilder buildArtifactListOutput(Set<Artifact> artifacts, boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
List<String> artifactStringList = new ArrayList<>();
for (Artifact artifact : artifacts) {
MessageBuilder messageBuilder = MessageUtils.buffer();
messageBuilder.a(""   "");
if (theOutputScope) {
messageBuilder.a(artifact.toString());
} else {
messageBuilder.a(artifact.getId());
}
if (outputAbsoluteArtifactFilename) {
try {
String artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
messageBuilder.a(':').a(artifactFilename);
} catch (NullPointerException e) {
}
}
if (theOutputScope && artifact.isOptional()) {
messageBuilder.a("" (optional)"");
}
if (artifact.getFile() != null) {
ModuleDescriptor moduleDescriptor = getModuleDescriptor(artifact.getFile());
if (moduleDescriptor != null) {
messageBuilder.project("" -- module "" + moduleDescriptor.name);
if (moduleDescriptor.automatic) {
if (""MANIFEST"".equals(moduleDescriptor.moduleNameSource)) {
messageBuilder.strong("" [auto]"");
} else {
messageBuilder.warning("" (auto)"");
}
}
}
}
artifactStringList.add(messageBuilder.toString() + System.lineSeparator());
}
if (theSort) {
Collections.sort(artifactStringList);
}
for (String artifactString : artifactStringList) {
sb.append(artifactString);
}
return sb;
}",0
4082,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
4083,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
DependencyUtil.write(output, outputFile, appendOutput, getLog());
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
4084,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
try (FileWriter writer = new FileWriter(file, append)) {
writer.write(string);
}
}",0
4085,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
try (FileWriter writer = new FileWriter(file, append)) {
writer.write(string);
}
}",0
4086,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4087,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4088,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4089,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4090,"protected void unpack(Artifact artifact, File location, String includes, String excludes) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(artifact.getType());
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
unArchiver.setUseJvmChmod(useJvmChmod);
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
4091,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
4092,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
4093,"private void reResolveArtifacts(MavenProject project, Set<Artifact> artifacts, ArtifactFilter filter) throws ArtifactResolutionException, ArtifactNotFoundException {
for (Artifact artifact : artifacts) {
try {
Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), null, ""pom"");
resolver.resolveAlways(pomArtifact, remoteRepositories, localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
}
}
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Artifact artifact : artifacts) {
verbose(""Resolving artifact: "" + artifact.getId());
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
4094,"private void reResolveArtifacts(MavenProject project, Set<Artifact> artifacts, ArtifactFilter filter) throws ArtifactResolutionException, ArtifactNotFoundException {
for (Artifact artifact : artifacts) {
try {
Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), null, ""pom"");
resolver.resolveAlways(pomArtifact, remoteRepositories, localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
}
}
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Artifact artifact : artifacts) {
verbose(""Resolving artifact: "" + artifact.getId());
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0
4095,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
4096,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0
4097,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
4098,"@Parameter
protected boolean useJvmChmod = true;",0
4099,"@Parameter
protected boolean ignorePermissions;",0
4100,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
4101,"@Parameter
protected boolean useJvmChmod = true;",0
4102,"@Parameter
protected boolean useJvmChmod = true;",0
4103,"protected void doExecute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
project.getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
} else if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
4104,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
4105,"@Parameter
protected boolean useJvmChmod = true;",0
4106,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
4107,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0
4108,"@Parameter
protected boolean useJvmChmod = true;",0
4109,"@Parameter
protected boolean ignorePermissions;",0
4110,"@Parameter
protected boolean useJvmChmod = true;",0
4111,"@Parameter
protected boolean useJvmChmod = true;",0
4112,"protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
4113,"protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0
4114,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
4115,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
4116,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0
4117,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4118,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4119,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4120,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4121,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4122,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4123,protected List reactorProjects;,0
4124,"public AbstractDependencyMojo() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
}",0
4125,protected File outputDirectory;,0
4126,protected MavenProjectBuilder mavenProjectBuilder;,0
4127,private ArrayList artifactItems;,0
4128,protected boolean overWriteReleases;,0
4129,protected File outputDirectory;,0
4130,protected boolean overWriteSnapshots;,0
4131,"protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}",0
4132,"protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}",0
4133,private File markersDirectory;,0
4134,private boolean useMarkers;,0
4135,private String groupId;,0
4136,private boolean excludeTransitive;,0
4137,private boolean excludeTransitive;,0
4138,private List remotePluginRepositories;,0
4139,"private static void logResults(Set resolvedArtifacts, Set missingArtifacts, HashSet existingArtifacts, boolean silent, Log log) {
if (!silent) {
log.info("""");
log.info(""The following files have been resolved: "");
if (resolvedArtifacts.isEmpty()) {
log.info(""   none"");
} else {
for (Iterator i = resolvedArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
if (existingArtifacts != null && !existingArtifacts.isEmpty()) {
log.info("""");
log.info(""The following files where skipped: "");
for (Iterator i = existingArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
log.info("""");
log.info(""The following files have NOT been resolved: "");
if (missingArtifacts.isEmpty()) {
log.info(""   none"");
} else {
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
log.info("""");
}
}",0
4140,"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0
4141,"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0
4142,"private void log(Set artifacts, Log log) {
log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
log.debug("""" + artifact);
}
}",0
4143,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4144,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4145,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4146,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4147,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4148,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}",0
4149,private ArtifactFactory factory;,0
4150,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}",0
4151,"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers, boolean overwrite) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.setOverwrite(overwrite);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0
4152,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
4153,"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0
4154,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
4155,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0
4156,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
4157,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
4158,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0
4159,"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0
4160,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4161,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4162,"@Parameter
protected boolean useJvmChmod = true;",0
4163,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4164,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4165,"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0
4166,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
4167,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
4168,"@Parameter
protected boolean useJvmChmod = true;",0
4169,"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0
4170,"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0
4171,"@Parameter
protected boolean useJvmChmod = true;",0
4172,"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0
4173,"private StringBuilder buildArtifactListOutput(Set<Artifact> artifacts, boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
List<String> artifactStringList = new ArrayList<>();
for (Artifact artifact : artifacts) {
MessageBuilder messageBuilder = MessageUtils.buffer();
messageBuilder.a(""   "");
if (theOutputScope) {
messageBuilder.a(artifact.toString());
} else {
messageBuilder.a(artifact.getId());
}
if (outputAbsoluteArtifactFilename) {
try {
String artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
messageBuilder.a(':').a(artifactFilename);
} catch (NullPointerException e) {
}
}
if (theOutputScope && artifact.isOptional()) {
messageBuilder.a("" (optional)"");
}
if (artifact.getFile() != null) {
ModuleDescriptor moduleDescriptor = getModuleDescriptor(artifact.getFile());
if (moduleDescriptor != null) {
messageBuilder.project("" -- module "" + moduleDescriptor.name);
if (moduleDescriptor.automatic) {
if (""MANIFEST"".equals(moduleDescriptor.moduleNameSource)) {
messageBuilder.strong("" [auto]"");
} else {
messageBuilder.warning("" (auto)"");
}
}
}
}
artifactStringList.add(messageBuilder.toString() + System.lineSeparator());
}
if (theSort) {
Collections.sort(artifactStringList);
}
for (String artifactString : artifactStringList) {
sb.append(artifactString);
}
return sb;
}",0
4174,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
4175,"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0
4176,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
4177,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
4178,"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0
4179,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4180,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0
4181,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4182,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4183,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",1
4184,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
4185,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0
4186,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
try (FileWriter writer = new FileWriter(file, append)) {
writer.write(string);
}
}",1
4187,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0
4188,"public void execute() throws MojoExecutionException, MojoFailureException {
if (artifactId == null && artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifactId == null) {
String[] tokens = StringUtils.split(artifact, "":"");
if (tokens.length < 3 && tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify groupId:artifactId:version[:packaging][:classifier] "" + artifact);
}
groupId = tokens[0];
artifactId = tokens[1];
version = tokens[2];
if (tokens.length >= 4) {
packaging = tokens[3];
}
if (tokens.length == 5) {
classifier = tokens[4];
} else {
classifier = null;
}
}
Artifact toDownload = classifier == null ? artifactFactory.createBuildArtifact(groupId, artifactId, version, packaging) : artifactFactory.createArtifactWithClassifier(groupId, artifactId, version, packaging, classifier);
Artifact dummyOriginatingArtifact = artifactFactory.createBuildArtifact(""org.apache.maven.plugins"", ""maven-downloader-plugin"", ""1.0"", ""jar"");
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
ArtifactRepository remoteRepo = artifactRepositoryFactory.createArtifactRepository(repositoryId, repositoryUrl, repositoryLayout, always, always);
if (pomRemoteRepositories == null) {
pomRemoteRepositories = new ArrayList();
}
List repoList = new ArrayList(pomRemoteRepositories);
if (remoteRepositories != null) {
// TODO: remote repositories as Strings?
repoList.addAll(Arrays.asList(StringUtils.split(remoteRepositories, "","")));
}
repoList.add(remoteRepo);
try {
if (transitive) {
artifactResolver.resolveTransitively(Collections.singleton(toDownload), dummyOriginatingArtifact, repoList, localRepository, source);
} else {
artifactResolver.resolve(toDownload, repoList, localRepository);
}
} catch (AbstractArtifactResolutionException e) {
throw new MojoExecutionException(""Couldn't download artifact: "" + e.getMessage(), e);
}
}",1
4189,"@Parameter(defaultValue = ""${reactorProjects}"", readonly = true, required = true)
protected List<MavenProject> reactorProjects;",1
4190,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",1
4191,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter "" + ""cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
try (BufferedReader r = new BufferedReader(new FileReader(outputFile))) {
for (String line = r.readLine(); line != null; line = r.readLine()) {
sb.append(line);
}
return sb.toString();
}
}",1
4192,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",1
4193,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
if (!manager.getScope().equals(node.getDependency().getScope())) {
artifactProperties.put(PRE_MANAGED_SCOPE, node.getDependency().getScope());
artifactProperties.put(MANAGED_SCOPE, manager.getScope());
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
node.getDependency().setArtifact(node.getDependency().getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
4194,"public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}",0
4195,"public Set<Artifact> translate(Set<Artifact> artifacts, Log log) {
Set<Artifact> results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet<Artifact>();
for (Artifact artifact : artifacts) {
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",1
4196,"private void fillMissingArtifactVersion(ArtifactItem artifact) throws MojoExecutionException {
if (!findDependencyVersion(artifact, project.getDependencies(), false) && (project.getDependencyManagement() == null || !findDependencyVersion(artifact, project.getDependencyManagement().getDependencies(), false)) && !findDependencyVersion(artifact, project.getDependencies(), true) && (project.getDependencyManagement() == null || !findDependencyVersion(artifact, project.getDependencyManagement().getDependencies(), true))) {
throw new MojoExecutionException(""Unable to find artifact version of "" + artifact.getGroupId() + "":"" + artifact.getArtifactId() + "" in either dependency list or in project's dependency management."");
}
}",0
4197,"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0
4198,"public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}",0
4199,"@Parameter(property = ""mdep.prependGroupId"", defaultValue = ""false"")
private final boolean prependGroupId = false;",0
4200,protected boolean appendOutput;,0
4201,"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",1
4202,"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0
4203,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter "" + ""cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
for (String line = r.readLine(); line != null; line = r.readLine()) {
sb.append(line);
}
r.close();
r = null;
return sb.toString();
} finally {
IOUtil.close(r);
}
}",1
4204,private String includes;,0
4205,"protected Set resolvePluginArtifacts() throws ArtifactResolutionException, ArtifactNotFoundException {
Set plugins = project.getPluginArtifacts();
Set reports = project.getReportArtifacts();
Set artifacts = new HashSet();
artifacts.addAll(reports);
artifacts.addAll(plugins);
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
this.resolver.resolve(artifact, this.remotePluginRepositories, this.getLocal());
}
return artifacts;
}",0
4206,"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0
4207,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getPluginArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
4208,"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",1
4209,"protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
if (this.localRepositoryDirectory != null) {
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(super.getLocal().getId(), ""file://"" + this.localRepositoryDirectory.getAbsolutePath(), super.getLocal().getLayout(), super.getLocal().getSnapshots(), super.getLocal().getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
return this.overrideLocalRepository;
}
this.overrideLocalRepository = super.getLocal();
return this.overrideLocalRepository;
}",0
4210,private List remotePluginRepositories;,1
4211,"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",1
4212,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
4213,"@Parameter(property = ""mdep.useBaseVersion"", defaultValue = ""true"")
private final boolean useBaseVersion = true;",0
4214,private MavenProject project;,0
4215,"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",1
4216,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0
4217,private File markersDirectory;,0
4218,"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0
4219,"public void execute() throws MojoExecutionException {
try {
ArtifactResolutionResult result = this.artifactCollector.collect(project.getArtifacts(), project.getArtifact(), this.getLocal(), this.remoteRepos, this.artifactMetadataSource, new ScopeArtifactFilter(Artifact.SCOPE_TEST), new ArrayList());
HashSet repos = new HashSet();
for (Iterator<ResolutionNode> i = result.getArtifactResolutionNodes().iterator(); i.hasNext(); ) {
ResolutionNode node = i.next();
repos.addAll(node.getRemoteRepositories());
}
this.getLog().info(""Repositories Used by this build:"");
for (Iterator i = repos.iterator(); i.hasNext(); ) {
this.getLog().info(i.next().toString());
}
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Unable to resolve artifacts"", e);
}
}",0
4220,"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
if (!manager.getScope().equals(node.getDependency().getScope())) {
artifactProperties.put(PRE_MANAGED_SCOPE, node.getDependency().getScope());
artifactProperties.put(MANAGED_SCOPE, manager.getScope());
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
node.getDependency().setArtifact(node.getDependency().getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0
4221,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
writer.close();
writer = null;
} finally {
IOUtil.close(writer);
}
}",0
4222,"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
writer.close();
writer = null;
} finally {
IOUtil.close(writer);
}
}",0
4223,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try (Writer w = new BufferedWriter(new FileWriter(out))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",1
4224,private MavenProject project;,1
4225,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
4226,"@Parameter(property = ""mdep.stripClassifier"", defaultValue = ""false"")
private final boolean stripClassifier = false;",0
4227,"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(outputFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0
4228,"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}",0
4229,"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0
4230,private ArtifactFactory factory;,0
4231,"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",1
4232,"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
w.close();
w = null;
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0
4233,private boolean excludeTransitive;,1
4234,protected boolean useSubDirectoryPerType;,0
4235,"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0
4236,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
4237,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4238,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4239,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4240,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4241,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
4242,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4243,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
4244,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4245,"@Deprecated
public static String PROVIDER;",0
4246,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
4247,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4248,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4249,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4250,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4251,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4252,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4253,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4254,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4255,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4256,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4257,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4258,"public IOException getIOException() {
return (IOException) getCause();
}",0
4259,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4260,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4261,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4262,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
4263,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4264,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4265,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4266,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4267,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4268,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4269,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4270,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4271,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4272,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4273,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4274,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4275,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4276,public String identifier;,0
4277,public int size;,0
4278,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4279,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4280,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4281,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4282,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4283,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4284,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4285,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4286,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4287,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4288,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4289,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4290,"public int[] startSubnegotiationRemote() {
return null;
}",0
4291,"public int[] startSubnegotiationLocal() {
return null;
}",0
4292,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4293,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
4294,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4295,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4296,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4297,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4298,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4299,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4300,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4301,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
4302,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4303,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4304,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
4305,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4306,"public InputStream getInputStream(boolean longOutput, String username, String encoding) throws IOException {
DataOutputStream output;
StringBuilder buffer = new StringBuilder(64);
if (longOutput) {
buffer.append(__LONG_FLAG);
}
buffer.append(username);
buffer.append(SocketClient.NETASCII_EOL);
byte[] encodedQuery = (encoding == null ? buffer.toString().getBytes() : buffer.toString().getBytes(encoding));
output = new DataOutputStream(new BufferedOutputStream(_output_, 1024));
output.write(encodedQuery, 0, encodedQuery.length);
output.flush();
return _input_;
}",0
4307,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4308,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0
4309,"public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, method.getAuthName()))) {
return false;
}
switch(method) {
case PLAIN:
{
int result = sendData(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case CRAM_MD5:
{
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
int result = sendData(new String(Base64.encodeBase64(toEncode)));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case LOGIN:
{
if (sendData(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT) {
return false;
}
int result = sendData(new String(Base64.encodeBase64(password.getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
}
return false;
}",0
4310,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4311,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4312,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4313,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4314,"public boolean auth(AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (sendCommand(POP3Command.AUTH, method.getAuthName()) != POP3Reply.OK_INT) {
return false;
}
switch(method) {
case PLAIN:
return sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))) == POP3Reply.OK;
case CRAM_MD5:
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return sendCommand(new String(Base64.encodeBase64(toEncode))) == POP3Reply.OK;
default:
return false;
}
}",0
4315,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4316,"public boolean login(String username, String timestamp, String secret) throws IOException, NoSuchAlgorithmException {
int i;
byte[] digest;
StringBuilder buffer, digestBuffer;
MessageDigest md5;
if (getState() != AUTHORIZATION_STATE) {
return false;
}
md5 = MessageDigest.getInstance(""MD5"");
timestamp += secret;
digest = md5.digest(timestamp.getBytes());
digestBuffer = new StringBuilder(128);
for (i = 0; i < digest.length; i++) {
int digit = digest[i] & 0xff;
if (digit <= 15) {
digestBuffer.append(""0"");
}
digestBuffer.append(Integer.toHexString(digit));
}
buffer = new StringBuilder(256);
buffer.append(username);
buffer.append(' ');
buffer.append(digestBuffer.toString());
if (sendCommand(POP3Command.APOP, buffer.toString()) != POP3Reply.OK) {
return false;
}
setState(TRANSACTION_STATE);
return true;
}",0
4317,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4318,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4319,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4320,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4321,"final synchronized void _sendTerminalType() throws IOException {
if (debug) {
System.err.println(""SEND TERMINAL-TYPE: "" + terminalType);
}
if (terminalType != null) {
_output_.write(_COMMAND_SB);
_output_.write(_COMMAND_IS);
_output_.write(terminalType.getBytes());
_output_.write(_COMMAND_SE);
_output_.flush();
}
}",0
4322,"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4323,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4324,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
4325,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4326,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
4327,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4328,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4329,"public Object encode(Object pObject) {
if (!(pObject instanceof byte[])) {
throw new RuntimeException(""Parameter supplied to Base64 encode is not a byte[]"");
}
return encode((byte[]) pObject);
}",0
4330,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4331,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4332,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
4333,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4334,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4335,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4336,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4337,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4338,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
4339,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4340,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
4341,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
4342,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4343,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4344,"@Deprecated
public static String KEYSTORE_ALGORITHM;",0
4345,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4346,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4347,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4348,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4349,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4350,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4351,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4352,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4353,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4354,"public IOException getIOException() {
return (IOException) getCause();
}",0
4355,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4356,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4357,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4358,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4359,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4360,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
4361,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4362,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4363,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4364,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4365,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4366,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4367,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4368,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4369,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4370,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4371,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4372,public String identifier;,0
4373,public int size;,0
4374,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4375,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4376,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4377,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4378,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4379,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4380,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4381,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4382,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4383,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4384,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4385,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4386,"public int[] startSubnegotiationRemote() {
return null;
}",0
4387,"public int[] startSubnegotiationLocal() {
return null;
}",0
4388,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4389,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
4390,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4391,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4392,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4393,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4394,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4395,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4396,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
4397,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4398,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4399,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4400,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
4401,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
4402,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4403,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4404,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4405,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4406,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
4407,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
4408,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4409,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4410,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",0
4411,"@Deprecated
public static String PROVIDER;",0
4412,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4413,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
4414,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4415,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4416,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4417,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4418,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4419,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4420,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4421,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4422,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4423,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0
4424,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4425,"public IOException getIOException() {
return (IOException) getCause();
}",0
4426,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4427,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4428,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4429,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
4430,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4431,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4432,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4433,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4434,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4435,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4436,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
bogusIdCount++;
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4437,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4438,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4439,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4440,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4441,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4442,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0
4443,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4444,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0
4445,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4446,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4447,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4448,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4449,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4450,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4451,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4452,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4453,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4454,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4455,"public int[] startSubnegotiationRemote() {
return null;
}",0
4456,"public int[] startSubnegotiationLocal() {
return null;
}",0
4457,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4458,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4459,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4460,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4461,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4462,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4463,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
4464,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4465,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4466,"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4467,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4468,"public static boolean enableEndpointNameVerification(SSLSocket socket) {
try {
Class<?> cls = Class.forName(""javax.net.ssl.SSLParameters"");
Method setEndpointIdentificationAlgorithm = cls.getDeclaredMethod(""setEndpointIdentificationAlgorithm"", String.class);
Method getSSLParameters = SSLSocket.class.getDeclaredMethod(""getSSLParameters"");
Method setSSLParameters = SSLSocket.class.getDeclaredMethod(""setSSLParameters"", cls);
if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
Object sslParams = getSSLParameters.invoke(socket);
if (sslParams != null) {
setEndpointIdentificationAlgorithm.invoke(sslParams, ""HTTPS"");
setSSLParameters.invoke(socket, sslParams);
return true;
}
}
} catch (SecurityException e) {
} catch (ClassNotFoundException e) {
} catch (NoSuchMethodException e) {
} catch (IllegalArgumentException e) {
} catch (IllegalAccessException e) {
} catch (InvocationTargetException e) {
}
return false;
}",0
4469,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
4470,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
4471,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4472,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4473,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4474,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4475,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4476,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
4477,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
4478,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4479,"@Deprecated
public static String TRUSTSTORE_ALGORITHM;",0
4480,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
4481,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4482,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4483,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4484,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4485,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4486,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4487,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4488,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4489,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4490,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4491,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4492,"public IOException getIOException() {
return (IOException) getCause();
}",0
4493,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4494,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4495,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4496,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4497,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
4498,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4499,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4500,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4501,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
bogusIdCount++;
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4502,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4503,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4504,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4505,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4506,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4507,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4508,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4509,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4510,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4511,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4512,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4513,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4514,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4515,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4516,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4517,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4518,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4519,"public int[] startSubnegotiationLocal() {
return null;
}",0
4520,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4521,"public int[] startSubnegotiationRemote() {
return null;
}",0
4522,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4523,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
4524,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4525,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4526,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4527,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4528,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4529,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
4530,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4531,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4532,"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4533,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4534,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
4535,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4536,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4537,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4538,"@Override
InputStream _createErrorStream() throws IOException {
int localPort;
ServerSocket server;
Socket socket;
localPort = MAX_CLIENT_PORT;
server = null;
for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort) {
try {
server = _serverSocketFactory_.createServerSocket(localPort, 1, getLocalAddress());
break;
} catch (SocketException e) {
continue;
}
}
if (server == null) {
throw new BindException(""All ports in use."");
}
_output_.write(Integer.toString(server.getLocalPort()).getBytes());
_output_.write('\0');
_output_.flush();
socket = server.accept();
server.close();
if (isRemoteVerificationEnabled() && !verifyRemote(socket)) {
socket.close();
throw new IOException(""Security violation: unexpected connection attempt by "" + socket.getInetAddress().getHostAddress());
}
return (new SocketInputStream(socket, socket.getInputStream()));
}",0
4539,"InputStream _createErrorStream() throws IOException {
ServerSocket server;
Socket socket;
server = _serverSocketFactory_.createServerSocket(0, 1, getLocalAddress());
_output_.write(Integer.toString(server.getLocalPort()).getBytes());
_output_.write('\0');
_output_.flush();
socket = server.accept();
server.close();
if (__remoteVerificationEnabled && !verifyRemote(socket)) {
socket.close();
throw new IOException(""Security violation: unexpected connection attempt by "" + socket.getInetAddress().getHostAddress());
}
return (new SocketInputStream(socket, socket.getInputStream()));
}",0
4540,"public void rexec(String username, String password, String command, boolean separateErrorStream) throws IOException {
int ch;
if (separateErrorStream) {
_errorStream_ = _createErrorStream();
} else {
_output_.write('\0');
}
_output_.write(username.getBytes());
_output_.write('\0');
_output_.write(password.getBytes());
_output_.write('\0');
_output_.write(command.getBytes());
_output_.write('\0');
_output_.flush();
ch = _input_.read();
if (ch > 0) {
StringBuilder buffer = new StringBuilder();
while ((ch = _input_.read()) != -1 && ch != '\n') {
buffer.append((char) ch);
}
throw new IOException(buffer.toString());
} else if (ch < 0) {
throw new IOException(""Server closed connection."");
}
}",0
4541,"public String getTime() throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader reader;
reader = new BufferedReader(new InputStreamReader(_input_));
while (true) {
read = reader.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
return result.toString();
}",0
4542,"public String getTime(InetAddress host, int port) throws IOException {
DatagramPacket sendPacket, receivePacket;
sendPacket = new DatagramPacket(__dummyData, __dummyData.length, host, port);
receivePacket = new DatagramPacket(__timeData, __timeData.length);
_socket_.send(sendPacket);
_socket_.receive(receivePacket);
return new String(receivePacket.getData(), 0, receivePacket.getLength());
}",0
4543,"public String query(boolean longOutput, String username) throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader input;
input = new BufferedReader(new InputStreamReader(getInputStream(longOutput, username)));
try {
while (true) {
read = input.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
} finally {
input.close();
}
return result.toString();
}",0
4544,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
4545,"private void readStream(InputStream stream, String encoding) throws IOException {
BufferedReader reader;
if (encoding == null) {
reader = new BufferedReader(new InputStreamReader(stream));
} else {
reader = new BufferedReader(new InputStreamReader(stream, encoding));
}
String line = this.parser.readNextEntry(reader);
while (line != null) {
this.entries.add(line);
line = this.parser.readNextEntry(reader);
}
reader.close();
}",0
4546,"public int execMIC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_MIC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_MIC, """");
}
}",0
4547,"public int execADAT(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ADAT, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ADAT);
}
}",0
4548,"public int execENC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ENC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ENC, """");
}
}",0
4549,"@Deprecated
public static String KEYSTORE_ALGORITHM;",0
4550,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = _socket_.getInetAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (!isClientMode) {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
}",0
4551,"public int execCONF(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_CONF, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_CONF, """");
}
}",0
4552,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4553,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4554,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0
4555,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4556,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4557,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4558,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4559,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
}",0
4560,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4561,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4562,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4563,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4564,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4565,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t);
}
}
root = findRootSet();
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects();
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
root = null;
return result;
}",0
4566,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4567,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4568,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4569,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4570,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4571,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4572,public String identifier;,0
4573,public int size;,0
4574,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
}",0
4575,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4576,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4577,"public boolean auth(AuthenticatingSMTPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!SMTPReply.isPositiveIntermediate(sendCommand(SMTPCommand.AUTH, AUTH_METHOD.getAuthName(method)))) {
return false;
}
if (method.equals(AUTH_METHOD.PLAIN)) {
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))));
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(4).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(toEncode))));
} else if (method.equals(AUTH_METHOD.LOGIN)) {
if (!SMTPReply.isPositiveIntermediate(sendCommand(new String(Base64.encodeBase64(username.getBytes()))))) {
return false;
}
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(password.getBytes()))));
} else {
return false;
}
}",0
4578,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
}",0
4579,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4580,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4581,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4582,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
4583,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
4584,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4585,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
4586,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4587,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4588,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4589,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4590,"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4591,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4592,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4593,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4594,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4595,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4596,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4597,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4598,"public Object decode(Object pObject) {
if (pObject instanceof byte[]) {
return decode((byte[]) pObject);
} else if (pObject instanceof String) {
return decode((String) pObject);
} else {
throw new RuntimeException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
}
}",0
4599,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
4600,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
4601,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4602,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4603,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4604,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4605,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4606,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4607,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
4608,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4609,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4610,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
4611,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
4612,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4613,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4614,"@Deprecated
public static String STORE_TYPE;",0
4615,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4616,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4617,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4618,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4619,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4620,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4621,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0
4622,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4623,"public IOException getIOException() {
return (IOException) getCause();
}",0
4624,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4625,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4626,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4627,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4628,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
4629,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4630,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4631,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4632,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4633,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
bogusIdCount++;
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4634,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4635,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4636,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4637,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4638,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4639,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4640,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4641,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0
4642,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0
4643,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4644,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4645,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4646,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4647,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4648,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4649,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4650,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4651,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4652,"public int[] startSubnegotiationRemote() {
return null;
}",0
4653,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4654,"public int[] startSubnegotiationLocal() {
return null;
}",0
4655,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4656,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4657,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4658,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _fileName.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_fileName.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4659,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _fileName.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_fileName.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4660,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4661,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4662,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4663,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
4664,"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4665,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4666,"public static boolean enableEndpointNameVerification(SSLSocket socket) {
try {
Class<?> cls = Class.forName(""javax.net.ssl.SSLParameters"");
Method setEndpointIdentificationAlgorithm = cls.getDeclaredMethod(""setEndpointIdentificationAlgorithm"", String.class);
Method getSSLParameters = SSLSocket.class.getDeclaredMethod(""getSSLParameters"");
Method setSSLParameters = SSLSocket.class.getDeclaredMethod(""setSSLParameters"", cls);
if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
Object sslParams = getSSLParameters.invoke(socket);
if (sslParams != null) {
setEndpointIdentificationAlgorithm.invoke(sslParams, ""HTTPS"");
setSSLParameters.invoke(socket, sslParams);
return true;
}
}
} catch (SecurityException e) {
} catch (ClassNotFoundException e) {
} catch (NoSuchMethodException e) {
} catch (IllegalArgumentException e) {
} catch (IllegalAccessException e) {
} catch (InvocationTargetException e) {
}
return false;
}",0
4667,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
4668,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
4669,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4670,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4671,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4672,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4673,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4674,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
4675,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4676,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
4677,"@Deprecated
public static String STORE_TYPE;",0
4678,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4679,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
4680,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4681,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4682,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4683,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4684,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4685,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4686,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4687,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4688,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4689,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4690,"public IOException getIOException() {
return (IOException) getCause();
}",0
4691,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
4692,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4693,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4694,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4695,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4696,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4697,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4698,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4699,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4700,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4701,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4702,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4703,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4704,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4705,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4706,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4707,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4708,public String identifier;,0
4709,public int size;,0
4710,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4711,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4712,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4713,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4714,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4715,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4716,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4717,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4718,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4719,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4720,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4721,"public int[] startSubnegotiationRemote() {
return null;
}",0
4722,"public int[] startSubnegotiationLocal() {
return null;
}",0
4723,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4724,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4725,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
4726,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4727,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4728,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4729,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4730,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4731,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
4732,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4733,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4734,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4735,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4736,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
4737,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
4738,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4739,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4740,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4741,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4742,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4743,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
4744,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4745,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0
4746,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4747,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
4748,"@Deprecated
public static String TRUSTSTORE_ALGORITHM;",0
4749,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4750,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4751,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0
4752,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4753,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4754,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4755,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4756,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4757,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4758,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4759,"public IOException getIOException() {
return (IOException) getCause();
}",0
4760,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4761,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0
4762,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4763,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4764,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4765,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4766,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4767,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4768,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0
4769,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4770,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
bogusIdCount++;
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4771,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4772,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4773,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4774,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4775,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4776,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4777,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4778,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4779,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4780,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4781,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4782,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4783,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4784,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4785,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4786,"public int[] startSubnegotiationRemote() {
return null;
}",0
4787,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4788,"public int[] startSubnegotiationLocal() {
return null;
}",0
4789,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4790,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
4791,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4792,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4793,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4794,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4795,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0
4796,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4797,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4798,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4799,"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4800,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4801,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0
4802,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0
4803,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0
4804,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0
4805,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0
4806,"@Override
InputStream _createErrorStream() throws IOException {
int localPort;
ServerSocket server;
Socket socket;
localPort = MAX_CLIENT_PORT;
server = null;
for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort) {
try {
server = _serverSocketFactory_.createServerSocket(localPort, 1, getLocalAddress());
break;
} catch (SocketException e) {
continue;
}
}
if (server == null) {
throw new BindException(""All ports in use."");
}
_output_.write(Integer.toString(server.getLocalPort()).getBytes());
_output_.write('\0');
_output_.flush();
socket = server.accept();
server.close();
if (isRemoteVerificationEnabled() && !verifyRemote(socket)) {
socket.close();
throw new IOException(""Security violation: unexpected connection attempt by "" + socket.getInetAddress().getHostAddress());
}
return (new SocketInputStream(socket, socket.getInputStream()));
}",0
4807,"public void rexec(String username, String password, String command, boolean separateErrorStream) throws IOException {
int ch;
if (separateErrorStream) {
_errorStream_ = _createErrorStream();
} else {
_output_.write('\0');
}
_output_.write(username.getBytes());
_output_.write('\0');
_output_.write(password.getBytes());
_output_.write('\0');
_output_.write(command.getBytes());
_output_.write('\0');
_output_.flush();
ch = _input_.read();
if (ch > 0) {
StringBuilder buffer = new StringBuilder();
while ((ch = _input_.read()) != -1 && ch != '\n') {
buffer.append((char) ch);
}
throw new IOException(buffer.toString());
} else if (ch < 0) {
throw new IOException(""Server closed connection."");
}
}",0
4808,"InputStream _createErrorStream() throws IOException {
ServerSocket server;
Socket socket;
server = _serverSocketFactory_.createServerSocket(0, 1, getLocalAddress());
_output_.write(Integer.toString(server.getLocalPort()).getBytes());
_output_.write('\0');
_output_.flush();
socket = server.accept();
server.close();
if (__remoteVerificationEnabled && !verifyRemote(socket)) {
socket.close();
throw new IOException(""Security violation: unexpected connection attempt by "" + socket.getInetAddress().getHostAddress());
}
return (new SocketInputStream(socket, socket.getInputStream()));
}",0
4809,"public String getTime() throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader reader;
reader = new BufferedReader(new InputStreamReader(_input_));
while (true) {
read = reader.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
return result.toString();
}",0
4810,"public String getTime(InetAddress host, int port) throws IOException {
DatagramPacket sendPacket, receivePacket;
sendPacket = new DatagramPacket(__dummyData, __dummyData.length, host, port);
receivePacket = new DatagramPacket(__timeData, __timeData.length);
_socket_.send(sendPacket);
_socket_.receive(receivePacket);
return new String(receivePacket.getData(), 0, receivePacket.getLength());
}",0
4811,"public InputStream getInputStream(boolean longOutput, String username, String encoding) throws IOException {
DataOutputStream output;
StringBuilder buffer = new StringBuilder(64);
if (longOutput) {
buffer.append(__LONG_FLAG);
}
buffer.append(username);
buffer.append(SocketClient.NETASCII_EOL);
byte[] encodedQuery = (encoding == null ? buffer.toString().getBytes() : buffer.toString().getBytes(encoding));
output = new DataOutputStream(new BufferedOutputStream(_output_, 1024));
output.write(encodedQuery, 0, encodedQuery.length);
output.flush();
return _input_;
}",0
4812,"public String query(boolean longOutput, String username) throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader input;
input = new BufferedReader(new InputStreamReader(getInputStream(longOutput, username)));
try {
while (true) {
read = input.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
} finally {
input.close();
}
return result.toString();
}",0
4813,"public String[] listNames(String pathname) throws IOException {
Socket socket;
if ((socket = _openDataConnection_(FTPCommand.NLST, getListArguments(pathname))) == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4814,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0
4815,"private void readStream(InputStream stream, String encoding) throws IOException {
BufferedReader reader;
if (encoding == null) {
reader = new BufferedReader(new InputStreamReader(stream));
} else {
reader = new BufferedReader(new InputStreamReader(stream, encoding));
}
String line = this.parser.readNextEntry(reader);
while (line != null) {
this.entries.add(line);
line = this.parser.readNextEntry(reader);
}
reader.close();
}",0
4816,"public int execADAT(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ADAT, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ADAT);
}
}",0
4817,"public int execENC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ENC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ENC, """");
}
}",0
4818,"public int execMIC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_MIC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_MIC, """");
}
}",0
4819,"@Deprecated
public static String KEYSTORE_ALGORITHM;",0
4820,"public int execCONF(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_CONF, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_CONF, """");
}
}",0
4821,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4822,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = _socket_.getInetAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (!isClientMode) {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
}",0
4823,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4824,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0
4825,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0
4826,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4827,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0
4828,"public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, method.getAuthName()))) {
return false;
}
switch(method) {
case PLAIN:
{
int result = sendData(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case CRAM_MD5:
{
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
int result = sendData(new String(Base64.encodeBase64(toEncode)));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case LOGIN:
{
if (sendData(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT) {
return false;
}
int result = sendData(new String(Base64.encodeBase64(password.getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
}
return false;
}",0
4829,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0
4830,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4831,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
}",0
4832,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4833,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0
4834,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0
4835,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0
4836,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0
4837,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0
4838,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0
4839,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t);
}
}
root = findRootSet();
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects();
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
root = null;
return result;
}",0
4840,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4841,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4842,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0
4843,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4844,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0
4845,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0
4846,"public boolean auth(AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (sendCommand(POP3Command.AUTH, method.getAuthName()) != POP3Reply.OK_INT) {
return false;
}
switch(method) {
case PLAIN:
return sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))) == POP3Reply.OK;
case CRAM_MD5:
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return sendCommand(new String(Base64.encodeBase64(toEncode))) == POP3Reply.OK;
default:
return false;
}
}",0
4847,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0
4848,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0
4849,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0
4850,"public boolean login(String username, String timestamp, String secret) throws IOException, NoSuchAlgorithmException {
int i;
byte[] digest;
StringBuilder buffer, digestBuffer;
MessageDigest md5;
if (getState() != AUTHORIZATION_STATE) {
return false;
}
md5 = MessageDigest.getInstance(""MD5"");
timestamp += secret;
digest = md5.digest(timestamp.getBytes());
digestBuffer = new StringBuilder(128);
for (i = 0; i < digest.length; i++) {
int digit = digest[i] & 0xff;
if (digit <= 15) {
digestBuffer.append(""0"");
}
digestBuffer.append(Integer.toHexString(digit));
}
buffer = new StringBuilder(256);
buffer.append(username);
buffer.append(' ');
buffer.append(digestBuffer.toString());
if (sendCommand(POP3Command.APOP, buffer.toString()) != POP3Reply.OK) {
return false;
}
setState(TRANSACTION_STATE);
return true;
}",0
4851,public int size;,0
4852,public String identifier;,0
4853,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4854,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
}",0
4855,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4856,"public boolean auth(AuthenticatingSMTPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!SMTPReply.isPositiveIntermediate(sendCommand(SMTPCommand.AUTH, AUTH_METHOD.getAuthName(method)))) {
return false;
}
if (method.equals(AUTH_METHOD.PLAIN)) {
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))));
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(4).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(toEncode))));
} else if (method.equals(AUTH_METHOD.LOGIN)) {
if (!SMTPReply.isPositiveIntermediate(sendCommand(new String(Base64.encodeBase64(username.getBytes()))))) {
return false;
}
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(password.getBytes()))));
} else {
return false;
}
}",0
4857,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
}",0
4858,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0
4859,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0
4860,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4861,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
4862,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4863,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4864,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
4865,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4866,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4867,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
4868,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4869,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0
4870,"final synchronized void _sendTerminalType() throws IOException {
if (debug) {
System.err.println(""SEND TERMINAL-TYPE: "" + terminalType);
}
if (terminalType != null) {
_output_.write(_COMMAND_SB);
_output_.write(_COMMAND_IS);
_output_.write(terminalType.getBytes());
_output_.write(_COMMAND_SE);
_output_.flush();
}
}",0
4871,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4872,"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4873,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0
4874,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0
4875,"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0
4876,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0
4877,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0
4878,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4879,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0
4880,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0
4881,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0
4882,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0
4883,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0
4884,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0
4885,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0
4886,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0
4887,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0
4888,"public Object encode(Object pObject) {
if (!(pObject instanceof byte[])) {
throw new RuntimeException(""Parameter supplied to Base64 encode is not a byte[]"");
}
return encode((byte[]) pObject);
}",0
4889,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4890,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
4891,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0
4892,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0
4893,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0
4894,"public Object decode(Object pObject) {
if (pObject instanceof byte[]) {
return decode((byte[]) pObject);
} else if (pObject instanceof String) {
return decode((String) pObject);
} else {
throw new RuntimeException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
}
}",0
4895,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0
4896,private final CopyOnWriteArrayList<EventListener> __listeners;,0
4897,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",1
4898,"// Call sequence: 2
public X509Certificate[] getCertificateChain(String alias) {
try {
return new X509Certificate[] { (X509Certificate) keyStore.getCertificate(alias) };
} catch (GeneralSecurityException e) {
return null;
}
}",1
4899,"public FTPHTTPClient(String proxyHost, int proxyPort, String proxyUser, String proxyPass) {
this.proxyHost = proxyHost;
this.proxyPort = proxyPort;
this.proxyUsername = proxyUser;
this.proxyPassword = proxyPass;
try {
CRLF = ""\r\n"".getBytes(getControlEncoding());
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",1
4900,"public String toDateString() {
DateFormat formatter = null;
if (simpleFormatter != null) {
formatter = simpleFormatter.get();
}
if (formatter == null) {
formatter = new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);
formatter.setTimeZone(TimeZone.getDefault());
simpleFormatter = new SoftReference<DateFormat>(formatter);
}
Date ntpDate = getDate();
synchronized (formatter) {
return formatter.format(ntpDate);
}
}",1
4901,public final String identifier;,0
4902,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list()))
return null;
return __readNewsgroupListing();
}",0
4903,"public Throwable getRootCause() {
return this.rootCause;
}",1
4904,"@Override
public FTPFile parseFTPEntry(String entry) {
boolean isParsed = false;
FTPFile f = new FTPFile();
if (isType == FILE_LIST_TYPE) {
isParsed = parseFileList(f, entry);
} else if (isType == MEMBER_LIST_TYPE) {
isParsed = parseMemberList(f, entry);
if (!isParsed) {
isParsed = parseSimpleEntry(f, entry);
}
} else if (isType == UNIX_LIST_TYPE) {
return unixFTPEntryParser.parseFTPEntry(entry);
} else if (isType == JES_LEVEL_1_LIST_TYPE) {
isParsed = parseJeslevel1List(f, entry);
} else if (isType == JES_LEVEL_2_LIST_TYPE) {
isParsed = parseJeslevel2List(f, entry);
}
if (!isParsed) {
f = null;
}
return f;
}",0
4905,"final synchronized void _processAYTResponse() {
if (!aytFlag) {
synchronized (aytMonitor) {
aytFlag = true;
try {
aytMonitor.notifyAll();
} catch (IllegalMonitorStateException e) {
System.err.println(""Exception notifying:"" + e.getMessage());
}
}
}
}",1
4906,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",1
4907,public String identifier;,0
4908,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
}",0
4909,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",1
4910,"private void gatherSubjects() {
int count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) count++;
HashMap<String, ThreadContainer> subjectTable = new HashMap<String, ThreadContainer>((int) (count * 1.2), (float) 0.9);
count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) {
Threadable threadable = c.threadable;
if (threadable == null)
threadable = c.child.threadable;
String subj = threadable.simplifiedSubject();
if (subj == null || subj == """")
continue;
ThreadContainer old = subjectTable.get(subj);
// Add this container to the table iff:
// - The container in the table has a ""Re:"" version of this subject, and
// this container has a non-""Re:"" version of this subject. The non-""Re:"" version
if (old == null || (c.threadable == null && old.threadable != null) || (old.threadable != null && old.threadable.subjectIsReply() && c.threadable != null && !c.threadable.subjectIsReply())) {
subjectTable.put(subj, c);
count++;
}
}
if (count == 0)
return;
ThreadContainer prev, c, rest;
for (prev = null, c = root.child, rest = c.next; c != null; prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
Threadable threadable = c.threadable;
if (threadable == null)
threadable = c.child.threadable;
String subj = threadable.simplifiedSubject();
if (subj == null || subj == """")
continue;
ThreadContainer old = subjectTable.get(subj);
if (old == c)
continue;
if (prev == null)
root.child = c.next;
else
prev.next = c.next;
c.next = null;
if (old.threadable == null && c.threadable == null) {
ThreadContainer tail;
for (tail = old.child; tail != null && tail.next != null; tail = tail.next) {
}
if (tail != null) {
tail.next = c.child;
}
for (tail = c.child; tail != null; tail = tail.next) tail.parent = old;
c.child = null;
} else if (old.threadable == null || (c.threadable != null && c.threadable.subjectIsReply() && !old.threadable.subjectIsReply())) {
// Else if old is empty, or c has ""Re:"" and old does not  ==> make this message a child of old
c.parent = old;
c.next = old.child;
old.child = c;
} else {
ThreadContainer newc = new ThreadContainer();
newc.threadable = old.threadable;
newc.child = old.child;
for (ThreadContainer tail = newc.child; tail != null; tail = tail.next) tail.parent = newc;
old.threadable = null;
old.child = null;
c.parent = old;
newc.parent = old;
old.child = c;
c.next = newc;
}
c = prev;
}
subjectTable.clear();
subjectTable = null;
}",1
4911,"@Deprecated
public static String PROVIDER;",1
4912,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4913,"private void tunnelHandshake(String host, int port, InputStream input, OutputStream output) throws IOException, UnsupportedEncodingException {
final String connectString = ""CONNECT "" + host + "":"" + port + "" HTTP/1.1"";
_output_.write(connectString.getBytes(getControlEncoding()));
_output_.write(CRLF);
if (proxyUsername != null && proxyPassword != null) {
final String header = ""Proxy-Authorization: Basic "" + base64.encode(proxyUsername + "":"" + proxyPassword) + ""\r\n"";
_output_.write(header.getBytes(""UTF-8""));
_output_.write(CRLF);
List<String> response = new ArrayList<String>();
BufferedReader reader = new BufferedReader(new InputStreamReader(_input_));
for (String line = reader.readLine(); line != null && line.length() > 0; line = reader.readLine()) {
response.add(line);
}
int size = response.size();
if (size == 0) {
throw new IOException(""No response from proxy"");
}
String code = null;
String resp = response.get(0);
if (resp.startsWith(""HTTP/"") && resp.length() >= 12) {
code = resp.substring(9, 12);
} else {
throw new IOException(""Invalid response from proxy: "" + resp);
}
if (!""200"".equals(code)) {
StringBuilder msg = new StringBuilder();
msg.append(""HTTPTunnelConnector: connection failed\r\n"");
msg.append(""Response received from the proxy:\r\n"");
for (String line : response) {
msg.append(line);
msg.append(""\r\n"");
}
throw new IOException(msg.toString());
}
}
}",0
4914,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
try {
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
} catch (IllegalMonitorStateException e) {
System.err.println(""Exception processing AYT:"" + e.getMessage());
}
}
return (retValue);
}",0
4915,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1
4916,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
try {
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
} catch (IllegalMonitorStateException e) {
System.err.println(""Exception processing AYT:"" + e.getMessage());
}
}
return (retValue);
}",1
4917,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = _socket_.getInetAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (!isClientMode) {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
}",0
4918,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
}",0
4919,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",1
4920,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
4921,"public FTPFile parseFTPEntry(String entry) {
String[] parts = entry.split("" "", 2);
if (parts.length != 2) {
return null;
}
FTPFile file = new FTPFile();
file.setRawListing(entry);
file.setName(parts[1]);
String[] facts = parts[0].split("";"");
boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
for (String fact : facts) {
String[] factparts = fact.split(""="");
if (factparts.length != 2) {
continue;
}
String factname = factparts[0].toLowerCase(Locale.ENGLISH);
String factvalue = factparts[1];
String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
if (""size"".equals(factname)) {
file.setSize(Long.parseLong(factvalue));
} else if (""sizd"".equals(factname)) {
file.setSize(Long.parseLong(factvalue));
} else if (""modify"".equals(factname)) {
SimpleDateFormat sdf;
if (factvalue.contains(""."")) {
sdf = new SimpleDateFormat(""yyyyMMddHHmmss.SSS"");
} else {
sdf = new SimpleDateFormat(""yyyyMMddHHmmss"");
}
GregorianCalendar gc = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
try {
gc.setTime(sdf.parse(factvalue));
} catch (ParseException e) {
}
file.setTimestamp(gc);
} else if (""type"".equals(factname)) {
Integer intType = TYPE_TO_INT.get(valueLowerCase);
if (intType == null) {
} else {
file.setType(intType.intValue());
}
} else if (factname.startsWith(""unix."")) {
String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
if (""group"".equals(unixfact)) {
file.setGroup(factvalue);
} else if (""owner"".equals(unixfact)) {
file.setUser(factvalue);
} else if (""mode"".equals(unixfact)) {
int off = factvalue.length() - 4;
for (int i = 1; i <= 3; i++) {
int ch = factvalue.charAt(off + i) - '0';
for (int p : UNIX_PERMS[ch]) {
file.setPermission(UNIX_GROUPS[i - 1], p, true);
}
}
file.setUser(factvalue);
}
} else if (!hasUnixMode && ""perm"".equals(factname)) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
return null;
}
}
}
}
return file;
}",0
4922,private final Charset charset;,1
4923,public final int number;,0
4924,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4925,public int size;,0
4926,"private void gatherSubjects() {
int count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) count++;
HashMap<String, ThreadContainer> subjectTable = new HashMap<String, ThreadContainer>((int) (count * 1.2), (float) 0.9);
count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) {
Threadable threadable = c.threadable;
if (threadable == null)
threadable = c.child.threadable;
String subj = threadable.simplifiedSubject();
if (subj == null || subj == """")
continue;
ThreadContainer old = subjectTable.get(subj);
// Add this container to the table iff:
// - The container in the table has a ""Re:"" version of this subject, and
// this container has a non-""Re:"" version of this subject. The non-""Re:"" version
if (old == null || (c.threadable == null && old.threadable != null) || (old.threadable != null && old.threadable.subjectIsReply() && c.threadable != null && !c.threadable.subjectIsReply())) {
subjectTable.put(subj, c);
count++;
}
}
if (count == 0)
return;
ThreadContainer prev, c, rest;
for (prev = null, c = root.child, rest = c.next; c != null; prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
Threadable threadable = c.threadable;
if (threadable == null)
threadable = c.child.threadable;
String subj = threadable.simplifiedSubject();
if (subj == null || subj == """")
continue;
ThreadContainer old = subjectTable.get(subj);
if (old == c)
continue;
if (prev == null)
root.child = c.next;
else
prev.next = c.next;
c.next = null;
if (old.threadable == null && c.threadable == null) {
ThreadContainer tail;
for (tail = old.child; tail != null && tail.next != null; tail = tail.next) {
}
if (tail != null) {
tail.next = c.child;
}
for (tail = c.child; tail != null; tail = tail.next) tail.parent = old;
c.child = null;
} else if (old.threadable == null || (c.threadable != null && c.threadable.subjectIsReply() && !old.threadable.subjectIsReply())) {
// Else if old is empty, or c has ""Re:"" and old does not  ==> make this message a child of old
c.parent = old;
c.next = old.child;
old.child = c;
} else {
ThreadContainer newc = new ThreadContainer();
newc.threadable = old.threadable;
newc.child = old.child;
for (ThreadContainer tail = newc.child; tail != null; tail = tail.next) tail.parent = newc;
old.threadable = null;
old.child = null;
c.parent = old;
newc.parent = old;
old.child = c;
c.next = newc;
}
c = prev;
}
subjectTable.clear();
subjectTable = null;
}",0
4927,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",1
4928,"public static void main(String[] args) throws Exception {
if (args.length == 0) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
}
CodeSource codeSource = Main.class.getProtectionDomain().getCodeSource();
Map<String, String> map = new HashMap<String, String>();
if (codeSource != null) {
final String sourceFile = codeSource.getLocation().getFile();
if (sourceFile.endsWith("".jar"")) {
if (args.length == 0) {
System.out.println(""\nClasses found in the jar:"");
}
JarFile jf = new JarFile(sourceFile);
Enumeration<JarEntry> e = jf.entries();
while (e.hasMoreElements()) {
JarEntry je = e.nextElement();
String name = je.getName();
if (!name.endsWith("".class"") || name.contains(""$"") || name.equals(""examples/nntp/NNTPUtils.class"") || name.equals(""examples/util/IOUtil.class"") || name.equals(""examples/mail/IMAPUtils.class"") || name.equals(""examples/Main.class"")) {
continue;
}
name = name.replace("".class"", """");
int lastSep = name.lastIndexOf('/');
String alias = name.substring(lastSep + 1);
if (args.length == 0) {
System.out.printf(""%-25s %s%n"", alias, name);
}
map.put(alias, name);
}
jf.close();
}
}
if (args.length == 0) {
return;
}
String shortName = args[0];
String fullName = map.get(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
m.invoke(null, (Object) args2);
}",1
4929,"private void gatherSubjects() {
int count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) {
count++;
}
HashMap<String, ThreadContainer> subjectTable = new HashMap<String, ThreadContainer>((int) (count * 1.2), (float) 0.9);
count = 0;
for (ThreadContainer c = root.child; c != null; c = c.next) {
Threadable threadable = c.threadable;
if (threadable == null) {
threadable = c.child.threadable;
}
String subj = threadable.simplifiedSubject();
if (subj == null || subj.length() == 0) {
continue;
}
ThreadContainer old = subjectTable.get(subj);
// Add this container to the table iff:
// - The container in the table has a ""Re:"" version of this subject, and
// this container has a non-""Re:"" version of this subject. The non-""Re:"" version
if (old == null || (c.threadable == null && old.threadable != null) || (old.threadable != null && old.threadable.subjectIsReply() && c.threadable != null && !c.threadable.subjectIsReply())) {
subjectTable.put(subj, c);
count++;
}
}
if (count == 0) {
return;
}
ThreadContainer prev, c, rest;
for (prev = null, c = root.child, rest = c.next; c != null; prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
Threadable threadable = c.threadable;
if (threadable == null) {
threadable = c.child.threadable;
}
String subj = threadable.simplifiedSubject();
if (subj == null || subj.length() == 0) {
continue;
}
ThreadContainer old = subjectTable.get(subj);
if (old == c) {
continue;
}
if (prev == null) {
root.child = c.next;
} else {
prev.next = c.next;
}
c.next = null;
if (old.threadable == null && c.threadable == null) {
ThreadContainer tail;
for (tail = old.child; tail != null && tail.next != null; tail = tail.next) {
}
if (tail != null) {
tail.next = c.child;
}
for (tail = c.child; tail != null; tail = tail.next) {
tail.parent = old;
}
c.child = null;
} else if (old.threadable == null || (c.threadable != null && c.threadable.subjectIsReply() && !old.threadable.subjectIsReply())) {
// Else if old is empty, or c has ""Re:"" and old does not  ==> make this message a child of old
c.parent = old;
c.next = old.child;
old.child = c;
} else {
ThreadContainer newc = new ThreadContainer();
newc.threadable = old.threadable;
newc.child = old.child;
for (ThreadContainer tail = newc.child; tail != null; tail = tail.next) {
tail.parent = newc;
}
old.threadable = null;
old.child = null;
c.parent = old;
newc.parent = old;
old.child = c;
c.next = newc;
}
c = prev;
}
subjectTable.clear();
subjectTable = null;
}",1
4930,"public boolean auth(ExtendedPOP3Client.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (sendCommand(authCommand + "" "" + AUTH_METHOD.getAuthName(method)) != POP3Reply.OK_INT)
return false;
if (method.equals(AUTH_METHOD.PLAIN)) {
return sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))) == POP3Reply.OK;
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return sendCommand(new String(Base64.encodeBase64(toEncode))) == POP3Reply.OK;
} else
return false;
}",0
4931,"public ParserInitializationException(String message, Throwable rootCause) {
super(message);
this.rootCause = rootCause;
}",1
4932,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",1
4933,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
__cslDebug = csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0
4934,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0
4935,"public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, AUTH_METHOD.getAuthName(method)))) {
return false;
}
if (method.equals(AUTH_METHOD.PLAIN)) {
int result = sendUntaggedCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
int result = sendUntaggedCommand(new String(Base64.encodeBase64(toEncode)));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
} else if (method.equals(AUTH_METHOD.LOGIN)) {
if (sendUntaggedCommand(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT) {
return false;
}
int result = sendUntaggedCommand(new String(Base64.encodeBase64(password.getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
} else
return false;
}",0
4936,"public FTPFile parseFTPEntry(String entry) {
String[] parts = entry.split("" "", 2);
if (parts.length != 2) {
return null;
}
FTPFile file = new FTPFile();
file.setRawListing(entry);
file.setName(parts[1]);
String[] facts = parts[0].split("";"");
boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
for (String fact : facts) {
String[] factparts = fact.split(""="");
if (factparts.length != 2) {
continue;
}
String factname = factparts[0].toLowerCase(Locale.ENGLISH);
String factvalue = factparts[1];
String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
if (""size"".equals(factname)) {
file.setSize(Long.parseLong(factvalue));
} else if (""sizd"".equals(factname)) {
file.setSize(Long.parseLong(factvalue));
} else if (""modify"".equals(factname)) {
SimpleDateFormat sdf;
if (factvalue.contains(""."")) {
sdf = new SimpleDateFormat(""yyyyMMddHHmmss.SSS"");
} else {
sdf = new SimpleDateFormat(""yyyyMMddHHmmss"");
}
GregorianCalendar gc = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
try {
gc.setTime(sdf.parse(factvalue));
} catch (ParseException e) {
}
file.setTimestamp(gc);
} else if (""type"".equals(factname)) {
Integer intType = TYPE_TO_INT.get(valueLowerCase);
if (intType == null) {
} else {
file.setType(intType.intValue());
}
} else if (factname.startsWith(""unix."")) {
String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
if (""group"".equals(unixfact)) {
file.setGroup(factvalue);
} else if (""owner"".equals(unixfact)) {
file.setUser(factvalue);
} else if (""mode"".equals(unixfact)) {
int off = factvalue.length() - 4;
for (int i = 1; i <= 3; i++) {
int ch = factvalue.charAt(off + i) - '0';
for (int p : UNIX_PERMS[ch]) {
file.setPermission(UNIX_GROUPS[i - 1], p, true);
}
}
file.setUser(factvalue);
}
} else if (!hasUnixMode && ""perm"".equals(factname)) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
return null;
}
}
}
}
return file;
}",0
4937,"public static void main(String[] args) throws Throwable {
CodeSource codeSource = Main.class.getProtectionDomain().getCodeSource();
Map<String, String> map = new HashMap<String, String>();
final boolean noArgsProvided = args.length == 0;
if (codeSource != null) {
final String sourceFile = codeSource.getLocation().getFile();
if (sourceFile.endsWith("".jar"")) {
if (noArgsProvided) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
System.out.println(""\nClasses found in the jar:"");
}
JarFile jf = new JarFile(sourceFile);
Enumeration<JarEntry> e = jf.entries();
while (e.hasMoreElements()) {
JarEntry je = e.nextElement();
String name = je.getName();
processFileName(name, map, noArgsProvided);
}
jf.close();
} else {
if (noArgsProvided) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<exampleClass>,<exampleClass parameters>"");
System.out.println(""\nClasses found in the jar:"");
}
File examples = new File(sourceFile, ""examples"");
if (examples.exists()) {
scanForClasses(sourceFile.length(), examples, map, noArgsProvided);
}
}
} else {
if (noArgsProvided) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
}
}
if (noArgsProvided) {
return;
}
String shortName = args[0];
String fullName = map.get(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0
4938,"public byte[] parseADATReply(String reply) {
if (reply == null)
return null;
else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0
4939,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
}",0
4940,"public String[] listNames(String pathname) throws IOException {
String line;
Socket socket;
BufferedReader reader;
ArrayList<String> results;
if ((socket = _openDataConnection_(FTPCommand.NLST, getListArguments(pathname))) == null)
return null;
reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
results = new ArrayList<String>();
while ((line = reader.readLine()) != null) results.add(line);
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0
4941,"public static X509TrustManager getDefaultTrustManager() throws NoSuchAlgorithmException {
return (X509TrustManager) TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
}",1
4942,public int size;,0
4943,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1
4944,"public boolean status(String mailboxName, String[] itemNames) throws IOException {
String statusNames = """";
if (itemNames != null) {
statusNames += "" ("";
for (int i = 0; i < itemNames.length; i++) {
statusNames += itemNames[i];
if (i < itemNames.length - 1)
statusNames += "" "";
}
statusNames += "")"";
}
return doCommand(IMAPCommand.STATUS, statusNames);
}",1
4945,"public String toUTCString() {
DateFormat formatter = null;
if (utcFormatter != null)
formatter = utcFormatter.get();
if (formatter == null) {
formatter = new SimpleDateFormat(NTP_DATE_FORMAT + "" 'UTC'"", Locale.US);
formatter.setTimeZone(TimeZone.getTimeZone(""UTC""));
utcFormatter = new SoftReference<DateFormat>(formatter);
}
Date ntpDate = getDate();
synchronized (formatter) {
return formatter.format(ntpDate);
}
}",1
4946,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1
4947,ThreadContainer prev;,1
4948,"public FTPFile[] listFiles(String pathname) throws IOException {
String key = null;
FTPListParseEngine engine = initiateListParsing(key, pathname);
return engine.getFiles();
}",1
4949,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
totalBytesSent = 0L;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
totalBytesSent += totalThisPacket;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",1
4950,"public FTPListParseEngine initiateListParsing(String pathname) throws IOException {
String key = null;
return initiateListParsing(key, pathname);
}",1
4951,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",1
4952,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",1
4953,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1
4954,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
4955,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
4956,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
4957,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
4958,"@Override
public void passivateObject(final T obj) throws Exception {
writeLock.tryLock();
try {
factory.passivateObject(obj);
} finally {
writeLock.unlock();
}
}",0
4959,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
4960,private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;,0
4961,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
4962,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
4963,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
4964,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
4965,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,0
4966,"@Override
public void addObject(final K key) throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.addObject(key);
} finally {
writeLock.unlock();
}
}",0
4967,"@Override
public void returnObject(final K key, final V obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
4968,"@Override
public void invalidateObject(final K key, final V obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
4969,"@Override
public void clear(final K key) throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.clear(key);
} finally {
writeLock.unlock();
}
}",0
4970,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
4971,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
4972,"void cancel() {
scheduledFuture.cancel(false);
}",0
4973,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
4974,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p.getObject());
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
4975,private int _minIdle = DEFAULT_MIN_IDLE;,0
4976,private GenericObjectPoolConfig config;,0
4977,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
if (_factory.validateObject(key, obj)) {
_factory.passivateObject(key, obj);
} else {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
4978,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
4979,"public synchronized void returnObject(Object key, Object obj) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
} else {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
success = false;
}
}
if (isClosed()) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
return;
}
boolean shouldDestroy = false;
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
}",0
4980,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTime(), getSoftMinEvictableIdleTime(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
4981,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
4982,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
4983,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
4984,"public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
long idleSoftEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
if (getSoftMinEvictableIdleTimeMillis() > 0) {
idleSoftEvictTime = getSoftMinEvictableIdleTimeMillis();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis() || (idleSoftEvictTime < underTest.getIdleTimeMillis() && getMinIdle() < idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
return;
}",0
4985,"public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
4986,"@Override
public void addObject() throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.addObject();
} finally {
writeLock.unlock();
}
}",0
4987,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
4988,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
ObjectTimestampPair pair = null;
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
if (newlyCreated) {
pool.incrementActiveCount();
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
pool.incrementActiveCount();
return pair.value;
}
}
}
}",0
4989,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
4990,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
4991,"public synchronized void evict() throws Exception {
Object key = null;
if (_recentlyEvictedKeys == null) {
_recentlyEvictedKeys = new HashSet(_poolMap.size());
}
Set remainingKeys = new HashSet(_poolMap.keySet());
remainingKeys.removeAll(_recentlyEvictedKeys);
Iterator keyIter = remainingKeys.iterator();
ListIterator objIter = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap.size() > 0) {
if (key == null) {
if (!keyIter.hasNext()) {
_recentlyEvictedKeys.clear();
remainingKeys = new HashSet(_poolMap.keySet());
keyIter = remainingKeys.iterator();
}
if (!keyIter.hasNext()) {
return;
}
key = keyIter.next();
}
if (objIter == null) {
final LinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
if (_evictLastIndex < 0 || _evictLastIndex > list.size()) {
_evictLastIndex = list.size();
}
objIter = list.listIterator(_evictLastIndex);
}
if (objIter.hasPrevious()) {
ObjectTimestampPair pair = (ObjectTimestampPair) (objIter.previous());
boolean removeObject = false;
if (_minEvictableIdleTimeMillis > 0 && System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
objIter.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if ((_minIdle == 0) && (((ObjectQueue) (_poolMap.get(key))).queue.isEmpty())) {
_poolMap.remove(key);
}
} catch (Exception e) {
;
}
}
} else {
_recentlyEvictedKeys.add(key);
_evictLastIndex = -1;
objIter = null;
}
}
}
}",0
4992,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
4993,"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0
4994,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e2) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",0
4995,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
4996,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
4997,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
4998,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
4999,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5000,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
5001,private int initIdleCapacity;,0
5002,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5003,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5004,"void cancel() {
scheduledFuture.cancel(false);
}",0
5005,private int _maxSleeping = StackKeyedObjectPool.DEFAULT_MAX_SLEEPING;,0
5006,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5007,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
5008,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final LinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final LinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
5009,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
5010,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5011,"@Override
public void evict() throws Exception {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5012,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
5013,"public synchronized void evict() throws Exception {
Object key = null;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
boolean removeObject = false;
if ((_minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if (_minIdle == 0) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
if (objectQueue != null && objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
} catch (Exception e) {
}
}
}
}",0
5014,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}",0
5015,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5016,private long _maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;,0
5017,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5018,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
5019,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5020,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
5021,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
5022,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0
5023,"@Override
public void clear(K key) {
ObjectDeque<T> objectDeque = poolMap.get(key);
if (objectDeque == null) {
return;
}
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",0
5024,"public void returnObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5025,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}",0
5026,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5027,"public synchronized void evict() throws Exception {
assertOpen();
if (!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0) && (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0) && (idleTimeMilis > _softMinEvictableIdleTimeMillis) && (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if (_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
}
}
}",0
5028,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5029,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
5030,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(final Object other) {
return ((IdentityWrapper) other).instance == instance;
}",0
5031,"public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
PooledObject<T> underTest = null;
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
keyCopy.addAll(poolKeyList);
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis()) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest.getObject());
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest.getObject())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest.getObject());
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}",0
5032,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
5033,private int _numTestsPerEvictionRun = GenericKeyedObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;,0
5034,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5035,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
5036,"@Override
@Deprecated
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
}
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}",0
5037,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
5038,private int initIdleCapacity;,0
5039,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
5040,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5041,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5042,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
5043,private GenericKeyedObjectPoolConfig config;,0
5044,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
5045,private int maxSleeping;,0
5046,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
5047,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}",0
5048,"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0
5049,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5050,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
5051,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5052,"@Override
public void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
if (this._factory == null) {
synchronized (factoryLock) {
if (this._factory == null) {
this._factory = factory;
} else {
throw new IllegalStateException(""Factory already set"");
}
}
} else {
throw new IllegalStateException(""Factory already set"");
}
}",0
5053,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
5054,"public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
boolean testWhileIdle = _testWhileIdle;
long idleEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
PooledObject<T> underTest = null;
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
keyCopy.addAll(poolKeyList);
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis()) {
destroy(evictionKey, underTest);
} else {
if (testWhileIdle) {
boolean active = false;
try {
_factory.activateObject(evictionKey, underTest.getObject());
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest);
}
if (active) {
if (!_factory.validateObject(evictionKey, underTest.getObject())) {
destroy(evictionKey, underTest);
} else {
try {
_factory.passivateObject(evictionKey, underTest.getObject());
} catch (Exception e) {
destroy(evictionKey, underTest);
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}",0
5055,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
5056,private int maxSleeping;,0
5057,"@Override
public T borrowObject() throws Exception, NoSuchElementException, IllegalStateException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
return pool.borrowObject();
} finally {
writeLock.unlock();
}
}",0
5058,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5059,"public synchronized void clear() {
for (Iterator entries = _poolMap.entrySet().iterator(); entries.hasNext(); ) {
final Map.Entry entry = (Map.Entry) entries.next();
final Object key = entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (entry.getValue())).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
}
_poolMap.clear();
_poolList.clear();
_totalIdle = 0;
notifyAll();
}",0
5060,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
ObjectTimestampPair pair = null;
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
if (newlyCreated) {
pool.incrementActiveCount();
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
pool.incrementActiveCount();
return pair.value;
}
}
}
}",0
5061,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}",0
5062,"public void evict() throws Exception {
assertOpen();
if (_idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_evictionIterator == null || !_evictionIterator.hasNext()) {
if (getLifo()) {
_evictionIterator = _idleObjects.descendingIterator();
} else {
_evictionIterator = _idleObjects.iterator();
}
}
if (!_evictionIterator.hasNext()) {
return;
} else {
try {
underTest = _evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
_evictionIterator = null;
continue;
}
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (getMinEvictableIdleTimeMillis() > 0 && getMinEvictableIdleTimeMillis() < underTest.getIdleTimeMillis() || (getSoftMinEvictableIdleTimeMillis() > 0 && getSoftMinEvictableIdleTimeMillis() < underTest.getIdleTimeMillis() && getMinIdle() < _idleObjects.size())) {
destroy(underTest);
} else {
if (getTestWhileIdle()) {
boolean active = false;
try {
_factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
}
if (active) {
if (!_factory.validateObject(underTest.getObject())) {
destroy(underTest);
} else {
try {
_factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
}
}
}
}
if (!underTest.endEvictionTest()) {
}
}
}
return;
}",0
5063,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5064,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActiveOld--;
}
allocate();
}
}
}",0
5065,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
5066,"void cancel() {
scheduledFuture.cancel(false);
}",0
5067,"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0
5068,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
5069,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5070,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5071,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5072,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5073,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception e) {
}
}",0
5074,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTime(), getSoftMinEvictableIdleTime(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
5075,private int initIdleCapacity;,0
5076,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5077,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
5078,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5079,"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
boolean create;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
return p.getObject();
}",0
5080,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
5081,private int _maxSleeping = StackObjectPool.DEFAULT_MAX_SLEEPING;,0
5082,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5083,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5084,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5085,"@Override
public void passivateObject(final T obj) throws Exception {
writeLock.tryLock();
try {
factory.passivateObject(obj);
} finally {
writeLock.unlock();
}
}",0
5086,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5087,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5088,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5089,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5090,private int initIdleCapacity;,0
5091,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
5092,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5093,"@Override
public void addObject(final K key) throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.addObject(key);
} finally {
writeLock.unlock();
}
}",0
5094,"@Override
public void returnObject(final K key, final V obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
5095,"@Override
public void invalidateObject(final K key, final V obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
5096,"@Override
public void clear(final K key) throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.clear(key);
} finally {
writeLock.unlock();
}
}",0
5097,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
5098,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5099,"@Override
public boolean validateObject(final K key, final V obj) {
writeLock.tryLock();
try {
return keyedFactory.validateObject(key, obj);
} finally {
writeLock.unlock();
}
}",0
5100,"void cancel() {
scheduledFuture.cancel(false);
}",0
5101,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5102,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p.getObject());
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
5103,private int _minIdle = DEFAULT_MIN_IDLE;,0
5104,private GenericObjectPoolConfig config;,0
5105,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5106,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5107,"public synchronized void returnObject(Object key, Object obj) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
} else {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
success = false;
}
}
if (isClosed()) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
return;
}
boolean shouldDestroy = false;
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
}",0
5108,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTime(), getSoftMinEvictableIdleTime(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
5109,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
5110,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5111,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
5112,"public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
long idleSoftEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
if (getSoftMinEvictableIdleTimeMillis() > 0) {
idleSoftEvictTime = getSoftMinEvictableIdleTimeMillis();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis() || (idleSoftEvictTime < underTest.getIdleTimeMillis() && getMinIdle() < idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
return;
}",0
5113,"public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
5114,"@Override
public void addObject() throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.addObject();
} finally {
writeLock.unlock();
}
}",0
5115,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5116,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
ObjectTimestampPair pair = null;
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
if (newlyCreated) {
pool.incrementActiveCount();
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
pool.incrementActiveCount();
return pair.value;
}
}
}
}",0
5117,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5118,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
5119,"public synchronized void evict() throws Exception {
Object key = null;
if (_recentlyEvictedKeys == null) {
_recentlyEvictedKeys = new HashSet(_poolMap.size());
}
Set remainingKeys = new HashSet(_poolMap.keySet());
remainingKeys.removeAll(_recentlyEvictedKeys);
Iterator keyIter = remainingKeys.iterator();
ListIterator objIter = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap.size() > 0) {
if (key == null) {
if (!keyIter.hasNext()) {
_recentlyEvictedKeys.clear();
remainingKeys = new HashSet(_poolMap.keySet());
keyIter = remainingKeys.iterator();
}
if (!keyIter.hasNext()) {
return;
}
key = keyIter.next();
}
if (objIter == null) {
final LinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
if (_evictLastIndex < 0 || _evictLastIndex > list.size()) {
_evictLastIndex = list.size();
}
objIter = list.listIterator(_evictLastIndex);
}
if (objIter.hasPrevious()) {
ObjectTimestampPair pair = (ObjectTimestampPair) (objIter.previous());
boolean removeObject = false;
if (_minEvictableIdleTimeMillis > 0 && System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
objIter.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if ((_minIdle == 0) && (((ObjectQueue) (_poolMap.get(key))).queue.isEmpty())) {
_poolMap.remove(key);
}
} catch (Exception e) {
;
}
}
} else {
_recentlyEvictedKeys.add(key);
_evictLastIndex = -1;
objIter = null;
}
}
}
}",0
5120,"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0
5121,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e2) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",0
5122,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
5123,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5124,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5125,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
5126,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5127,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
5128,private int initIdleCapacity;,0
5129,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5130,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5131,"void cancel() {
scheduledFuture.cancel(false);
}",0
5132,private int _maxSleeping = StackKeyedObjectPool.DEFAULT_MAX_SLEEPING;,0
5133,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5134,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
5135,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final LinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final LinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
5136,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
5137,"@Override
public void clear() {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
5138,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5139,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5140,"@Override
public void evict() throws Exception {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5141,"public synchronized void evict() throws Exception {
Object key = null;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
boolean removeObject = false;
if ((_minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if (_minIdle == 0) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
if (objectQueue != null && objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
} catch (Exception e) {
}
}
}
}",0
5142,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}",0
5143,"@Override
public void returnObject(final T obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.returnObject(obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
5144,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5145,"@Override
public int getNumIdle(final K key) {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle(key);
} finally {
readLock.unlock();
}
}",0
5146,private long _maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;,0
5147,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5148,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
5149,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5150,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
5151,"@Override
public void destroyObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.destroyObject(key, obj);
} finally {
writeLock.unlock();
}
}",0
5152,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
5153,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0
5154,"@Override
public void clear(K key) {
ObjectDeque<T> objectDeque = poolMap.get(key);
if (objectDeque == null) {
return;
}
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",0
5155,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}",0
5156,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5157,"public synchronized void evict() throws Exception {
assertOpen();
if (!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0) && (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0) && (idleTimeMilis > _softMinEvictableIdleTimeMillis) && (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if (_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
}
}
}",0
5158,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5159,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
5160,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(final Object other) {
return ((IdentityWrapper) other).instance == instance;
}",0
5161,"public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
PooledObject<T> underTest = null;
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
keyCopy.addAll(poolKeyList);
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis()) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest.getObject());
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest.getObject())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest.getObject());
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}",0
5162,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
5163,"@Override
public void close() {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.close();
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
5164,private int _numTestsPerEvictionRun = GenericKeyedObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;,0
5165,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",0
5166,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5167,"@Override
@Deprecated
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
}
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}",0
5168,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
5169,private int initIdleCapacity;,0
5170,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5171,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5172,private int initIdleCapacity;,0
5173,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
5174,private GenericKeyedObjectPoolConfig config;,0
5175,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
5176,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}",0
5177,"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0
5178,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5179,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
5180,"@Override
public V borrowObject(final K key) throws Exception, NoSuchElementException, IllegalStateException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
return keyedPool.borrowObject(key);
} finally {
writeLock.unlock();
}
}",0
5181,"@Override
public void close() {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.close();
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
5182,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5183,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final K key = keyiter.next();
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final CursorableLinkedList<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
5184,"@Override
public void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
if (this._factory == null) {
synchronized (factoryLock) {
if (this._factory == null) {
this._factory = factory;
} else {
throw new IllegalStateException(""Factory already set"");
}
}
} else {
throw new IllegalStateException(""Factory already set"");
}
}",0
5185,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
5186,"@Override
public void activateObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.activateObject(key, obj);
} finally {
writeLock.unlock();
}
}",0
5187,"public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
boolean testWhileIdle = _testWhileIdle;
long idleEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
PooledObject<T> underTest = null;
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
keyCopy.addAll(poolKeyList);
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis()) {
destroy(evictionKey, underTest);
} else {
if (testWhileIdle) {
boolean active = false;
try {
_factory.activateObject(evictionKey, underTest.getObject());
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest);
}
if (active) {
if (!_factory.validateObject(evictionKey, underTest.getObject())) {
destroy(evictionKey, underTest);
} else {
try {
_factory.passivateObject(evictionKey, underTest.getObject());
} catch (Exception e) {
destroy(evictionKey, underTest);
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}",0
5188,"@Override
public void invalidateObject(final T obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.invalidateObject(obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",0
5189,"@Override
public int getNumActive(final K key) {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumActive(key);
} finally {
readLock.unlock();
}
}",0
5190,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
5191,"@Override
public void clear() throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.clear();
} finally {
writeLock.unlock();
}
}",0
5192,"@Override
public T borrowObject() throws Exception, NoSuchElementException, IllegalStateException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
return pool.borrowObject();
} finally {
writeLock.unlock();
}
}",0
5193,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5194,"public synchronized void clear() {
for (Iterator entries = _poolMap.entrySet().iterator(); entries.hasNext(); ) {
final Map.Entry entry = (Map.Entry) entries.next();
final Object key = entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (entry.getValue())).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
}
_poolMap.clear();
_poolList.clear();
_totalIdle = 0;
notifyAll();
}",0
5195,"@Override
public int getNumActive() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return pool.getNumActive();
} finally {
readLock.unlock();
}
}",0
5196,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
ObjectTimestampPair pair = null;
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
if (newlyCreated) {
pool.incrementActiveCount();
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
pool.incrementActiveCount();
return pair.value;
}
}
}
}",0
5197,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}",0
5198,"public void evict() throws Exception {
assertOpen();
if (_idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_evictionIterator == null || !_evictionIterator.hasNext()) {
if (getLifo()) {
_evictionIterator = _idleObjects.descendingIterator();
} else {
_evictionIterator = _idleObjects.iterator();
}
}
if (!_evictionIterator.hasNext()) {
return;
} else {
try {
underTest = _evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
_evictionIterator = null;
continue;
}
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (getMinEvictableIdleTimeMillis() > 0 && getMinEvictableIdleTimeMillis() < underTest.getIdleTimeMillis() || (getSoftMinEvictableIdleTimeMillis() > 0 && getSoftMinEvictableIdleTimeMillis() < underTest.getIdleTimeMillis() && getMinIdle() < _idleObjects.size())) {
destroy(underTest);
} else {
if (getTestWhileIdle()) {
boolean active = false;
try {
_factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
}
if (active) {
if (!_factory.validateObject(underTest.getObject())) {
destroy(underTest);
} else {
try {
_factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
}
}
}
}
if (!underTest.endEvictionTest()) {
}
}
}
return;
}",0
5199,"@Override
public void destroyObject(final T obj) throws Exception {
writeLock.tryLock();
try {
factory.destroyObject(obj);
} finally {
writeLock.unlock();
}
}",0
5200,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
5201,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActiveOld--;
}
allocate();
}
}
}",0
5202,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
5203,"void cancel() {
scheduledFuture.cancel(false);
}",0
5204,"@Override
public void passivateObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.passivateObject(key, obj);
} finally {
writeLock.unlock();
}
}",0
5205,"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0
5206,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
5207,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5208,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5209,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5210,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5211,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception e) {
}
}",0
5212,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTime(), getSoftMinEvictableIdleTime(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
5213,private int initIdleCapacity;,0
5214,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5215,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
5216,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5217,"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
boolean create;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
return p.getObject();
}",0
5218,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
5219,private int _maxSleeping = StackObjectPool.DEFAULT_MAX_SLEEPING;,0
5220,protected int _totIdle = 0;,1
5221,"private long getMeanFromStatsCache(LinkedList<Long> cache) {
List<Long> times = new ArrayList<Long>(AVERAGE_TIMING_STATS_CACHE_SIZE);
synchronized (cache) {
times.addAll(cache);
}
double result = 0;
int counter = 0;
Iterator<Long> iter = times.iterator();
while (iter.hasNext()) {
Long time = iter.next();
if (time != null) {
counter++;
result = result * ((counter - 1) / counter) + time.longValue() / counter;
}
}
return (long) result;
}",1
5222,"public PoolableObjectFactory getFactory() {
return _factory;
}",1
5223,"private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if (null == old) {
_activeCount.put(key, new Integer(1));
} else {
_activeCount.put(key, new Integer(old.intValue() + 1));
}
}",1
5224,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",1
5225,private int initIdleCapacity;,1
5226,private int maxSleeping;,1
5227,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
final PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (final Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",1
5228,"@Override
public int getNumIdle() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle();
} finally {
readLock.unlock();
}
}",1
5229,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5230,private int _totalIdle = 0;,1
5231,"@Override
public boolean validateObject(final K key, final V obj) {
writeLock.tryLock();
try {
return keyedFactory.validateObject(key, obj);
} finally {
writeLock.unlock();
}
}",1
5232,"private long getMeanFromStatsCache(LinkedList<Long> cache) {
List<Long> times = new ArrayList<Long>(AVERAGE_TIMING_STATS_CACHE_SIZE);
synchronized (cache) {
times.addAll(cache);
}
double result = 0;
int counter = 0;
Iterator<Long> iter = times.iterator();
while (iter.hasNext()) {
Long time = iter.next();
if (time != null) {
counter++;
result = result * ((counter - 1) / counter) + time.longValue() / counter;
}
}
return (long) result;
}",1
5233,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
5234,"@Override
public void activateObject(final T obj) throws Exception {
writeLock.tryLock();
try {
factory.activateObject(obj);
} finally {
writeLock.unlock();
}
}",1
5235,private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;,1
5236,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",1
5237,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5238,"@Override
public int getNumActive() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumActive();
} finally {
readLock.unlock();
}
}",1
5239,protected int _totIdle = 0;,1
5240,"@Override
public int getNumIdle() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return pool.getNumIdle();
} finally {
readLock.unlock();
}
}",1
5241,"@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + t.getMessage());
}
}
}
}
_numActive++;
return obj;
}",1
5242,"@Override
public V makeObject(final K key) throws Exception {
writeLock.tryLock();
try {
return keyedFactory.makeObject(key);
} finally {
writeLock.unlock();
}
}",1
5243,"@Override
public void returnObject(T obj) {
PooledObject<T> p = allObjects.get(obj);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(obj)) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(obj);
} catch (Exception e1) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdle();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(p);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
updateStatsReturn(activeTime);
}",1
5244,"private void destroy(PooledObject<T> toDestory) {
_idleObjects.remove(toDestory);
try {
_factory.destroyObject(toDestory.getObject());
} catch (Exception e) {
}
}",1
5245,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
5246,private PoolableObjectFactory _factory = null;,1
5247,"@Override
public boolean validateObject(final T obj) {
writeLock.tryLock();
try {
return factory.validateObject(obj);
} finally {
writeLock.unlock();
}
}",1
5248,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
}
if (destroyed) {
itemsToRemove--;
}
}
}",1
5249,protected int _totActive = 0;,1
5250,"@Override
public void clear(K key) {
ObjectDeque<T> objectDeque = register(key);
try {
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
p = idleObjects.poll();
}
} finally {
deregister(key);
}
}",1
5251,"@Override
public T makeObject() throws Exception {
writeLock.tryLock();
try {
return factory.makeObject();
} finally {
writeLock.unlock();
}
}",1
5252,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",1
5253,"@Override
public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (getTestOnReturn()) {
if (!_factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
return;
}
}
try {
_factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
return;
}
if (!p.deallocate()) {
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
}",1
5254,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
5255,"@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll();
}",1
5256,"@Override
public void clear() throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.clear();
} finally {
writeLock.unlock();
}
}",1
5257,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(final Object other) {
return ((IdentityWrapper) other).instance == instance;
}",1
5258,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",1
5259,"@Override
public Map<String, Integer> getNumWaitersByKey() {
final Map<String, Integer> result = new HashMap<String, Integer>();
for (final K key : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",1
5260,"@Override
public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
if (hasBorrowWaiters()) {
reuseCapacity();
}
updateStatsReturn(activeTime);
}",1
5261,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
final Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (final K key : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
final List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (final PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",1
5262,"private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if (null == active) {
} else if (active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}",1
5263,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",1
5264,"@Override
public void returnObject(final T obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.returnObject(obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",1
5265,"@Override
public int getNumIdle(final K key) {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle(key);
} finally {
readLock.unlock();
}
}",1
5266,"@Override
public void destroyObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.destroyObject(key, obj);
} finally {
writeLock.unlock();
}
}",1
5267,protected PoolableObjectFactory _factory = null;,1
5268,"@Override
public void close() {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.close();
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",1
5269,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",1
5270,"public JdkProxySource(ClassLoader classLoader, Class<?>[] interfaces) {
this.classLoader = classLoader;
this.interfaces = interfaces;
}",1
5271,private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;,1
5272,private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;,1
5273,private int initIdleCapacity;,1
5274,private int maxSleeping;,1
5275,"@SuppressWarnings(""null"")
public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",1
5276,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (final PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
final Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
final Map.Entry<PooledObject<T>, K> entry = iter.next();
final K key = entry.getValue();
final PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (final Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",1
5277,"@Override
public V borrowObject(final K key) throws Exception, NoSuchElementException, IllegalStateException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
return keyedPool.borrowObject(key);
} finally {
writeLock.unlock();
}
}",1
5278,"@Override
public void close() {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.close();
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",1
5279,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final K key = keyiter.next();
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final CursorableLinkedList<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",1
5280,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",1
5281,"@Override
public void activateObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.activateObject(key, obj);
} finally {
writeLock.unlock();
}
}",1
5282,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",1
5283,"@Override
public void invalidateObject(final T obj) {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.invalidateObject(obj);
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",1
5284,"@Override
public int getNumActive(final K key) {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumActive(key);
} finally {
readLock.unlock();
}
}",1
5285,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",1
5286,"@Override
public void clear() throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.clear();
} finally {
writeLock.unlock();
}
}",1
5287,"private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext(); ) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext(); ) {
try {
factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
} finally {
synchronized (this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}",1
5288,private int initIdleCapacity;,1
5289,"private void removeAbandoned() {
final long now = System.currentTimeMillis();
final long timeout = now - (abandonedConfig.getRemoveAbandonedTimeout() * 1000);
ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>();
Iterator<PooledObject<T>> it = allObjects.values().iterator();
while (it.hasNext()) {
PooledObject<T> pooledObject = it.next();
synchronized (pooledObject) {
if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsed() <= timeout) {
pooledObject.markAbandoned();
remove.add(pooledObject);
}
}
}
Iterator<PooledObject<T>> itr = remove.iterator();
while (itr.hasNext()) {
PooledObject<T> pooledObject = itr.next();
if (abandonedConfig.getLogAbandoned()) {
pooledObject.printStackTrace();
}
try {
invalidateObject(pooledObject.getObject());
} catch (Exception e) {
e.printStackTrace();
}
}
}",1
5290,"private boolean hasBorrowWaiters() {
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",1
5291,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
5292,"public PoolableObjectFactory getFactory() {
return _factory;
}",1
5293,"@Override
public int getNumActive() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return pool.getNumActive();
} finally {
readLock.unlock();
}
}",1
5294,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
for (K key : _poolMap.keySet()) {
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",1
5295,protected int _totIdle = 0;,1
5296,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5297,"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",1
5298,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",1
5299,"@Override
public void destroyObject(final T obj) throws Exception {
writeLock.tryLock();
try {
factory.destroyObject(obj);
} finally {
writeLock.unlock();
}
}",1
5300,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",1
5301,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
5302,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",1
5303,"@Override
public void passivateObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.passivateObject(key, obj);
} finally {
writeLock.unlock();
}
}",1
5304,private Exception borrowedBy = null;,1
5305,"@Override
public void returnObject(T obj) {
PooledObject<T> p = _allObjects.get(obj);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (getTestOnReturn()) {
if (!_factory.validateObject(obj)) {
try {
destroy(p);
} catch (Exception e) {
}
return;
}
}
try {
_factory.passivateObject(obj);
} catch (Exception e1) {
try {
destroy(p);
} catch (Exception e) {
}
return;
}
if (!p.deallocate()) {
}
int maxIdle = getMaxIdle();
if (isClosed() || maxIdle > -1 && maxIdle <= _idleObjects.size()) {
try {
destroy(p);
} catch (Exception e) {
}
} else {
if (getLifo()) {
_idleObjects.addFirst(p);
} else {
_idleObjects.addLast(p);
}
}
}",1
5306,"private PooledObject<T> create(K key, boolean force) throws Exception {
int maxActive = getMaxActive();
int maxTotal = getMaxTotal();
boolean loop = true;
while (loop) {
int newNumTotal = numTotal.incrementAndGet();
if (!force && maxTotal > -1 && newNumTotal > maxTotal) {
numTotal.decrementAndGet();
if (getNumIdle() == 0) {
return null;
} else {
clearOldest();
}
} else {
loop = false;
}
}
ObjectDeque<T> objectDeque;
int newNumActive;
synchronized (poolMap) {
objectDeque = poolMap.get(key);
if (objectDeque == null) {
objectDeque = new ObjectDeque<T>();
newNumActive = objectDeque.getNumActive().incrementAndGet();
poolMap.put(key, objectDeque);
poolKeyList.add(key);
} else {
newNumActive = objectDeque.getNumActive().incrementAndGet();
}
}
if (!force && maxActive > -1 && newNumActive > maxActive) {
cleanObjectDeque(key, objectDeque);
numTotal.decrementAndGet();
return null;
}
T t = null;
try {
t = _factory.makeObject(key);
} catch (Exception e) {
cleanObjectDeque(key, objectDeque);
numTotal.decrementAndGet();
throw e;
}
PooledObject<T> p = new PooledObject<T>(t);
objectDeque.getAllObjects().put(t, p);
return p;
}",1
5307,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5308,private SoftReference<T> reference;,1
5309,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
5310,private int initIdleCapacity;,1
5311,"@Override
public void clear() {
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",1
5312,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= this.maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",1
5313,protected int _totIdle = 0;,1
5314,"private long getMeanFromStatsCache(LinkedList<Long> cache) {
List<Long> times = new ArrayList<Long>(AVERAGE_TIMING_STATS_CACHE_SIZE);
synchronized (cache) {
times.addAll(cache);
}
double result = 0;
int counter = 0;
Iterator<Long> iter = times.iterator();
while (iter.hasNext()) {
Long time = iter.next();
if (time != null) {
counter++;
result = result * ((counter - 1) / counter) + time.longValue() / counter;
}
}
return (long) result;
}",1
5315,"public PoolableObjectFactory getFactory() {
return _factory;
}",1
5316,"private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if (null == old) {
_activeCount.put(key, new Integer(1));
} else {
_activeCount.put(key, new Integer(old.intValue() + 1));
}
}",1
5317,private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;,1
5318,private int maxSleeping;,1
5319,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
final PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (final Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",1
5320,"@Override
public int getNumIdle() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle();
} finally {
readLock.unlock();
}
}",1
5321,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5322,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5323,private int _totalIdle = 0;,1
5324,"private long getMeanFromStatsCache(LinkedList<Long> cache) {
List<Long> times = new ArrayList<Long>(AVERAGE_TIMING_STATS_CACHE_SIZE);
synchronized (cache) {
times.addAll(cache);
}
double result = 0;
int counter = 0;
Iterator<Long> iter = times.iterator();
while (iter.hasNext()) {
Long time = iter.next();
if (time != null) {
counter++;
result = result * ((counter - 1) / counter) + time.longValue() / counter;
}
}
return (long) result;
}",1
5325,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
5326,"@Override
public void activateObject(final T obj) throws Exception {
writeLock.tryLock();
try {
factory.activateObject(obj);
} finally {
writeLock.unlock();
}
}",1
5327,private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;,1
5328,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
if (_factory.validateObject(key, obj)) {
_factory.passivateObject(key, obj);
} else {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",1
5329,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5330,"@Override
public int getNumActive() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumActive();
} finally {
readLock.unlock();
}
}",1
5331,protected int _totIdle = 0;,1
5332,"@Override
public int getNumIdle() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return pool.getNumIdle();
} finally {
readLock.unlock();
}
}",1
5333,"@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + t.getMessage());
}
}
}
}
_numActive++;
return obj;
}",1
5334,"@Override
public V makeObject(final K key) throws Exception {
writeLock.tryLock();
try {
return keyedFactory.makeObject(key);
} finally {
writeLock.unlock();
}
}",1
5335,"@Override
public void returnObject(T obj) {
PooledObject<T> p = allObjects.get(obj);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(obj)) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(obj);
} catch (Exception e1) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdle();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(p);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
updateStatsReturn(activeTime);
}",1
5336,"private void destroy(PooledObject<T> toDestory) {
_idleObjects.remove(toDestory);
try {
_factory.destroyObject(toDestory.getObject());
} catch (Exception e) {
}
}",1
5337,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
5338,private PoolableObjectFactory _factory = null;,1
5339,"@Override
public boolean validateObject(final T obj) {
writeLock.tryLock();
try {
return factory.validateObject(obj);
} finally {
writeLock.unlock();
}
}",1
5340,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
}
if (destroyed) {
itemsToRemove--;
}
}
}",1
5341,protected int _totActive = 0;,1
5342,"@Override
public void clear(K key) {
ObjectDeque<T> objectDeque = register(key);
try {
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
p = idleObjects.poll();
}
} finally {
deregister(key);
}
}",1
5343,"@Override
public T makeObject() throws Exception {
writeLock.tryLock();
try {
return factory.makeObject();
} finally {
writeLock.unlock();
}
}",1
5344,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",1
5345,"@Override
public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (getTestOnReturn()) {
if (!_factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
return;
}
}
try {
_factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
return;
}
if (!p.deallocate()) {
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
}",1
5346,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
5347,"@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll();
}",1
5348,"@Override
public void clear() throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
keyedPool.clear();
} finally {
writeLock.unlock();
}
}",1
5349,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(final Object other) {
return ((IdentityWrapper) other).instance == instance;
}",1
5350,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",1
5351,"@Override
public Map<String, Integer> getNumWaitersByKey() {
final Map<String, Integer> result = new HashMap<String, Integer>();
for (final K key : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",1
5352,"@Override
public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
if (hasBorrowWaiters()) {
reuseCapacity();
}
updateStatsReturn(activeTime);
}",1
5353,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
final Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (final K key : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
final List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (final PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",1
5354,"private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if (null == active) {
} else if (active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}",1
5355,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",1
5356,protected PoolableObjectFactory _factory = null;,1
5357,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
5358,"public JdkProxySource(ClassLoader classLoader, Class<?>[] interfaces) {
this.classLoader = classLoader;
this.interfaces = interfaces;
}",1
5359,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
5360,private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;,1
5361,private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;,1
5362,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
5363,private int maxSleeping;,1
5364,private int maxSleeping;,1
5365,"@SuppressWarnings(""null"")
public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",1
5366,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (final PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
final Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
final Map.Entry<PooledObject<T>, K> entry = iter.next();
final K key = entry.getValue();
final PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (final Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",1
5367,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",1
5368,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",1
5369,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",1
5370,private int maxSleeping;,1
5371,"private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext(); ) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext(); ) {
try {
factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
} finally {
synchronized (this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}",1
5372,private int initIdleCapacity;,1
5373,"private void removeAbandoned() {
final long now = System.currentTimeMillis();
final long timeout = now - (abandonedConfig.getRemoveAbandonedTimeout() * 1000);
ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>();
Iterator<PooledObject<T>> it = allObjects.values().iterator();
while (it.hasNext()) {
PooledObject<T> pooledObject = it.next();
synchronized (pooledObject) {
if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsed() <= timeout) {
pooledObject.markAbandoned();
remove.add(pooledObject);
}
}
}
Iterator<PooledObject<T>> itr = remove.iterator();
while (itr.hasNext()) {
PooledObject<T> pooledObject = itr.next();
if (abandonedConfig.getLogAbandoned()) {
pooledObject.printStackTrace();
}
try {
invalidateObject(pooledObject.getObject());
} catch (Exception e) {
e.printStackTrace();
}
}
}",1
5374,"private boolean hasBorrowWaiters() {
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",1
5375,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
5376,"public PoolableObjectFactory getFactory() {
return _factory;
}",1
5377,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
for (K key : _poolMap.keySet()) {
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",1
5378,protected int _totIdle = 0;,1
5379,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5380,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",1
5381,"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",1
5382,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
5383,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",1
5384,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",1
5385,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",1
5386,private Exception borrowedBy = null;,1
5387,"@Override
public void returnObject(T obj) {
PooledObject<T> p = _allObjects.get(obj);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (getTestOnReturn()) {
if (!_factory.validateObject(obj)) {
try {
destroy(p);
} catch (Exception e) {
}
return;
}
}
try {
_factory.passivateObject(obj);
} catch (Exception e1) {
try {
destroy(p);
} catch (Exception e) {
}
return;
}
if (!p.deallocate()) {
}
int maxIdle = getMaxIdle();
if (isClosed() || maxIdle > -1 && maxIdle <= _idleObjects.size()) {
try {
destroy(p);
} catch (Exception e) {
}
} else {
if (getLifo()) {
_idleObjects.addFirst(p);
} else {
_idleObjects.addLast(p);
}
}
}",1
5388,"private PooledObject<T> create(K key, boolean force) throws Exception {
int maxActive = getMaxActive();
int maxTotal = getMaxTotal();
boolean loop = true;
while (loop) {
int newNumTotal = numTotal.incrementAndGet();
if (!force && maxTotal > -1 && newNumTotal > maxTotal) {
numTotal.decrementAndGet();
if (getNumIdle() == 0) {
return null;
} else {
clearOldest();
}
} else {
loop = false;
}
}
ObjectDeque<T> objectDeque;
int newNumActive;
synchronized (poolMap) {
objectDeque = poolMap.get(key);
if (objectDeque == null) {
objectDeque = new ObjectDeque<T>();
newNumActive = objectDeque.getNumActive().incrementAndGet();
poolMap.put(key, objectDeque);
poolKeyList.add(key);
} else {
newNumActive = objectDeque.getNumActive().incrementAndGet();
}
}
if (!force && maxActive > -1 && newNumActive > maxActive) {
cleanObjectDeque(key, objectDeque);
numTotal.decrementAndGet();
return null;
}
T t = null;
try {
t = _factory.makeObject(key);
} catch (Exception e) {
cleanObjectDeque(key, objectDeque);
numTotal.decrementAndGet();
throw e;
}
PooledObject<T> p = new PooledObject<T>(t);
objectDeque.getAllObjects().put(t, p);
return p;
}",1
5389,private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
5390,private SoftReference<T> reference;,1
5391,private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
5392,private int initIdleCapacity;,1
5393,"@Override
public void clear() {
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",1
5394,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= this.maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",1
5395,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5396,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5397,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5398,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5399,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5400,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
5401,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
5402,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
5403,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
5404,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
5405,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
5406,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
5407,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
5408,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
5409,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
5410,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5411,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
5412,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
5413,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5414,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5415,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5416,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5417,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5418,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
5419,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
5420,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
5421,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
5422,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
5423,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
5424,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
5425,"private void reuseCapacity() {
final int maxTotalPerKey = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKey && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
5426,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
5427,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
5428,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
5429,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
5430,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5431,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5432,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5433,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5434,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5435,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5436,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5437,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5438,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5439,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5440,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5441,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5442,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5443,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5444,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5445,"public void returnObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5446,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5447,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5448,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5449,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5450,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5451,"// --- protected methods ------------------------------------------
@Override
protected Listable<E> insertListable(Listable<E> before, Listable<E> after, E value) {
_modCount++;
_size++;
Listable<E> elt = _list.insertListable((null == before ? _pre : before), (null == after ? _post : after), value);
if (null == _head.next()) {
_head.setNext(elt);
_head.setPrev(elt);
}
if (before == _head.prev()) {
_head.setPrev(elt);
}
if (after == _head.next()) {
_head.setNext(elt);
}
broadcastListableInserted(elt);
return elt;
}",0
5452,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
5453,"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5454,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5455,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5456,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5457,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5458,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5459,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5460,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5461,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
5462,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5463,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5464,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
5465,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5466,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5467,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5468,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5469,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5470,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5471,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5472,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5473,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5474,"@Deprecated
protected int _totActive = 0;",0
5475,"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0
5476,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5477,"@Deprecated
protected int _totIdle = 0;",0
5478,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5479,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5480,"@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5481,"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5482,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5483,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5484,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5485,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5486,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5487,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5488,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5489,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5490,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5491,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5492,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5493,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5494,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5495,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5496,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5497,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5498,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5499,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5500,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5501,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5502,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5503,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5504,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5505,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5506,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5507,"private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext(); ) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
} finally {
synchronized (this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}",0
5508,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5509,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
5510,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5511,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5512,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}",0
5513,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5514,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}",0
5515,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
// Do nothing
}
}
}",0
5516,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5517,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
5518,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5519,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}",0
5520,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5521,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5522,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
5523,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
5524,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
5525,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5526,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5527,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
5528,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5529,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5530,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5531,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5532,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5533,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5534,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5535,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5536,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
5537,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5538,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5539,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5540,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5541,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5542,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5543,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5544,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5545,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5546,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5547,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5548,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5549,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5550,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5551,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5552,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5553,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5554,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5555,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5556,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5557,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5558,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5559,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5560,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5561,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5562,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5563,"protected void listableChanged(Listable elt) {
if (_lastReturned == elt) {
_lastReturned = null;
}
}",0
5564,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
5565,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5566,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5567,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
5568,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5569,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5570,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5571,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5572,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5573,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
5574,"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
5575,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5576,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5577,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5578,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5579,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
5580,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5581,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5582,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5583,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5584,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5585,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
5586,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5587,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5588,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5589,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5590,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5591,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5592,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5593,protected int _totIdle = 0;,0
5594,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5595,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5596,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5597,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5598,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
5599,protected int _totActive = 0;,0
5600,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5601,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5602,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5603,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5604,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5605,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5606,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5607,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5608,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5609,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5610,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5611,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5612,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5613,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5614,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5615,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5616,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5617,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5618,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5619,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5620,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5621,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5622,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5623,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5624,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5625,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5626,"void setPrev(Listable prev) {
_prev = prev;
}",0
5627,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
5628,"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
5629,"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
5630,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5631,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5632,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
5633,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5634,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5635,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
5636,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5637,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
5638,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5639,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5640,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5641,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5642,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5643,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5644,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5645,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5646,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.remove();
synchronized (l) {
l.notify();
}
}
}
}",0
5647,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5648,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
5649,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5650,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5651,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5652,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5653,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5654,protected int _totIdle = 0;,0
5655,protected int _totIdle = 0;,0
5656,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5657,protected int _totActive = 0;,0
5658,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5659,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
5660,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5661,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5662,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5663,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5664,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5665,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5666,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5667,"public void returnObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5668,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5669,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5670,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5671,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5672,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5673,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5674,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5675,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5676,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5677,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5678,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5679,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5680,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5681,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5682,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5683,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5684,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5685,"@Override
public <T> T[] toArray(T[] a) {
checkForComod();
return super.toArray(a);
}",0
5686,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
5687,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5688,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5689,"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5690,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
5691,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final K key = keyiter.next();
final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set<Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final List<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
5692,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5693,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5694,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5695,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5696,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5697,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5698,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5699,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5700,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5701,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5702,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
5703,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5704,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5705,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5706,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5707,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5708,"@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5709,"@Deprecated
protected int _totIdle = 0;",0
5710,"@Deprecated
protected int _totActive = 0;",0
5711,"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0
5712,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5713,"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5714,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5715,"@Override
public synchronized void invalidateObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
_factory.destroyObject(key, obj);
}
notifyAll();
}",0
5716,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5717,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5718,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5719,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5720,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5721,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5722,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5723,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5724,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5725,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5726,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5727,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5728,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5729,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5730,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5731,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5732,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5733,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5734,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5735,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5736,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5737,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5738,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5739,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5740,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5741,"protected void broadcastListableInserted(Listable elt) {
Iterator it = _cursors.iterator();
while (it.hasNext()) {
WeakReference ref = (WeakReference) it.next();
Cursor cursor = (Cursor) ref.get();
if (cursor == null) {
it.remove();
} else {
cursor.listableInserted(elt);
}
}
}",0
5742,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5743,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
5744,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
5745,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5746,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5747,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5748,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5749,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
5750,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
5751,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5752,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5753,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5754,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5755,"public synchronized void clear() {
if (null != _factory) {
Iterator iter = _pool.iterator();
while (iter.hasNext()) {
try {
Object obj = ((SoftReference) iter.next()).get();
if (null != obj) {
_factory.destroyObject(obj);
}
} catch (Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}",0
5756,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5757,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5758,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5759,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5760,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
5761,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5762,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5763,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5764,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5765,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5766,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5767,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5768,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5769,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5770,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5771,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5772,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5773,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5774,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5775,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5776,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5777,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5778,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5779,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5780,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5781,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5782,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5783,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5784,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5785,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5786,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5787,"public void close() {
if (_valid) {
_valid = false;
unregisterCursor(this);
}
}",0
5788,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5789,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
5790,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
5791,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
5792,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5793,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5794,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
5795,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
5796,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5797,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
5798,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5799,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5800,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5801,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
5802,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
5803,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
5804,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5805,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
5806,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5807,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5808,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5809,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5810,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5811,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
5812,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
5813,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5814,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5815,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5816,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5817,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5818,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5819,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5820,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5821,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5822,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5823,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5824,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5825,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5826,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5827,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5828,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5829,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5830,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5831,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5832,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5833,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5834,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5835,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5836,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5837,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5838,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5839,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5840,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5841,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
5842,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5843,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
5844,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5845,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5846,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
5847,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5848,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5849,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5850,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
5851,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
5852,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5853,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5854,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5855,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5856,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
5857,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5858,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5859,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5860,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5861,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5862,"public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5863,"public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5864,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5865,protected int _totActive = 0;,0
5866,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
5867,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5868,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5869,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5870,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5871,protected int _totIdle = 0;,0
5872,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5873,"public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5874,"public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5875,"public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5876,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5877,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5878,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5879,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5880,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5881,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5882,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5883,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5884,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5885,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5886,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5887,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5888,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5889,"public void returnObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5890,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5891,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5892,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5893,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5894,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5895,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5896,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5897,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5898,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5899,"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0
5900,"@Deprecated
@Override
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
}
}
destroy(toDestroy, oldFactory);
}",0
5901,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
5902,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final K key = keyiter.next();
final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set<Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final List<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
5903,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
5904,"@Override
public void clear() {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
5905,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) {
return;
}
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5906,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5907,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5908,private ClassLoader _factoryClassLoader = null;,0
5909,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) {
return;
}
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5910,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5911,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5912,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5913,"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5914,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5915,"private synchronized void allocate() {
if (isClosed()) {
return;
}
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5916,private ClassLoader _factoryClassLoader = null;,0
5917,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5918,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5919,"private synchronized void allocate() {
if (isClosed()) {
return;
}
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5920,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5921,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.getTstamp();
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.getValue());
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.getValue())) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.getValue());
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.getValue());
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
5922,"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0
5923,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5924,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5925,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
5926,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5927,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5928,"@Deprecated
protected int _totIdle = 0;",0
5929,"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5930,"@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5931,"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0
5932,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5933,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5934,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5935,"@Deprecated
protected int _totActive = 0;",0
5936,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5937,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5938,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5939,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5940,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5941,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
5942,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5943,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
5944,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5945,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5946,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
5947,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5948,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5949,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5950,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
5951,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
5952,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5953,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
5954,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5955,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
5956,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
5957,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
5958,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
5959,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
5960,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
5961,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
_size = 0;
_modCount = 0;
_cursors = new ArrayList();
_head = new Listable(null, null, null);
int size = in.readInt();
for (int i = 0; i < size; i++) {
this.add(in.readObject());
}
}",0
5962,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5963,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
5964,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
5965,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5966,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
5967,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
5968,"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
5969,"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
5970,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
5971,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
5972,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
5973,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
5974,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5975,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
5976,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5977,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
5978,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5979,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
5980,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
5981,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
5982,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
5983,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
5984,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5985,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5986,"public synchronized void clear() {
if (null != _factory) {
Iterator iter = _pool.iterator();
while (iter.hasNext()) {
try {
Object obj = ((SoftReference) iter.next()).get();
if (null != obj) {
_factory.destroyObject(obj);
}
} catch (Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}",0
5987,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
5988,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
5989,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
5990,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
5991,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
5992,protected int _totIdle = 0;,0
5993,protected int _totActive = 0;,0
5994,protected int _totActive = 0;,0
5995,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5996,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5997,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
5998,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
5999,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6000,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6001,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6002,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6003,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6004,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6005,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6006,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6007,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6008,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6009,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6010,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6011,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6012,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6013,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6014,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6015,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6016,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6017,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6018,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6019,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6020,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
// Do nothing
}
}
}",0
6021,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6022,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6023,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
6024,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6025,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6026,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6027,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6028,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6029,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6030,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6031,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6032,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6033,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6034,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6035,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6036,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6037,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6038,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6039,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6040,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6041,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6042,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6043,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6044,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6045,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6046,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6047,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6048,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6049,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6050,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
6051,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
6052,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6053,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
6054,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6055,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
6056,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
6057,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6058,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
6059,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6060,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6061,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6062,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6063,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6064,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6065,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6066,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6067,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6068,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
6069,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6070,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
6071,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
6072,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
6073,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6074,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
6075,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
6076,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6077,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6078,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6079,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6080,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6081,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6082,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6083,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6084,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6085,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6086,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6087,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6088,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6089,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6090,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6091,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6092,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6093,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6094,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6095,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6096,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6097,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6098,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6099,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6100,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6101,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6102,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6103,"protected void broadcastListableRemoved(Listable elt) {
Iterator it = _cursors.iterator();
while (it.hasNext()) {
WeakReference ref = (WeakReference) it.next();
Cursor cursor = (Cursor) ref.get();
if (cursor == null) {
it.remove();
} else {
cursor.listableRemoved(elt);
}
}
}",0
6104,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6105,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6106,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6107,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6108,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}",0
6109,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
6110,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6111,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6112,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6113,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6114,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6115,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6116,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6117,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6118,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6119,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6120,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6121,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6122,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6123,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6124,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6125,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6126,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6127,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6128,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6129,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6130,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6131,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6132,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
6133,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
6134,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6135,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
6136,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6137,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6138,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
6139,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
6140,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
6141,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
6142,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
6143,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6144,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6145,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6146,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6147,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6148,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6149,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6150,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6151,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6152,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6153,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6154,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6155,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6156,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6157,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6158,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6159,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6160,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6161,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6162,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6163,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6164,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6165,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6166,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6167,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6168,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6169,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
6170,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6171,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6172,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6173,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6174,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6175,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6176,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6177,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6178,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6179,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6180,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6181,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6182,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6183,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6184,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6185,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6186,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6187,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6188,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6189,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6190,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6191,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6192,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6193,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6194,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6195,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6196,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6197,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6198,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6199,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6200,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6201,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6202,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6203,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6204,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6205,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6206,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6207,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6208,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6209,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6210,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6211,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6212,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6213,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
6214,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
6215,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6216,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6217,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6218,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
6219,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6220,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6221,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6222,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
6223,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6224,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
6225,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6226,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
6227,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6228,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6229,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6230,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6231,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6232,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6233,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6234,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6235,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6236,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6237,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6238,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6239,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6240,protected int _totIdle = 0;,0
6241,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6242,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6243,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6244,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6245,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6246,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6247,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6248,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6249,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6250,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6251,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6252,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6253,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6254,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6255,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6256,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6257,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6258,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6259,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6260,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6261,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6262,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6263,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6264,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6265,"private void writeObject(ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeInt(_size);
Listable cur = _head.next();
while (cur != null) {
out.writeObject(cur.value());
cur = cur.next();
}
}",0
6266,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6267,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6268,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
6269,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
6270,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6271,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
6272,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6273,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6274,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
6275,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6276,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6277,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
6278,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
6279,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6280,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6281,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
6282,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6283,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6284,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6285,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6286,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6287,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6288,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6289,protected int _totActive = 0;,0
6290,protected int _totIdle = 0;,0
6291,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6292,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6293,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6294,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6295,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6296,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6297,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6298,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6299,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6300,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6301,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6302,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6303,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6304,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6305,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6306,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6307,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
6308,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
6309,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
6310,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
6311,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6312,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
6313,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6314,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
6315,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6316,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6317,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6318,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6319,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6320,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6321,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6322,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6323,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6324,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6325,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6326,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6327,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6328,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6329,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6330,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6331,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6332,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6333,"public void returnObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6334,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6335,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6336,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6337,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6338,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6339,"// --- public methods ------------------------------------------
@Override
public void clear() {
checkForComod();
Iterator<E> it = iterator();
while (it.hasNext()) {
it.next();
it.remove();
}
}",0
6340,"@Override
public void clear() {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
6341,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
6342,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6343,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6344,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6345,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6346,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6347,"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6348,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
6349,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6350,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final K key = keyiter.next();
final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set<Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final List<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
6351,"@Deprecated
@Override
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
6352,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
6353,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
6354,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
6355,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
6356,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6357,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6358,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6359,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
6360,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6361,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6362,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
6363,"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
6364,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6365,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6366,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6367,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6368,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6369,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6370,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6371,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6372,"private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if (null == old) {
_activeCount.put(key, new Integer(1));
} else {
_activeCount.put(key, new Integer(old.intValue() + 1));
}
}",0
6373,"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6374,"@Deprecated
protected int _totIdle = 0;",0
6375,"private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if (null == active) {
} else if (active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}",0
6376,"@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6377,"@Deprecated
protected int _totActive = 0;",0
6378,"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0
6379,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6380,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6381,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6382,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6383,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6384,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6385,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6386,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6387,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6388,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6389,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6390,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6391,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6392,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6393,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6394,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6395,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6396,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6397,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6398,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6399,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6400,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6401,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6402,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6403,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6404,"private void writeObject(ObjectOutputStream out) throws IOException {
out.defaultWriteObject();
out.writeInt(_size);
Listable cur = _head.next();
while (cur != null) {
out.writeObject(cur.value());
cur = cur.next();
}
}",0
6405,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6406,"public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
// set the classloader for the factory
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
// Evict from the pool
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
// Re-create idle instances.
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
// restore the previous CCL
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0
6407,"public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0
6408,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6409,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
6410,private ClassLoader _factoryClassLoader = null;,0
6411,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
6412,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6413,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
6414,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6415,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6416,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
6417,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
6418,"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
6419,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
6420,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
}
}
destroy(toDestroy, oldFactory);
}",0
6421,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6422,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
6423,"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0
6424,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6425,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6426,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
6427,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6428,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6429,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6430,private ClassLoader _factoryClassLoader = null;,0
6431,"public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0
6432,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6433,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6434,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6435,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6436,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6437,protected int _totActive = 0;,0
6438,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6439,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6440,protected int _totIdle = 0;,0
6441,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6442,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6443,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6444,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6445,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6446,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6447,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6448,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6449,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6450,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6451,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6452,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6453,"@Override
public void clear() {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
6454,private int minIdlePerKey;,0
6455,private boolean testOnReturn;,0
6456,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (this.testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (this.maxIdlePerKey >= 0 && (pool.queue.size() >= this.maxIdlePerKey)) {
shouldDestroy = true;
} else if (success) {
if (this.lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
6457,private boolean testOnBorrow;,0
6458,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6459,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6460,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
for (K key : _poolMap.keySet()) {
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6461,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6462,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = this.testWhileIdle;
minEvictableIdleTimeMillis = this.minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((this.lifo && !_evictionCursor.hasPrevious()) || (!this.lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((this.lifo && !_evictionCursor.hasPrevious()) || (!this.lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = this.lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.getTstamp() > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.getValue());
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.getValue())) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.getValue());
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.getValue());
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (this.lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
6463,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
6464,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (K key : _poolMap.keySet()) {
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (ObjectTimestampPair<V> pair : list) {
map.put(pair, key);
}
}
Set<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final CursorableLinkedList<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
6465,"@Override
public void addObject(K key) throws Exception {
assertOpen();
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6466,"public int compareTo(ObjectTimestampPair<V> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6467,private boolean testOnReturn;,0
6468,private long maxWait;,0
6469,private int minIdlePerKey;,0
6470,private int maxTotal;,0
6471,private boolean lifo;,0
6472,private WhenExhaustedAction whenExhaustedAction;,0
6473,private int maxTotalPerKey;,0
6474,private int maxIdlePerKey;,0
6475,private boolean testWhileIdle;,0
6476,private boolean testOnBorrow;,0
6477,private long minEvictableIdleTimeMillis;,0
6478,private long timeBetweenEvictionRunsMillis;,0
6479,private int numTestsPerEvictionRun;,0
6480,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (this.testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((this.maxIdle >= 0) && (_pool.size() >= this.maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (this.getLifo()) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6481,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}",0
6482,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6483,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (this.maxTotal < 0 || (_numActive + _numInternalProcessing) < this.maxTotal)) {
Latch latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6484,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(this.lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((this.lifo && !_evictionCursor.hasPrevious()) || !this.lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(this.lifo ? _pool.size() : 0);
}
pair = this.lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.getTstamp();
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.getValue());
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.getValue())) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.getValue());
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.getValue());
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (this.lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
6485,private boolean testOnReturn;,0
6486,"@Override
public void addObject() throws Exception {
assertOpen();
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6487,private boolean testOnBorrow;,0
6488,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (this.maxTotal < 0 || (_numActive + _numInternalProcessing) < this.maxTotal)) {
Latch latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6489,private int numTestsPerEvictionRun;,0
6490,private boolean testOnBorrow;,0
6491,private int maxIdle;,0
6492,private long maxWait;,0
6493,private WhenExhaustedAction whenExhaustedAction;,0
6494,private int maxTotal;,0
6495,private long minEvictableIdleTimeMillis;,0
6496,private int minIdle;,0
6497,private boolean testOnReturn;,0
6498,private boolean lifo;,0
6499,private int numTestsPerEvictionRun;,0
6500,private long timeBetweenEvictionRunsMillis;,0
6501,private long softMinEvictableIdleTimeMillis;,0
6502,private boolean testWhileIdle;,0
6503,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(this.createReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6504,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(this.createReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6505,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6506,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6507,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6508,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6509,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6510,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6511,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6512,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6513,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6514,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6515,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6516,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6517,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6518,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6519,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6520,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6521,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6522,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6523,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6524,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6525,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6526,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6527,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6528,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6529,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
// Do nothing
}
}
}",0
6530,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6531,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
6532,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6533,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6534,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6535,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6536,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6537,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6538,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6539,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6540,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6541,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6542,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6543,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6544,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6545,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6546,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6547,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6548,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6549,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6550,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6551,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6552,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6553,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6554,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
6555,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6556,"public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
PooledObject<T> underTest = null;
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
keyCopy.addAll(poolKeyList);
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis()) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest.getObject());
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest.getObject())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest.getObject());
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}",0
6557,"public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
if (hasBorrowWaiters()) {
reuseCapacity();
}
updateStatsReturn(activeTime);
}",0
6558,"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0
6559,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6560,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6561,"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0
6562,"private boolean reuseCapacity() {
final int maxTotalPerKey = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKey && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
boolean success = false;
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
success = true;
}
} catch (Exception ex) {
} finally {
deregister(loadedKey);
}
}
return success;
}",0
6563,"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0
6564,"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0
6565,"public void clear(K key) {
register(key);
try {
ObjectDeque<T> objectDeque = poolMap.get(key);
if (objectDeque == null) {
return;
}
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
p = idleObjects.poll();
}
} finally {
deregister(key);
}
}",0
6566,"public T borrowObject(long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWait < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p.getObject());
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0
6567,"public T borrowObject(long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWait < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p.getObject());
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0
6568,"public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
long idleSoftEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
if (getSoftMinEvictableIdleTimeMillis() > 0) {
idleSoftEvictTime = getSoftMinEvictableIdleTimeMillis();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis() || (idleSoftEvictTime < underTest.getIdleTimeMillis() && getMinIdle() < idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
return;
}",0
6569,"@Override
public void clear() {
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",0
6570,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6571,"@Override
public void returnObject(T obj) {
PooledObject<T> p = allObjects.get(obj);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(obj)) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(obj);
} catch (Exception e1) {
try {
destroy(p);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdle();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(p);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
updateStatsReturn(activeTime);
}",0
6572,"public synchronized boolean endEvictionTest(LinkedBlockingDeque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.MAINTAIN_EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.MAINTAIN_EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6573,"public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
6574,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6575,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6576,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6577,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6578,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6579,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6580,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6581,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6582,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6583,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6584,"E setValue(E val) {
E temp = _val;
_val = val;
return temp;
}",0
6585,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (this.testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (this.maxIdlePerKey >= 0 && (pool.queue.size() >= this.maxIdlePerKey)) {
shouldDestroy = true;
} else if (success) {
if (this.lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6586,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6587,"@Override
public void addObject(K key) throws Exception {
assertOpen();
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6588,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6589,"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (K key : _poolMap.keySet()) {
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (ObjectTimestampPair<V> pair : list) {
map.put(pair, key);
}
}
Set<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
6590,"@Override
public void clear() {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
6591,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6592,"public int compareTo(ObjectTimestampPair<V> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6593,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6594,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6595,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
for (K key : _poolMap.keySet()) {
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6596,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6597,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6598,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (this.testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((this.maxIdle >= 0) && (_pool.size() >= this.maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (this.getLifo()) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6599,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(this.lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((this.lifo && !_evictionCursor.hasPrevious()) || !this.lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(this.lifo ? _pool.size() : 0);
}
pair = this.lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.getTstamp();
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.getValue());
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.getValue())) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.getValue());
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.getValue());
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (this.lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
6600,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (this.maxTotal < 0 || (_numActive + _numInternalProcessing) < this.maxTotal)) {
Latch latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6601,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (this.maxTotal < 0 || (_numActive + _numInternalProcessing) < this.maxTotal)) {
Latch latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6602,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}",0
6603,"@Override
public void addObject() throws Exception {
assertOpen();
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6604,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (this.maxTotal < 0 || (_numActive + _numInternalProcessing) < this.maxTotal)) {
Latch latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6605,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6606,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6607,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6608,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6609,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6610,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6611,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6612,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6613,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6614,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
6615,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
6616,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6617,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
6618,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
6619,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6620,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
6621,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
6622,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6623,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6624,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6625,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6626,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6627,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6628,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6629,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6630,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
6631,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6632,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
6633,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6634,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6635,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
6636,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
6637,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
6638,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
6639,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6640,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6641,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6642,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6643,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6644,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6645,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6646,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6647,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6648,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6649,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6650,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6651,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6652,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6653,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6654,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6655,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6656,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6657,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6658,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6659,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6660,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6661,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6662,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6663,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6664,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6665,"public void run() {
ThreadLocal keys = null;
try {
keys = objectPool.getOwningCompositeKeyedObjectPool().getKeys();
keys.set(key);
objectPool.getFactory().destroyObject(obj);
} catch (Exception e) {
} finally {
if (keys != null) {
keys.set(null);
}
}
}",0
6666,"public void run() {
try {
objectPool.getFactory().destroyObject(obj);
} catch (Exception e) {
}
}",0
6667,"private void close(final Object key) {
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
pool.close();
synchronized (objectPools) {
if (pool.getNumActive() == 0) {
objectPools.remove(key);
pool.close();
}
}
} catch (Exception e) {
// XXX: In pool 3 this catch block will not be necessary and shouled be removed
} finally {
if (keys != null) {
keys.set(null);
}
}
}",0
6668,"// XXX: Add better handling of when this instance is not Serializable
private final ObjectPoolFactory poolFactory;",0
6669,"public String toString() {
final StringBuffer sb = new StringBuffer(128);
sb.append(""CompositeKeyedObjectPool{"");
sb.append(""poolFactory="").append(poolFactory);
sb.append("", open="").append(open);
try {
final int numActive = getNumActive();
sb.append("", activeObjects="").append(numActive);
} catch (Exception e) {
}
try {
final int numIdle = getNumIdle();
sb.append("", idleObjects="").append(numIdle);
} catch (Exception e) {
}
sb.append('}');
return sb.toString();
}",0
6670,"public String toString() {
final StringBuffer sb = new StringBuffer(128);
sb.append(""CompositeKeyedObjectPool{"");
sb.append(""poolFactory="").append(poolFactory);
sb.append("", open="").append(open);
try {
final int numActive = getNumActive();
sb.append("", activeObjects="").append(numActive);
} catch (Exception e) {
}
try {
final int numIdle = getNumIdle();
sb.append("", idleObjects="").append(numIdle);
} catch (Exception e) {
}
sb.append('}');
return sb.toString();
}",0
6671,"public String toString() {
final StringBuffer sb = new StringBuffer(128);
sb.append(""CompositeObjectPool{"");
if (factoryConfig != null) {
sb.append(factoryConfig);
} else {
sb.append(""factory="").append(factory);
sb.append("", lender="").append(lender);
sb.append("", manager="").append(manager);
sb.append("", tracker="").append(tracker);
sb.append("", validateOnReturn="").append(validateOnReturn);
}
sb.append("", open="").append(open);
try {
final int numActive = getNumActive();
sb.append("", activeObjects="").append(numActive);
} catch (Exception e) {
}
try {
final int numIdle = getNumIdle();
sb.append("", idleObjects="").append(numIdle);
} catch (Exception e) {
}
sb.append('}');
return sb.toString();
}",0
6672,private final transient List pool;,0
6673,private final transient List pool;,0
6674,"// XXX: Add better handling of when this instance is not Serializable
private final PoolableObjectFactory factory;",0
6675,private final transient Object lock = new Object();,0
6676,"// XXX: Add better handling of when this instance is not Serializable
private final PoolableObjectFactory factory;",0
6677,"// XXX: Add better handling of when this instance is not Serializable
private final PoolableObjectFactory factory;",0
6678,"public Object borrow() {
final EvictorReference ref = (EvictorReference) super.borrow();
Object obj = null;
if (ref != null) {
synchronized (ref) {
obj = ref.get();
ref.clear();
}
}
return obj;
}",0
6679,private final transient ThreadLocal cause = new ThreadLocal();,0
6680,private Object referant;,0
6681,"public void run() {
if (referant == null) {
cancel();
return;
}
final PoolableObjectFactory factory = getObjectPool().getFactory();
synchronized (InvalidEvictorReference.this) {
Object r = referant;
while (r instanceof LenderReference) {
r = ((LenderReference) r).get();
}
if (r == null) {
clear();
return;
}
try {
factory.activateObject(r);
if (factory.validateObject(r)) {
factory.passivateObject(r);
} else {
factory.destroyObject(r);
clear();
}
} catch (Exception e) {
clear();
}
}
}",0
6682,"public void run() {
if (referant == null) {
cancel();
return;
}
final PoolableObjectFactory factory = getObjectPool().getFactory();
synchronized (InvalidEvictorReference.this) {
Object r = referant;
while (r instanceof LenderReference) {
r = ((LenderReference) r).get();
}
if (r == null) {
clear();
return;
}
try {
factory.activateObject(r);
if (factory.validateObject(r)) {
factory.passivateObject(r);
} else {
factory.destroyObject(r);
clear();
}
} catch (Exception e) {
clear();
}
}
}",0
6683,"// XXX: Add better handling of when this instance is not Serializable
private final KeyedPoolableObjectFactory delegate;",0
6684,protected final transient ReferenceQueue rq = new ReferenceQueue();,0
6685,private transient volatile int active = 0;,0
6686,"public void borrowed(final Object obj) {
active++;
}",0
6687,"public void returned(final Object obj) throws IllegalStateException {
if (--active < 0) {
active++;
throw new IllegalStateException(""More objects returned than were borrowed. Most recent object: "" + obj);
}
}",0
6688,"public boolean addAll(Collection c) {
checkForComod();
return super.addAll(c);
}",0
6689,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6690,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
6691,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
6692,"public synchronized void evict() throws Exception {
Object key = null;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
boolean removeObject = false;
if ((_minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if (_minIdle == 0) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
if (objectQueue != null && objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
} catch (Exception e) {
;
}
}
}
}",0
6693,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
synchronized (this) {
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
6694,"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0
6695,"public void run() {
try {
evict();
} catch (Exception e) {
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6696,"public synchronized void clear() {
for (Iterator entries = _poolMap.entrySet().iterator(); entries.hasNext(); ) {
final Map.Entry entry = (Map.Entry) entries.next();
final Object key = entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (entry.getValue())).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
}
_poolMap.clear();
_poolList.clear();
_totalIdle = 0;
notifyAll();
}",0
6697,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
6698,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0
6699,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = false;
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (decrementNumActive) {
pool.decrementActiveCount();
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
}
}
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
}",0
6700,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
}
}
}",0
6701,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
}
}
}",0
6702,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6703,"public synchronized void clear() {
for (Iterator it = _pool.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
_pool.clear();
notifyAll();
}",0
6704,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
}
}
}",0
6705,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
}
}
}",0
6706,"public void run() {
try {
evict();
} catch (Exception e) {
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6707,"public synchronized void evict() throws Exception {
assertOpen();
if (!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0) && (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0) && (idleTimeMilis > _softMinEvictableIdleTimeMillis) && (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if (_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
}
}
}",0
6708,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = false;
synchronized (this) {
if (decrementNumActive) {
_numActive--;
}
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
}
}
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6709,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
6710,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
6711,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
6712,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
_factory.passivateObject(obj);
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6713,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6714,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6715,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
6716,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6717,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6718,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6719,"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0
6720,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
6721,"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
6722,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6723,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
_factory.passivateObject(obj);
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6724,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6725,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6726,"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0
6727,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",0
6728,"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6729,"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6730,"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6731,"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6732,"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6733,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6734,"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6735,"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6736,"public void returnObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6737,"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6738,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6739,"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6740,"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6741,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6742,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6743,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6744,"public void returnObject(final T obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6745,"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6746,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6747,"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6748,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6749,"@Override
public E removeLast() {
checkForComod();
return super.removeLast();
}",0
6750,"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6751,"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6752,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6753,"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6754,"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
6755,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6756,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6757,"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0
6758,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6759,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6760,"private void addObjectToPool(K key, V obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
6761,"private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6762,"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6763,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
6764,"@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6765,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6766,"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6767,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6768,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6769,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6770,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6771,"@Deprecated
protected int _totActive = 0;",0
6772,"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6773,"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6774,"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0
6775,"@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6776,"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6777,"@Deprecated
protected int _totIdle = 0;",0
6778,"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6779,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6780,"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6781,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6782,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6783,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6784,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6785,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6786,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6787,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6788,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6789,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6790,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6791,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6792,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6793,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6794,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
6795,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6796,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6797,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6798,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6799,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6800,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6801,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6802,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6803,"public void close() {
if (_valid) {
_valid = false;
unregisterCursor(this);
}
}",0
6804,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6805,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
6806,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6807,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
6808,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6809,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6810,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6811,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
6812,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6813,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6814,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
6815,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
6816,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6817,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6818,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6819,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6820,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6821,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6822,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6823,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
6824,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
6825,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6826,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6827,"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll();
}",0
6828,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6829,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6830,protected int _totIdle = 0;,0
6831,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6832,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6833,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6834,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6835,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6836,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6837,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception e) {
}
}",0
6838,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
6839,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
6840,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0
6841,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6842,"void cancel() {
scheduledFuture.cancel(false);
}",0
6843,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy.fillInStackTrace();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
6844,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6845,"@Override
public int compareTo(final PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
6846,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6847,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6848,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6849,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6850,private long createCount = 0;,0
6851,private int numActive = 0;,0
6852,"@Override
public synchronized void returnObject(final T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
6853,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
6854,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6855,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6856,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6857,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6858,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6859,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6860,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6861,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6862,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6863,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6864,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6865,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6866,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6867,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6868,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6869,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6870,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6871,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6872,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
6873,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
6874,"protected void listableInserted(Listable elt) {
if (null == _cur.next() && null == _cur.prev()) {
_cur.setNext(elt);
} else if (_cur.prev() == elt.prev()) {
_cur.setNext(elt);
}
if (_cur.next() == elt.next()) {
_cur.setPrev(elt);
}
if (_lastReturned == elt) {
_lastReturned = null;
}
}",0
6875,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0
6876,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0
6877,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6878,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6879,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6880,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
6881,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
6882,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0
6883,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0
6884,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
6885,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6886,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0
6887,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
6888,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6889,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0
6890,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
6891,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
6892,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6893,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6894,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
6895,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0
6896,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6897,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6898,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6899,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
6900,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
6901,protected int _totIdle = 0;,0
6902,protected int _totActive = 0;,0
6903,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
6904,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6905,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
6906,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
6907,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
6908,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6909,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6910,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
6911,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6912,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6913,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6914,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6915,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
6916,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6917,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
6918,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
6919,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
6920,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
6921,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
6922,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
6923,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
6924,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6925,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
6926,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
6927,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6928,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6929,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
6930,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
6931,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0
6932,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6933,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception e) {
}
}",0
6934,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
6935,"void cancel() {
scheduledFuture.cancel(false);
}",0
6936,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6937,"@Override
public int compareTo(final PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
6938,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy.fillInStackTrace();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
6939,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6940,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
6941,"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
6942,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6943,private int numActive = 0;,0
6944,"@Override
public synchronized void returnObject(final T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
6945,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
6946,private long createCount = 0;,0
6947,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception ignored) {
}
}",0
6948,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6949,"@Override
public void close() {
try {
pool.close();
} catch (final Exception ignored) {
}
}",0
6950,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception ignored) {
}
}",0
6951,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception ignored) {
}
}",0
6952,PooledObjectState getState();,0
6953,"void cancel() {
scheduledFuture.cancel(false);
}",0
6954,"@SuppressWarnings(""unchecked"")
protected E cast(final Throwable throwable) {
return (E) throwable;
}",0
6955,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowInstant = now();
lastUseInstant = lastBorrowInstant;
borrowedCount++;
if (logAbandoned) {
borrowedBy.fillInStackTrace();
}
return true;
}
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
}
return false;
}",0
6956,"@Override
public int compareTo(final PooledObject<T> other) {
final int compareTo = getLastReturnInstant().compareTo(other.getLastReturnInstant());
if (compareTo == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return compareTo;
}",0
6957,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && getNumIdle() < 2 && getNumActive() > getMaxTotal() - 3) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitMillis < 0 ? objectDeque.getIdleObjects().takeFirst() : objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
} catch (InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitMillis="" + borrowMaxWaitMillis));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
6958,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
underTest.endEvictionTest(idleObjects);
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6959,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
underTest.endEvictionTest(idleObjects);
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6960,"public T borrowObject(final Duration borrowMaxWaitDuration) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && getNumIdle() < 2 && getNumActive() > getMaxTotal() - 3) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitDuration.isNegative() ? idleObjects.takeFirst() : idleObjects.pollFirst(borrowMaxWaitDuration);
} catch (final InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitDuration="" + borrowMaxWaitDuration));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p, DestroyMode.NORMAL);
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
6961,private int numActive;,0
6962,private long createCount;,0
6963,"@Override
public synchronized void returnObject(final T obj) throws E {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception ignored) {
}
}
}",0
6964,"@Override
public synchronized void addObject() throws E {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception ignored) {
}
}
}",0
6965,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0
6966,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6967,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception e) {
}
}",0
6968,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
6969,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
6970,PooledObjectState getState();,0
6971,"void cancel() {
scheduledFuture.cancel(false);
}",0
6972,"@SuppressWarnings(""unchecked"")
protected E cast(final Throwable throwable) {
return (E) throwable;
}",0
6973,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowInstant = now();
lastUseInstant = lastBorrowInstant;
borrowedCount++;
if (logAbandoned) {
borrowedBy.fillInStackTrace();
}
return true;
}
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
}
return false;
}",0
6974,"@Override
public int compareTo(final PooledObject<T> other) {
final int compareTo = getLastReturnInstant().compareTo(other.getLastReturnInstant());
if (compareTo == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return compareTo;
}",0
6975,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
}
if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
6976,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6977,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6978,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitMillis < 0 ? objectDeque.getIdleObjects().takeFirst() : objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
} catch (InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitMillis="" + borrowMaxWaitMillis));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
6979,"public T borrowObject(final Duration borrowMaxWaitDuration) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitDuration.isNegative() ? idleObjects.takeFirst() : idleObjects.pollFirst(borrowMaxWaitDuration);
} catch (final InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitDuration="" + borrowMaxWaitDuration));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p, DestroyMode.NORMAL);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
6980,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6981,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
6982,private long createCount;,0
6983,private int numActive;,0
6984,"@Override
public synchronized void returnObject(final T obj) throws E {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
6985,"@Override
public synchronized void addObject() throws E {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
6986,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6987,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
6988,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
6989,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6990,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
6991,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
6992,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6993,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6994,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6995,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
6996,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
6997,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
6998,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
6999,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7000,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7001,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
7002,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7003,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7004,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
7005,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
7006,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7007,"private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext(); ) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
} finally {
synchronized (this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}",0
7008,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
7009,"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}",0
7010,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
7011,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
7012,"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}",0
7013,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
7014,"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0
7015,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
7016,"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0
7017,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
7018,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
7019,"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}",0
7020,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
7021,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
7022,"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0
7023,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
7024,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
7025,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
7026,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
7027,"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}",0
7028,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
7029,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7030,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7031,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7032,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
7033,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
7034,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
7035,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
7036,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
7037,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
7038,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7039,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7040,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
7041,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7042,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
7043,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7044,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7045,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7046,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7047,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7048,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
7049,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
7050,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
7051,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7052,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7053,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
7054,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
7055,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7056,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7057,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
7058,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
7059,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7060,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7061,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
7062,"public void run() {
// Evict from the pool
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
// Re-create idle instances.
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
7063,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
7064,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0
7065,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
7066,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
7067,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0
7068,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
7069,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
7070,"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
7071,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0
7072,"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
7073,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7074,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7075,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7076,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
7077,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
7078,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
7079,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
7080,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
7081,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
7082,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
7083,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7084,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7085,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7086,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
7087,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
7088,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7089,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7090,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7091,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
7092,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
7093,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
7094,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
7095,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
7096,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
7097,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
7098,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
7099,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
7100,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
7101,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
7102,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
7103,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7104,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7105,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
7106,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7107,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
7108,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
7109,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
7110,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
7111,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
7112,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
7113,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
7114,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
7115,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
7116,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
7117,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
7118,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0
7119,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
7120,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
7121,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7122,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7123,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
7124,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7125,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
7126,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
7127,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
7128,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
7129,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
7130,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
7131,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
7132,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
7133,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
7134,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
7135,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
7136,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
7137,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
7138,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
7139,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
7140,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
7141,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (final Exception e) {
}
}",0
7142,"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0
7143,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0
7144,"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0
7145,PooledObjectState getState();,0
7146,"void cancel() {
scheduledFuture.cancel(false);
}",0
7147,"@SuppressWarnings(""unchecked"")
protected E cast(final Throwable throwable) {
return (E) throwable;
}",0
7148,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowInstant = now();
lastUseInstant = lastBorrowInstant;
borrowedCount++;
if (logAbandoned) {
borrowedBy.fillInStackTrace();
}
return true;
}
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
}
return false;
}",0
7149,"@Override
public int compareTo(final PooledObject<T> other) {
final int compareTo = getLastReturnInstant().compareTo(other.getLastReturnInstant());
if (compareTo == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return compareTo;
}",0
7150,"@Override
public synchronized boolean endEvictionTest(final Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
}
if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
7151,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
7152,"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
7153,"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitMillis < 0 ? objectDeque.getIdleObjects().takeFirst() : objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
} catch (InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitMillis="" + borrowMaxWaitMillis));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
7154,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
7155,"public T borrowObject(final Duration borrowMaxWaitDuration) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitDuration.isNegative() ? idleObjects.takeFirst() : idleObjects.pollFirst(borrowMaxWaitDuration);
} catch (final InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitDuration="" + borrowMaxWaitDuration));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p, DestroyMode.NORMAL);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0
7156,"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
7157,private int numActive;,0
7158,private long createCount;,0
7159,"@Override
public synchronized void addObject() throws E {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
7160,"@Override
public synchronized void returnObject(final T obj) throws E {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0
7161,"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0
7162,"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0
7163,"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7164,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7165,"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7166,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7167,"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0
7168,"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7169,"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
7170,"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0
7171,"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7172,"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
7173,"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7174,"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0
7175,"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
7176,"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7177,"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0
7178,"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0
7179,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7180,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7181,"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7182,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
7183,"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0
7184,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
7185,"public synchronized void clear() {
for (Iterator entries = _poolMap.entrySet().iterator(); entries.hasNext(); ) {
final Map.Entry entry = (Map.Entry) entries.next();
final Object key = entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (entry.getValue())).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
}
_poolMap.clear();
_poolList.clear();
_totalIdle = 0;
notifyAll();
}",0
7186,"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0
7187,"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
synchronized (this) {
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0
7188,"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
notifyAll();
}
}
}",0
7189,"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0
7190,"public void run() {
try {
evict();
} catch (Exception e) {
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
7191,"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
notifyAll();
}
}
}
}
}",0
7192,"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e2) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",0
7193,"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0
7194,"public synchronized void evict() throws Exception {
Object key = null;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
boolean removeObject = false;
if ((_minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > _minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if (_minIdle == 0) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
if (objectQueue != null && objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
} catch (Exception e) {
;
}
}
}
}",0
7195,"public void run() {
try {
evict();
} catch (Exception e) {
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0
7196,"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
notifyAll();
}
}
}
}",0
7197,"public synchronized void clear() {
for (Iterator it = _pool.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
_pool.clear();
notifyAll();
}",0
7198,"public synchronized void clear() {
for (Iterator it = _pool.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
_pool.clear();
notifyAll();
}",0
7199,"public synchronized void evict() throws Exception {
assertOpen();
if (!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0) && (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0) && (idleTimeMilis > _softMinEvictableIdleTimeMillis) && (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if (_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
}
}
}",0
7200,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0
7201,"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
notifyAll();
}
}
}",0
7202,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7203,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7204,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7205,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
7206,"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0
7207,"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0
7208,"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0
7209,"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0
7210,"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0
7211,"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0
7212,"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7213,"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0
7214,"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0
7215,"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0
7216,"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0
7217,"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0
7218,"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0
7219,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(Object other) {
return ((IdentityWrapper) other).instance == instance;
}",0
7220,"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(Object other) {
return ((IdentityWrapper) other).instance == instance;
}",0
7221,"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0
7222,"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0
7223,"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0
7224,"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
7225,"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0
7226,"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0
7227,"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0
7228,"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0
7229,"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0
7230,"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0
7231,"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0
7232,"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0
7233,"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
7234,"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0
